ER[BS];*I = 127TARGET[ILC];%BYTE INSTRUCTIONSBYTE POINTERS HAVE THE FORMAT:   B[0,5]   P-FIELD (NO. BITS TO RIGHT OF BYTE)   B[6,13]  S-FIELD (SIZE OF BYTE)   B[14]    IGNORED   B[15], B[16,21], B[22,43] I, X, AND E FOR EFF. ADDR. CALC.SPECIAL NOTES:   FOR P>=44 NO BYTE IS PROCESSED   S + P > 44 REFERS TO A BYTE OF SIZE 44-P   INCREMENTING THE BYTE POINTER IS AS FOLLOWS:  IF (P_P-S) < 0, THEN(P_(44-S) MOD 100) AND (BP[15,43]_BP[15,43]+1)   INCREMENTING THE BYTE POINTER TAKES PLACE BEFORE LOADING OR DEPOSITING%MC[BIS&J,BIS,J];%TO "IBP" FROM MAIN LOOP AFTER MAPVA_P_E OR FROM "RMWBPC" WITH J=1.TIMING = M+R+W+5 (R+W=2 + (1 IF WORD BOUNDARY CROSSED) IF B.P. IN AC)I = 14%	LEFADR_P OR Q, Q_RMWMQ, CALL[LOADMAP];IBP:	RMWREF, Q_LX, MDR_X, INHINT, CALL[IBPAC,G=1], REFADR_P;	GOTO[.-2,G=1], Q_RMWLE;	P_BSPLIT_MDR, SETFC[BIS&J,J=1], Q_7777 777777R;	Q_XTOP, SETF[J], RTEMP_P AND Q;	MDR_P-Q-NJ, P_RTEMP;	RETURN[J=1], P_P+1, WRESTART, X_20S; *KNOW LTEMP=20	P_(P) U (440000 000000S), INHINT;IBP1:	LX_MDR_P-Q, RETURN, SETF[J]; *RESULT INTO MDR FOR ISPLIT_ LATERIBPAC:	P_BSPLIT_Q, GOTO[RMWAMDR,H=1], Q_7777 777777R;	Q_XTOP, RTEMP_P AND Q, POP, SETFC[BIS&J,J=1];	X_MDR, SETF[J];	MDR_LX_P-Q-NJ, P_RTEMP, DGOTO[IBP1];	RETURN[J=1], P_(P+1) U (440000 000000S);%"RMWBPC" ENTERED FROM THE MAIN LOOP AFTER MAPVA_P_E.  IT GOES TO "RBP"IF BIS WAS SET; OTHERWISE, IT SETS BIS AND J, INCREMENTS THE BYTEPOINTER, AND RETURNS WITH THE INCREMENTED BYTE POINTER IN MDR.TIMING = 7+R+W + (2+R PER BYTE POINTER INDIRECT) (R+W=5 FOR AC)I = 2%RMWBPC:	SETSF[BIS&J], DGOTO[IBP];	SETF[J], GOTO[RBP,J=1];*TO "RBP" AFTER MAPVA_P_E IN THE MAIN LOOP.  RETURN AFTER MAPVA_P_E OF BYTE*WITH SIZE AND POSITION FIELDS OF BYTE POINTER IN RTEMP.SM[XCT0,IP[10 000000S]]; ***MC[XCT2&K,XCT2,K];SM[XCT1,IP[4 000000S]];*I = 9RBP5:	P_MAPVA_(MDR) U (ACBASE), A1, CALL[RREFX];	Q_RLE, RETURN[G=0]; *RETURN ALWAYS TO RBP0	LEFADR_P OR Q, Q_RMQ, CALL[LOADMAP];RBP:	RREF, Q_LX, MDR_X, REFADR_P, GOTO[.-2,G=0], SETSF[XCT2&K];	P_ISPLIT_Q, GOTO[RBP5,H=1];	Q_LINDX, INSTR_P, SETFB[XCT0,K=1], POP, GOTO[BINDE,K=1];	GOTO[BINDE];RBP0:	P_ISPLIT_MDR, DGOTO[BINDE];	Q_LINDX, INSTR_P, SETFB[XCT0,K=1], GOTO[BINDE,K=1];*MUST WAIT ONE CYCLE AFTER CHANGING XCT1 BEFORE REFSETXCT1: SETF[XCT1], GOTO[RETN];%ENTER AT "DPB" WITH BYTE POINTER IN INSTR AFTER MAPVA_E OF BYTEK=1 IFF XCT3=1 (SET BY "BINDE")TIMING = 6+R+W + (2 IF FUNNY XCT) (R+W=5 IF DATA IN AC)I = 25%DPBX:	RTEMP_P AND Q, CLEARFC[BIS&J,J=1];PTOQ:	Q_P, RETURN;	LEFADR_P, Q_RMWMQ, CALL[LOADMAP];DPB:	CALL[SETXCT1,K=1], P_(REFADR_P) U (RMWLE);	RMWREF, MDR_X, Q_INSTR, INHINT, CALL[DPBAC,G=1];	A0, GOTO[.-3,G=1];*ENTRY HERE FOR BLISP DATA TYPE STUFFBDPB:	BSPLIT_Q, Q_A0, GOTO[PMDR,ALU#0];	P_A1, XMASK, Q_LAC, X_20S, CALL[DPBX]; *KNOW LTEMP=20	0Q RCY [44-Y], Q_MDR;DPBY:	LTEMP_NOT P AND Q, Q_RTEMP, WRESTART, DECAC, RETURN[H=1];	0Q RCY [44-Y], Q_LTEMP, INHINT;	LX_MDR_P OR Q, RETURN;DPBAC:	BSPLIT_Q, GOTO[RMWAMDR,H=1];	P_A1, XMASK, Q_LAC, X_MDR, CALL[DPBX];	0Q RCY [44-Y], Q_LX, POP, GOTO[DPBY];*TO "LDB" WITH BYTE POINTER IN INSTR AFTER MAPVA_E OF BYTE*TIMING = 5+R + (1 IF NO BYTE) + (2 IF FUNNY XCT) (R=1 IF DATA IN AC)	LEFADR_P, Q_RMQ, CALL[LOADMAP];LDB:	CALL[SETXCT1,K=1], P_(REFADR_P) U (RLE);	CALL[LDBAC,G=1], RREF, MDR_X, Q_INSTR;	GOTO[.-3,G=1];	BSPLIT_Q, DGOTO[LDBAC1];	P_MDR, Q_A0, CLEARFC[BIS&J,J=1], GOTO[LDBAC1,J=1];LDBAC:	P_LX, BSPLIT_Q, GOTO[RAMDR,H=1];	Q_A0, CLEARFC[BIS&J,J=1], POP;LDBAC1:	PQ RCY [Y], XMASK, DGOTO[SETZ];	LAC_P, ENDM[H=0];DI[133,IBP,REMAPPC,SCRASH];DI[134,RMWBPC,RBP0,LDB];DI[135,RBP,RBP0,LDB];DI[136,RMWBPC,RBP0,DPB];DI[137,RBP,RBP0,DPB];%SHIFT INSTRUCTIONS:TIMING (SHIFT COUNT <=44):   LSH    M + 5 = 14 CYCLES   ROT    M + 4(L) OR 5(R) = 13 CYCLES (LEFT) OR 14 (RIGHT)   ASH    M + 5(R) + 1 IF NUMBER < 0 = 14 OR 15 CYCLES RIGHT          M + 5(L) + 1/SHIFT = 14 + E CYCLES LEFT   LSHC   M + 6(L) OR 7(R) = 15 CYCLES (LEFT) OR 16 CYCLES (RIGHT)   ROTC   M + 6(L) OR 7(R) = 15 CYCLES (LEFT) OR 16 CYCLES (RIGHT)   ASHC   M + 8(R) = 17 CYCLES RIGHT          M + 6(L) + 1/SHIFT = 15 + E CYCLES LEFTMICROINSTRUCTIONS:   SHFT   1   LSH    11   ROT    1   ASH    7   CSHFT  7   LSHCL  3   LSHCR  3   ROTCL  3   ROTCR  3   ASHC   16TOTAL     55%*ACCEPTS E IN P FROM MAIN LOOPSHFT:	YSHIFT_P, P_Q_LAC, RETURN;LSH:	GOTO[LSHL0,Y>=0], RTEMP_P, Q_NULL;LSHR0:	NEGY;LSHR:	PQ RCY [Y];	LAC_P, RETURN[H=0];	LTEMP_Q, P_Y, Q_44R, DGOTO[LSHR];	Y_P-Q, P_Q_LTEMP, CALL[RETN];  *LOOP FOR ROT NOT LSHLSHL0:	Q_RTEMP, P_A0, GOTO[LSHL];ROT:	RTEMP_P, GOTO[LSHR0,Y<0];LSHL:	PQ RCY [44-Y], Q_P;	LAC_P, RETURN[H=0];	LTEMP_Q, P_Y, Q_44R, DGOTO[LSHL];	Y_P-Q, P_Q_LTEMP, CALL[RETN];  *LOOP FOR ROT NOT LSHASH:	GOTO[ASHL,Y>=0], RTEMP_P, Q_NULL;	NEGY, GOTO[LSHR,ALU>=0];ASHB:	Q_A1, GOTO[LSHR];ASHL:	DECY;	RETURN[Y<0], Q_A0, DECY;	PQ LCY [1], ASHOVF, DECY, GOTO[.,Y>=0];	RETURN;%CSHFT ACCEPTS E IN P.  ON E<0 (RIGHT SHIFT), LEAVES AC INRTEMP AND STEMP, -E IN Y, AC+1 IN LTEMP AND Q, AND LOW PART OFRESULT IN P.  AC POINTS TO AC+1 AND RESULT IS VALID IFF H=0.STACK IS POPPED BEFORE RETURN.ON E>=0 (LEFT SHIFT), LEAVES AC+1 IN RTEMP, TOP PART OF RESULT IN P,AC POINTS TO AC, E IS IN Y, AND AC IS IN Q.%CSHFT:	YSHIFT_P, INCAC, Q_LAC;	P_LAC, RTEMP_Q, GOTO[CSHFTL,Y>=0];	NEGY, POP, LTEMP_P, GOTO[.+2];CSHFTR:	LTEMP_P;	PQ RCY [Y], Q_P, STEMP_Q, RETURN;*NOTE MANDATORY 1 CYCLE WAIT BETWEEN Y_ AND RCY[44-Y]CSHFTL:	RTEMP_P;	PQ RCY [44-Y], DECAC, RETURN;LSHCL:	LAC_P, P_NULL, INCAC, Q_RTEMP, POP, GOTO[LSHL, H=0];	LAC_A0, P_Y, Q_44R, DGOTO[LSHL];	Y_P-Q, Q_RTEMP, P_LAC, DECAC, CALL[RETN];LSHCR:	LAC_P, DECAC, Q_NULL, P_RTEMP, GOTO[LSHR,H=0];	LAC_Q, P_Y, Q_44R, DGOTO[LSHR];	Y_P-Q, P_RTEMP, Q_LAC, INCAC, CALL[RETN];	Y_P-Q, P_LTEMP, Q_RTEMP, CALL[CSHFTL];ROTCL:	P_B, B_Q, LAC_P, INCAC, Q_RTEMP, POP, GOTO[LSHL,H=0];	P_Y, Q_44R, LTEMP_P, CALL[.-2]; *CALL TO CANCEL OUT POP	Y_P-Q, Q_LTEMP, P_RTEMP, INCAC, CALL[CSHFTR];ROTCR:	LAC_P, DECAC, P_STEMP, GOTO[LSHR,H=0];	P_Y, Q_44L, RTEMP_P, GOTO[.-2];*ACCEPTS E IN PASHC:	YSHIFT_P, INCAC, Q_LAC; **PATCHED	P_LAC, RTEMP_Q, GOTO[ASHCL,Y>=0], POP, Q_NULL, DECAC;	NEGY, POP, PQ LCY [1], Q_RTEMP, DGOTO[ASHCRP,ALU>=0];*Y CONTAINS THE SHIFT COUNT FOR A RIGHT SHIFT, RTEMP AND Q CONTAIN*LEFT HALF, P RIGHT HALF OF QUANTITY TO BE SHIFTED.  DGOTO IS PENDING IF*NUMBER >= 0.	PQ RCY [Y], Q_A0, INCAC;	PQ RCY [1], Q_400000 000000S, GOTO[.+2,H=1];	LAC_P OR Q, DECAC, P_RTEMP, Q_-1S, GOTO[LSHR];	DECAC, P_Y, Q_44R, LPGRT_A1;	Y_P-Q, P_RTEMP, Q_LPGRT;	LAC_Q_A1, PQ RCY [1], INCAC, GOTO[LSHR];ASHCRP: PQ RCY [1], Q_(RTEMP) RSH 1, GOTO[LSHCR,H=0];	RTEMP_Q, GOTO[LSHCR];ASHCL:	Q_2P, P_RTEMP, DECY, POP;	GOTO[REMAPPC,Y<0], P, DECY; *NO SHIFT IF COUNT=0	PQ LCY [1], ASHOVF, Q LSH 1, DECY, P, GOTO[.,Y>=0];	LAC_P, Q RSH 1, P_400000 000000S, INCAC, GOTO[QTOAC,ALU>=0];POQA:	LAC_P OR Q, ENDM;DI[242,SHFT,LSH,PTOAC];DI[241,SHFT,ROT,PTOAC];DI[240,SHFT,ASH,PTOAC];DI[244,ASHC,SCRASH,SCRASH];DI[245,CSHFT,ROTCL,ROTCR];DI[246,CSHFT,LSHCL,LSHCR];%BLT INSTRUCTIONE IS IN P AT THE CALL.RTEMP IS USED TO HOLD THE "UNTIL" FIELD, LAC THE FROM-TO, AND LTEMPTHE INCREMENTED FROM-TO.  AC IS CLOBBERED WITH AN UPDATED BLT POINTERBEFORE EACH WORD IS TRANSFERRED SO IT WINDS UP WITH FROM+UNTIL-TO IN THE L.H.AND WITH UNTIL IN THE R.H. (UNLESS IT IS THE LAST WORD WRITTEN BY BLT).AT LEAST ONE WORD IS TRANSFERRED REGARDLESS OF THE "UNTIL" FIELD.MUST ADVANCE AC AFTER THE WRITE AND AFTER THE END CHECK SO THAT THE BLT DOESN'TGO ASTRAY IF IT RANGES ACCROSS THE BLT POINTER AND SO THAT IF THE BLT AC IS THELAST WORD WRITTEN IT DOESN'T GET CLOBBEREDTIMING = M + 3 + (2 + R + W)/WORD TRANSFERRED WHERE R=3 AND W=6 FOR AC'SI = 23%BLT:	RTEMP_P, P_LAC, Q_1 000000S, GOTO[.+3];BLTLP:	P_LTEMP, SETSF[INTCONDH], GOTO[REMAPPC,ALU>=0];	LAC_P, GOTO[PI,H=1], Q_1 000000S;	LTEMP_P+Q+1, PQ RCY [22], SAMASK[22];	MAPVA_REFADR_P, GOTO[.+2];BLRML:	LEFADR_Q, Q_RMQ, CALL[LOADMAP];	RREF, Q_LX, GOTO[.+3,G=0];	MDR_Q, GOTO[.+3,H=0], P_ICTR, Q_P;	MAPVA_P_(Q) U (ACBASE), A1, CALL[RREFX];	GOTO[BLRML,G=1], Q_(P) U (RLE), P_ICTR;	P_LAC, BAMASK[22], ICTR_P+1, Q_BLTWLE;	MAPVA_REFADR_P, CALL[.+1];*! MAXC1 ONLY	MDR;*!	WREF, LEFADR_P OR Q, Q_RTEMP, GOTO[BWM1,G=0];BWM0:	P-Q, Q_MDR, GOTO[.+2,H=1];	LX_Q, FRZBALUBC, GOTO[BLTLP];	MAPVA_Q_(X) U (ACBASE), A1;	WREFDXK, Q_(Q) U (BLTWLE);	LEFADR_Q, Q_RTEMP;BWM1:	P-Q, GOTO[BLTLP,G=0], P_LEFADR;*LOADMAP RETURNS TO WREF ABOVE AND CAN'T HAPPEN TWICE	P_(P) U (WLE), Q_LTEMP, GOTO[.+2,ALU>=0];	LAC_Q, Q_WMQ, GOTO[LOADMAP];	LEFADR_P, Q_WMQ, GOTO[LOADMAP]; *DON'T DECREMENT PC IF LAST WRITE TRAPSDI[251,BLT,SCRASH,SCRASH];