<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12microcode.dm!3>jmc.mc</title>
  </head>
  <body>
    <pre>
ER[JMC];*I = 191TARGET[ILC];*! MAXC1 ONLYSV[XPARITY,2160];	*DISK INTERRUPT CHANNELS*!*~ MAXC2 ONLYSV[XPARITY,200 002160];	*DISK INTERRUPTS &amp; PARITY (700 002160 DOESN'T WORK)*~%FOR THE IN-OUT RESET ROUTINE, "KRESET" TURNS OFF ALL THE DISK UNITSBY "KOFF" (BUT DOES NOT RECALIBRATE).I = 4%	DECX, RETURN[X&lt;0];KRESET:	KUNIT&larr;X, DGOTO[.-1], LTEMP&larr;A1;	CALL[.+1,X&gt;=0], YKPTR&larr;X, INHINT;	KSET&larr;KOFFX, KNEWCOMM, INHINT, GOTO[.+3]; **NO KRDYW%"KOFF" IS A JMC WHICH:   1.  TURNS OFF SECTOR MICROINTERRUPTS, DISMISSES WORD INT., CLEARSERRORS, AND RECALIBRATES UNIT   2.  CLEARS THE INTERRUPT REQUEST BIT IN MICINTS FOR THIS UNIT   3.  MAXKA&larr;NULL (SO THAT "KGO" AND "KSEEK" WILL BE REJECTED)   4.  WIDISP&larr;CRASH (SO THAT FALSE DISPATCH INTS WILL CRASH)   5.  WCSA&larr;NULL (SO THAT FALSE READ AND WRITE INTS WILL WRITE A HARMLESSLOCATION AND CRASH)   6.  NSDISP&larr;NULL (SO THAT FALSE SECTOR INTS WILL CRASH)   7.  DESELECT THE UNITAT CALL:  KUNIT&larr;UNIT NO. HAS BEEN DONEI = 10%KOFF:	X&larr;KUNIT;	KSET&larr;KOFFL, KNEWCOMM, INHINT;  ***NO KRDYW	P&larr;LTEMP, AMASK[30], MAXKA&larr;KMDR&larr;NULL, DGOTO[SCRASH];	WIDISP&larr;NPC, P&larr;P+1, INHINT, GOTO[.+1];	Q&larr;KSTAT, A1, DGOTO[.+1];*CHECK "DESEL" TO SEE IF A UNIT IS REALLY THERE, ELSE "KRDYW" WILL HANG	P AND Q, WCSA&larr;NULL, INHINT, CALL[KRDYW,ALU=0];	KSET&larr;DESEL, KNEWCOMM, INHINT;	P&larr;A1, XMASK, INHINT, Q&larr;MICINTS;	P&larr;P+1, KA&larr;KWDATA, DGOTO[SCRASH];	Q&larr;NOT P AND Q, INHINT, NSDISP&larr;NPC, GOTO[KPIS1];%"PKSER" IS A SUBROUTINE TO LOOK AT EACH OF THE DISK UNITS AND DECIDEON WHICH UNIT A PARTICULAR DISK PACK IS MOUNTED.AT CALL: PACK NO. IN RTEMP[12,21], 7 IN X.AT RETURN: Y POINTS TO THE 16-WORD UNIT ARRAY FOR THE PACK AND KUNITPOINTS TO THE UNIT, MAXKA IN Q, P PRESERVED.  IF THE PACK IS OFF-LINE, THEILLEGAL PACK BIT IS RETURNED IN AC, AND AN IMMEDIATE EXIT IS MADE.I = 5%PKSER:	LPGRT&larr;P, YKPTR&larr;KUNIT&larr;X, P&larr;777777R;	Q&larr;MAXKA, P&larr;NOT P, BAMASK[32];	Q&larr;P AND Q, P&larr;RTEMP, DECX, DGOTO[QTOAC,X&lt;0];	P#Q, Q&larr;ILLPK, DGOTO[PKSER];	RETURN[ALU=0], P&larr;LPGRT, Q&larr;MAXKA;%"KON" IS ENTERED WITH THE MAXIMUM LEGAL DISK ADDRESS IN AC FOR UNIT E.IT RESETS THAT UNIT AND PUTS IT ON-LINE.  IF THE UNIT IS ALREADY ONLINE IT SERVES TO RESET THE UNIT AS FOLLOWS:   1.  NSDISP&larr;INTRET;   2.  ENABLE SECTOR INTERRUPTS AND CLEAR ERRORS   3.  MAXKA&larr;Q   4.  CMMA&larr;NMMA&larr;USTATE&larr;0   5.  ENABLE THE DISK MICROINTERRUPT CHANNELS   6.  KA&larr;PACK,,7770KBLK AND KPARAM SHOULD BE SET IN ADVANCE BY THE SLOC JMCTHERE ARE NO ERRORS.  KON ALWAYS SKIPS.I = 7%*YKPTR&larr;KUNIT&larr;E WAS DONE BY JMC DISPATCH INSTRUCTIONKON:	MAXKA&larr;Q, P&larr;LTEMP, AMASK[14], DGOTO[INTRET];	Q&larr;P OR Q, NSDISP&larr;NPC, INHINT, GOTO[.+1];	KSET&larr;SECERRS, KNEWCOMM, INHINT;	ARM&larr;XPARITY, INHINT;	CMMA&larr;KMDR&larr;NULL, P&larr;LTEMP, AMASK[3], DGOTO[KSEC2];	USTATE&larr;KWDATA, Q&larr;NOT P AND Q, DGOTO[.+1];	NMMA&larr;NULL, GOTO[ASKIP];%"KNOPDP" TURNS OFF THE PDP-10 PORTION OF DISK INTERRUPTS ON THE PACK SELECTED BY AC.  ERROR RETURN IF THE PACK NUMBER ISN'T FOUNDOR UNIT BUSY.  OTHERWISE, NSDISP&larr;@INTRET AND SKIP RETURN.AT CALL: PACK NUMBER IN Q, 377 000000 IN PI = 5%KNOPDP: RTEMP&larr;P AND Q, X&larr;7S, CALL[PKSER];	MDR&larr;NMMA, DGOTO[KNOP1];	P&larr;(MDR) U (CMMA), DGOTO[INTRET];CRJ:	Q&larr;ILLOP;	*COMMAND REJECT*! MAXC 1 ONLYILLRET:	Q&larr;(KSTAT) U (Q) U (USTATE), GOTO[QTOAC];*!*~ MAXC 2 ONLYILLRET:	P&larr;KSTAT;	Q&larr;(P OR Q) U (USTATE), GOTO[QTOAC];*~%"KSEEK" IS USED TO INITIATE A SEEK AND ENABLE PDP-10 INTERRUPTS.ERROR RETURNS WITH STATUS IN AC ARE GIVEN FOR:   1.  PACK NO. NOT ON-LINE   2.  ILLEGAL ARM POSITION   3.  SEEKING TO A DIFFERENT ARM POSITION ALREADY   4.  HARDWARE FAILUREOTHERWISE, A SKIP RETURN IS GIVEN.AT ENTRY: DISK ADDRESS (PACK AND ARM) IN Q AND IN AC, 377 000000 IN PI = 21%KSEEK1:	P&larr;(MDR) U (CMMA), DGOTO[KSERV];KNOP1:	P, Q&larr;NPC, GOTO[.+1];	P&larr;PC, GOTO[ASKIP1,ALU#0]; *BUSY?NSDASK:	NSDISP&larr;Q, GOTO[ASKIP];KSEEK:	RTEMP&larr;P AND Q, P&larr;7770S;	LTEMP&larr;P AND Q, X&larr;7S, CALL[PKSER];  *LTEMP&larr;NEW ARM POSITION	RTEMP&larr;P AND Q, Q&larr;KA; *RTEMP&larr;MAX. ARM POS.	P&larr;P AND Q, Q&larr;LTEMP, MDR&larr;NMMA; *P&larr;CURRENT ARM POS.	P#Q, P&larr;RTEMP,INHINT;*SEEK TO CURRENT POS. ENABLES PDP-10 INTERRUPTS IFF THEY ARE OFF	P-Q, PQ RCY [33], Q&larr;KSTAT, GOTO[KSEEK1,ALU=0];*CHECK FOR LEGAL ARM POSITION	GOTO[.+2,ALU&gt;=0], RPGRT2&larr;P, P&larr;NOSKER;	Q&larr;ILLARM, GOTO[ILLRET];*CHECK FOR HARDWARE ERRORS OR SEEKING	P AND Q, P&larr;(MDR) U (CMMA);	P, P&larr;KA, INHINT, GOTO[ILLRET,ALU#0];*SECTOR INTERRUPTS TABOO WHILE UPDATING KA	USTATE&larr;NULL, INHINT, GOTO[CRJ,ALU#0];	Q&larr;(NOT P) U (7770S), P&larr;LTEMP, DGOTO[KSERV];	Q&larr;P OR NOT Q, P&larr;RPGRT2, NSDISP&larr;NPC, GOTO[.+1], INHINT;	KA&larr;Q, Q&larr;P, CALL[KRDYW], INHINT;*LOAD CYLINDER REGISTER (MUST CALL KRDYW BECAUSE OF SECTOR INTS)*(KNOW (LOADC) WILL BE F1 = READS WHICH = KNEWCOMM)*USE "FSET" PURELY AS A GARBAGE ROUTINE TO ALLOW INTERRUPTS WHILE WAITING	KSET&larr;(Q) U (LOADC), INHINT, CALL[FSET];	INHINT, CALL[KRDYW];	KSET&larr;SEEK, KNEWCOMM, INHINT, GOTO[ASKIP];%"KGO" IS USED TO INITIATE ALL DATA TRANSFERS.  IT CAN BE ISSUED AT ANY TIMEAND NOTHING BAD WILL HAPPEN IF A SECTOR MICROINTERRUPT OCCURS INMEDIAS RES.  THE ADDRESS OF THE 9-WORD COMMAND BLOCK IS IN P.ERROR RETURNS WITH STATUS IN AC ARE GIVEN FOR:   1.  MAIN MEMORY ADDRESS &lt; 20   2.  PACK NOT ON-LINE   3.  ARM # CURRENT ARM POSITION OR SECTOR # NEXT SECTOR   4.  ILLEGAL HEAD SELECT   5.  ILLEGAL OPERATION #AT CALL:  Q CONTAINS VIRTUAL ADDRESS OF A DISK DATA TRANSFER COMMAND FORWHICH MAPVA&larr;P&larr;AQ, SAMASK[22] HAS JUST BEEN DONE.  A SKIPRETURN IS GIVEN IF THE COMMAND IS ACCEPTED.EACH COMMAND DISPATCH WORD CONTAINS AN INITIAL COMMAND DISPATCH IN B[30,43]AND 6 4-BIT BYTES IN B[0,27] CONTROLLING THE PATH OF THE DISK FINITESTATE MACHINE (SEE "DISPT" TABLE IN KINT)I = 13%F[FL,0,3]; F[FM,4,7]; F[FN,10,13]; F[FO,14,17]; F[FP,20,23]; F[FQ,24,27];M[KOP,XSLC[E1[#1]FL[#2]FM[#3]FN[#4]FO[#5]FP[#6]FQ[#7]]];SM[XSLC,IP[KCOMS]]; *BEGINNING OF COMMAND DISPATCH TABLE (10 WORDS)KOP[CSW,15,3];		*WRITE HEADERKOP[CSW,15,4,12,4,13,3];	*WRITE, WRITE, WRITEKOP[CSR,10,0,5,2];	*READ, READKOP[CSR,10,1,12,3];	*READ, WRITEKOP[CSR,10,0,5,0,7,2];	*READ, READ, READKOP[CSR,10,0,6,0,7,2];	*READ, COMPARE, READKOP[CSR,10,0,5,1,13,3];	*READ, READ, WRITEKOP[CSR,10,0,6,1,13,3];	*READ, COMPARE, WRITEKOP[CSR,10,1,12,4,13,3];*READ, WRITE, WRITEKOP[CSR,10,0,6,0,14,2]; *READ, COMPARE, CHECKSV[KPREH,777400 000000];	*LEADING BITS OF DISK HEADER***ERROR IF NOT RESIDENT PAGE, BUT NOT NECESSARILY IN MAPKGO:	CALL[RQARG]; *Q&larr;COMMAND AND DISK ADDRESS	Q&larr;(Q) U (KPREH), QQ RCY [33], DGOTO[KCOMS];	RPGRT2&larr;Q, Q&larr;NPC, PQ RCY [0], SAMASK[4], GOTO[.+1]; *RPGRT2&larr;DISK HEADER*COMMAND REJECT ERROR IF G=1 (COMMAND BLOCK IN AC)	Y&larr;P+Q, P&larr;RPGRT2, SAMASK[22], GOTO[CRJ,G=1]; *Y&larr;OPER. CODE + KCOMS	LPGRT&larr;P, Q&larr;SY, GOTO[CRJ,Y&gt;=0];	*Y-REG. OVF IF COMMAND NO. &gt; 11	LPGRT2&larr;Q, Q&larr;RPGRT2, P&larr;377 000000S; *LPGRT2&larr;NSDISP VALUE	RTEMP&larr;P AND Q, P&larr;LPGRT, X&larr;7S, CALL[PKSER];	Q&larr;P, P&larr;Q, BAMASK[22], MDR&larr;ILLHD;	P-Q, P&larr;RPGRT2, Q&larr;KA, INHINT;*MUST TURN-OFF INTS. DURING VOLATILE PART	GOTO[ILLRET,ALU&lt;0], P&larr;P#Q, SAMASK[14], Q&larr;MDR, INHINT;*KNOW SECTOR AND ARM ARE RIGHT-MOST FIELDS OF ADDRESS	P, NMMA&larr;MAR, Q&larr;RPGRT2, DGOTO[NSDASK];	NKA&larr;Q, Q&larr;LPGRT2, P&larr;777777R, AMASK[7], INHINT, GOTO[.+1,ALU#0];	NMMA&larr;NULL, Q&larr;P+1, GOTO[ILLRET]; *Q&larr;200 = SECNE*ASSIGN DEVICE X[36,43] TO PRIORITY LEVEL P[41,43], -1 IN RTEMPASNLEV: LTEMP&larr;P, Q&larr;FINTS, P&larr;RTEMP, XMASK;	RPGRT3&larr;P&larr;P+1, FRZBALUBC, DGOTO[.+3,ALU=0];	P&larr;P AND Q, Q&larr;NOTFCOND, CALL[UPQ,ALU=0];	Q&larr;NOT P AND Q; *ENABLE FCOND	NOTFCOND&larr;Q, Q&larr;RPGRT3, P&larr;LTEMP, GOTO[SPILEV];*ASSIGN AC[14,43] TO BE VALUE OF INTERRUPT PARAMETER FOR DEVICE [P]ASNLOC: P-Q, Q&larr;INTTAB, DGOTO[SETPARAM];	GOTO[ILLIO,ALU&gt;=0], Y&larr;P+Q;*ASSIGN BOTH LEVEL AND LOCATION FOR DEVICEALEVLOC: LTEMP&larr;P&larr;P, SAMASK[6], CALL[ASNLOC];	P&larr;LTEMP, RTEMP&larr;A1, GOTO[ALEVX];%*READ LEVEL INTO AC[0,13] AND PARAMETER INTO AC[14,43] FOR DEVICE [P]*DEIMPLEMENTED FOR BYTE LISP.  JMC DISPATCH WAS Q&larr;INTTAB, GOTO[RLEVLOC]RLEVLOC: X&larr;P;	Y&larr;P+Q, P&larr;RTEMP, XMASK; *Y&larr;INTTAB+DEV NO.	Q&larr;SY, P&larr;LTEMP, BAMASK[30], RTEMP&larr;P+1;	LAC&larr;P AND Q, Y&larr;IONTABX, DGOTO[6];	X&larr;NPC, Q&larr;A0, P&larr;LAC, INCY, GOTO[.+1];	Q&larr;SY, LAC&larr;P+Q, INCY, P&larr;RTEMP, RETURN[ALU#0];	P AND Q, DECX, P&larr;LAC, Q&larr;100 000000S, GOTO[.-1,X&gt;=0];	P&larr;LAC, SAMASK[30], GOTO[PTOAC];%*SUBROUTINE FOR "SETIR" AND "CLRIR"IOCK:	P&larr;A1, XMASK, Q&larr;FINTS;	Q&larr;P+1, P&larr;Q, SETFC[MICRO,G=1];	MDR&larr;P AND Q;	STEMP&larr;MDR;	SETFB[STEMP,G=1], GOTO[QMIC,G=1]; *SETF AND GO FOR "SETIR", CLEARF FOR "CLRIR"%ROUTINE ENTERED WITH BITS IN MICINTS TO CLEAR IN Q, VALUESTO BE RESTORED TO P AND TO Q IN RTEMP AND LTEMP, RESPECTIVELY.BALUBC DOESN'T CHANGE.%CLRMINT: P&larr;MICINTS, FRZBALUBC, CALL[CLRPQ], INHINT;	MICINTS&larr;Q, Q&larr;LTEMP, P&larr;RTEMP, FRZBALUBC, RETURN;*HERE WITH FINTS IN P*! MAXC1 ONLYREADIR:	Q&larr;NOT F;	LTEMP&larr;P AND NOT Q, Q&larr;MICINTS;*!*~ MAXC2 ONLYREADIR:	Q&larr;FLAGS;	LTEMP&larr;P AND Q, Q&larr;MICINTS;*~	P&larr;NOT P AND Q, Q&larr;LTEMP, GOTO[POQA];*0 THE BIT FOR DEVICE [X] IN MAXNV AND SIGNAL THE NOVASIGNAL:	P&larr;A1, XMASK, RMW&larr;MAXNV, INHINT, CALL[RETN];	Q&larr;P+1, P&larr;MDR, SIGNOVA, GOTO[PANQM];*ENABLE/DISABLE INTERRUPTS ON PI LEVELS SELECTED BY E[35,43]LEVX:	PQ RCY [35], AMASK[16], Q&larr;PISTAT, CALL[UPQ,J=1];	Q&larr;NOT P AND Q, PISTAT&larr;Q, GOTO[CONINTCOND,J=1];PISTQ:	PISTAT&larr;Q, GOTO[CONINTCOND];MC[TTYBSY&amp;K,TTYBSY,K];*DLS VARIABLESSVN[DLSOD]; SVN[DLSO]; SVN[DLSIN]; SVN[DLSB];*RESET APR, PI, MAP, AND DISKS.  DON'T CLOBBER Q, LPGRT3PRES:	X&larr;RESCNT, RTEMP&larr;Q, DGOTO[SLMIC];	Y&larr;NPC, CLEARF[-1S], INHINT, GOTO[.+1];	ARM&larr;NULL, INHINT, CALL[IREAD];	Y&larr;INTTAB, DGOTO[52];	X&larr;NPC, GOTO[.+1];	P&larr;IMINTT, CALL[IREAD];PRES1:	X&larr;7S, CALL[KRESET];	***WAIT FOR DISK ACTIVITY TO CEASE???	SETF[IENABLE], GOTO[MAPRESET]; *RETURN "RTEMP" IN Q%IORESET CLEARS THE CONTROL LOGIC IN ALL PERIPHERAL EQUIPMENT BUT DOESNOT AFFECT THE PRIORITY INTERRUPT SYSTEM OR PROCESSOR FLAGS.  ITALSO MUST RELOAD ALL INTER-PROCESSOR COMMUNICATION VARIABLES WHICH AREPOINTERS.***MUST NOT CLOBBER "RTEMP" OR "STEMP1"%RESIO:	P&larr;DLSOD&larr;MDR;IORESET: P&larr;Q&larr;P+1, CLEARF[TTYBSY&amp;K], DGOTO[.+1];	DLSO&larr;Q, P&larr;Q&larr;P+1;	DLSIN&larr;Q, Q&larr;P+1, P&larr;LPGRT2, BAMASK[24]; *P&larr;IORESET BIT -1	DLSB&larr;Q, LPGRT2&larr;P+1;*CLEAR ALL INTS EXCEPT OVF, NXM, PARITY, FOVF, POWFL, PDLOVF	Q&larr;17757 777777S, CALL[CLRMINT];	WRITE&larr;MAXNV, SIGNOVA, Q&larr;LPGRT2, DGOTO[PRES1];	MDR&larr;P&larr;NOT Q, CALL[SPUNT];*READ "LOGF" INTO AC[23], "INCMP" INTO AC[24], NOT "PIACTIVE"*INTO AC[25], PI LEVELS OFF INTO AC[26,34], AND PI-IN-PROG INTO AC[35,43]PIREAD:	P&larr;PISTAT, Q&larr;P+1, CALL[PQORP,K=1];	SETSF[PIACTIVE&amp;G], DGOTO[PIRDX];	Q RSH 1, SETSF[LOGF&amp;K], CALL[PQORP,G=0];%SET VALUE OF SYSTEM PARAMETER:  0 TO SLOCLOW-1 ARE IN SM TABLE,413 + 20*UNIT AND 414 + 20*UNIT ARE "KBLK" AND "KPARAM" FOR THE DISKUNITS RESPECTIVELY.  OTHER VALUES BETWEEN 400 AND 577 ARE RESERVEDFOR MORE DISK PARAMETERS.%SETSYSP: P-Q, Q&larr;400S;	P-Q, Q&larr;600S, GOTO[SETSYS1,ALU&lt;0]; *0 TO SLOCLOW-1?	P-Q, Q&larr;13S, GOTO[ILLIO,ALU&lt;0]; *400-577?	Y&larr;P, SAMASK[4], GOTO[ILLIO,ALU&gt;=0];	P#Q, Q&larr;14S;	P#Q, Q&larr;LAC, GOTO[QTOSY,ALU=0]; *KBLK?	GOTO[ILLIO,ALU#0]; *KPARAM?QTOSY:	SY&larr;Q, RETURN;SETSYS1: DGOTO[SLMIC];	Q&larr;NPC, GOTO[.+1];	Y&larr;P+Q, Q&larr;LAC, GOTO[QTOSY];*WRITE ABSOLUTE ADDRESSWABS:  MDR&larr;Q, RETURN;*READ FROM ABSOLUTE ADDRESSRABS:  Q&larr;MDR, GOTO[QTOAC];*MAP VIRTUAL ADDRESS [P] BY USING THE "LOADMAP" ROUTINE.  IF IT TRAPS,*THE TRAP CAUSE MAY BE ILL. READ, WRITE, OR EXECUTE, BUT THE KIND OF*ACCESS ATTEMPTED WILL SHOW THAT NOTHING WAS ATTEMPTED.  IT IS NOT*NECESSARY TO CLEAR THE FORMER MAP ENTRY BEFORE DOING THIS JMC.MVA:	P&larr;(REFADR&larr;P) U (1 000000S); *PGRMM	LEFADR&larr;P, P&larr;RTEMP, BAMASK[26];	Q&larr;NOT P AND Q, CALL[LOADMAP];	Q&larr;MAP, PQ RCY [0], BAMASK[11];	PQ RCY [33], SAMASK[26], Q&larr;P, GOTO[POQA];*AC&larr;INSTRUCTION COUNTER.  P HAS 10, Q HAS E.  E=0 SELECTS LEVEL 1 COUNTER,*E=1 LEVEL 2, ... , E=6 LEVEL 7, AND E=7 NON-INTERRUPT LEVEL COUNTER.*E&gt;7 SELECTS THE "CURRENT" INSTRUCTION COUNTER.RICTR:	P-Q, P&larr;@ICTR, GOTO[WICTR,G=1];	P#Q, Q&larr;ICTR, GOTO[QTOAC,ALU&lt;=0];	P&larr;YICTR, GOTO[PTOAC,ALU#0];	LAC&larr;Q, ENDM;*INSTRUCTION COUNTER&larr;ACWICTR:	P#Q, Q&larr;LAC, GOTO[.+2,ALU&lt;=0];	GOTO[.+2,ALU#0];	ICTR&larr;Q, RETURN;	YICTR&larr;Q, RETURN;*INCREMENT EVENT  COUNTER POINTED TO BY Y AND RETURNEVINC:	LINT1&larr;P, P&larr;EVCTR, INHINT;	Q&larr;P+1, P&larr;Q, INHINT;*WRITE EVENT COUNTER 0-7 IN 16TH WORD OF DISK BLOCKS 0-7WECTR:	Q&larr;P, EVCTR&larr;Q, P&larr;LINT1, INHINT, RETURN;*READ EVENT COUNTER E INTO ACRECTR:	P&larr;EVCTR, GOTO[PTOAC];%UJMC 2 = CSUM16:	AC	-NWords,,Pointer to block			AC+1	Initial checksumLoop performs CSum &larr; (CSum + Item) LCy 1 over 16-bit items, where the firstitem is bits 0:15 in the first word and the last item is bits 16:31 in thelast word, and sums are ones-complement (wraparound carry) over 16 bits.Carries out of bits 20:35 in the checksum word are folded back after eachpair of 16-bit bytes has been processed, so that at the end of each step,the number in AC+1 is .le. 200010b (provided that the original checksum is.le. this value).  After the last PDP-10 word has been processed, the carryword is folded one more time to produce a 16-bit final checksum in AC+1.Note that if a zero count is in AC initially, so that the inner loop isnot executed, then the checksum in AC+1 will be folded precisely once;this will produce a 16-bit result if the original value is less than2&uarr;17-1, a 17-bit result if the original value is less than 2&uarr;32-1,and a 22-bit result for arbitrary values.  If the inner loop is executedat least once, then the original checksum can be as great as 2&uarr;32-1 andstill produce a final result that is .le. 16 bits.  This means that afterchecksumming an odd 16-bit byte at the beginning, one execution of theopcode will produce a 16-bit result, even if the word count is 0, andafter checksumming an additional odd byte at the end, one execution of theopcode will produce a 16-bit result.%*	P &larr; LAC, AQ, SAMASK[22], GOTO[CSUM16];*P/ 16-bits, Q/ previous csum; P &larr; (P+Q) LCY 1CS16X:	P &larr; P + Q;	PQ LCY [1], Q &larr; MDR, RETURN;CS16LP:	LAC &larr; P &larr; P + Q, SAMASK[22], GOTO[PI,H=1];*P/ 777777, Q/ Pointer to block, AC/ pointer to initial csum.CSUM16:	INCAC, GOTO[C16DON,ALU&gt;=0];	MAPVA &larr; P, CALL[RTOMDR];	P &larr; MDR, Q &larr; A0;*P&larr;bits 0:15 of current word, Q&larr;previous csum (.le. 200010b)	PQ RCY [24], Q &larr; LAC, CALL[CS16X];*Q&larr;previous csum (.le. 1000020b), P&larr;bits 16:31 of current word	Q &larr; P, QQ RCY [4], SAMASK[20], CALL[CS16X];*P has new checksum (.le. 2400036b); fold it to 17d bits here so that*carries won't propagate outside bits 4:15 of the word.	Q &larr; P, PQ RCY[20], SAMASK[24];	Q &larr; P, P &larr; Q, SAMASK[20];*Largest result from this operation (for Q = 2377777b) is 200010b.	LAC &larr; P + Q, DECAC;	P &larr; LAC, Q &larr; (2 000002R) RSH 1, SETSF[INTCONDH], GOTO[CS16LP];*Fold 36-bit result once into the sum of the right-most 16d bits and the*left-most 20d bits (This will result in a 16d-bit result for LAC .le.*377776b, which is the case when the loop has run one or more times.).C16DON:	P &larr; Q &larr; LAC, SAMASK[20];	QQ RCY [20], Q &larr; P, SAMASK[24];	LAC &larr; P + Q, ENDM;%UJMC 3 = BYTBLT: A	AC	-NWords,,pointer to source block		  D	AC+1	source to destination offset - 1		  B	AC+2	No. unused bits at right of source		  C	AC+3	Number of bits to right-shift the				source word pair so that the				right-most word has the destination				data right-justified.Approximate equivalent code:	SKIPA T1,(A)LP:	MOVE T1,T3	; Collect source word pair in T1..T2	JUMPGE A,EXIT	MOVE T2,1(A)	MOVE T3,T2	LSH T1,-B	; Squeeze out "crack" between T1 and T2	LSHC T1,-C	; Right-shift T1..T2 so that T2 contains			; the destination data right-justified	LSH T2,B	MOVEM T2,D+1(A)	AOBJN A,LPEXIT:	...%*	RTEMP1 &larr; Q, INCAC, GOTO[BYTB0];BYTB0:	MAPVA &larr; P &larr; AQ, SAMASK[22], CALL[RQARG];*Have P/ AC, Q/ memory data	RTEMP &larr; Q, INCAC;		*RTEMP &larr; 0(AC)	P &larr; RTEMP1, Q &larr; LAC, INCAC;	Q &larr; LAC, STEMP &larr; Q, DECAC;	*STEMP&larr;B	STEMP1 &larr; Q, P &larr; P, DECAC, GOTO[BYTBA];	*STEMP1&larr;C*RTEMP/		0(AC) = first memory word*STEMP1/	right-shift distance for word pairBYTBLP:	LAC &larr; P &larr; P + Q, INCAC, GOTO[PI,H=1];*Here the AC register contains its original value + 1 (points at D)*P contains A, which has been put through the ALU.BYTBA:	INCAC, GOTO[REMAPPC,ALU&gt;=0];	MAPVA &larr; P &larr; P + 1, SAMASK[22], CALL[RTOMDR];	P &larr; RTEMP, Y &larr; P;	Q &larr; A0;	PQ RCY [Y], Y &larr; STEMP1;	*P&larr;T1 data right-justified	P &larr; MDR, Q &larr; P;*RTEMP&larr;T2 now to be T1 next time	RTEMP &larr; P, PQ RCY [Y], Q &larr; LAC, DECAC;	Y &larr; Q, Q &larr; P &larr; P, SAMASK[0], CALL[RETN];*NOTE: delay 1 instruction after Y&larr; before PQ RCY[44-Y]	PQ RCY[44-Y];		*LSHIFT by B to zero unused bits	MDR &larr; P, P &larr; REFADR, Q &larr; LAC, DECAC;	MAPVA &larr; P &larr; P + Q, SAMASK[22], CALL[WMDR];	P &larr; LAC, Q &larr; (2 000002R) RSH 1, SETSF[INTCONDH], GOTO[BYTBLP];*Write data in MDR to address in P for which MAPVA has been done*and return to caller.  On page fault, PC is not advanced.WMDR:	WREF, REFADR &larr; P, Q &larr; MDR, GOTO[WMDR2,G=1];WMDR1:	P &larr; (P) U (BLTWLE), RETURN[G=0];	Q &larr; WMQ, LEFADR &larr; P, CALL[LOADMAP];	WREF, Q &larr; MDR &larr; WDATA, GOTO[WMDR1,G=0];WMDR2:	P &larr; (X) U (ACBASE), GOTO[WMDR3,H=0];	MAPVA &larr; P &larr; (P) U (BLTWLE);	WREFDXK, MDR &larr; Q, GOTO[WMDR1];WMDR3:	LX &larr; Q, RETURN;%UJMC 4 = WDUMP0:	AC	-NWords,,pointer to first src word			AC+1	points at destination blockLoop moves two 40-bit words from the source to the destination translatinginto Maxc dump format, where data bytes begin with 0:7 in the first sourceword and with 0:7 in the first destination word.  Translation of nibbles isas follows:	Source			Destination	xx xx xx xx s t		xx xx xx xx	yy yy yy yy u v		-- st yy yy				yy yy -- uvwhere s and u are bits 32:35 in the two source words and t and v are thetag bits in the source words and where -- denotes a garbage byte.  In otherwords, 40-bit words from the source (including 4 tag bits/word) is copiedto the destination as 5 8-bit bytes with an extra garbage byte thrown inbetween the 32nd and 33rd source bits, and the destination is packed 48-bit bytes/word.%*	P &larr; LAC, INCAC, GOTO[WDMP0];WD0LP:	GOTO[REMAPPC,ALU&gt;=0];WDMP0:	MAPVA &larr; P &larr; P, SAMASK[22], CALL[RTOMDR];	P &larr; A0, Q &larr; MDRL, SETSF[INTCONDH];	PQ RCY [4], Q &larr; MDR, GOTO[PI,H=1];	*P/ t0 00 00 00 0	PQ RCY [14], Q &larr; LAC, DECAC;	*P/ -- st 00 00 0	RTEMP &larr; P, P &larr; Q, SAMASK[22];	*RTEMP/ -- st 00 00 0	MAPVA &larr; P, CALL[WMDR];		*Write xx xx xx xx -	P &larr; LAC, INCAC;	MAPVA &larr; P &larr; P+1, SAMASK[22], CALL[RTOMDR];	Q &larr; A0, P &larr; STEMP &larr; MDR;	PQ RCY [20], Q &larr; RTEMP, STEMP1 &larr; MDRL;	MDR &larr; P OR Q, P &larr; LAC;	MAPVA &larr; P &larr; P+1, SAMASK[22], CALL[WMDR];	P &larr; A0, Q &larr; STEMP;	PQ RCY [24], Q &larr; STEMP1;		*P/ yy yy u0 00 0	RTEMP &larr; P, 0Q RCY [4], Q &larr; STEMP;	*P/ v0 00 00 00 0	PQ RCY [34], SAMASK[14], Q &larr; RTEMP;	*P/ 00 00 00 uv 0	MDR &larr; P OR Q, Q &larr; LAC, P &larr; 2 000002R;	MAPVA &larr; P &larr; P+Q, SAMASK[22], CALL[WMDR];	Q &larr; LAC, P &larr; 2 000002R;	P &larr; P+Q, Q &larr; (2 000002R) RSH 1;	LAC &larr; P+Q, DECAC;	P &larr; LAC, Q &larr; 2 000002R;	LAC &larr; P &larr; P+Q, INCAC, GOTO[WD0LP];%UJMC 5 = WDUMP1:	AC	-NWords,,pointer to first src word			AC+1	Right-justified 8-bit byte from the				previous iteration.			AC+2	address of destination blockLike WDUMP0 but with a different destination alignment.Translation of nibbles is as follows:	Source			Destination	xx xx xx xx s t		ll xx xx xx	yy yy yy yy u v		xx -- st yy				yy yy yy --where ll is the byte from the previous iteration and where uvis left right-justified in AC+1 for the next iteration.%*	P &larr; LAC, INCAC, GOTO[WDMP1];WD1LP:	GOTO[REMAPPC,ALU&gt;=0];WDMP1:	MAPVA &larr; P &larr; P, SAMASK[22], CALL[RTOMDR];	P &larr; STEMP &larr; MDR, Q &larr; LAC, INCAC;	RTEMP &larr; P, PQ RCY [10], Q &larr; MDRL, SETSF[INTCONDH];	MDR &larr; P, 0Q RCY [4], Q &larr; RTEMP, GOTO[PI,H=1];	PQ RCY [10];			*P/ -s t0 00 00 0	PQ RCY [14], Q &larr; LAC, DECAC;	*P/ xx -- st 00 0	RTEMP &larr; P, P &larr; Q, DECAC;	MAPVA &larr; P &larr; P, SAMASK[22], CALL[WMDR];	P &larr; LAC, INCAC;	MAPVA &larr; P &larr; P+1, SAMASK[22], CALL[RTOMDR];	P &larr; STEMP &larr; MDR, Q &larr; A0, INCAC;	PQ RCY [30], Q &larr; RTEMP, STEMP1 &larr; MDRL;	MDR &larr; P OR Q, P &larr; LAC;	MAPVA &larr; P &larr; P+1, SAMASK[22], CALL[WMDR];	P &larr; A0, Q &larr; STEMP;	PQ RCY [34];	MDR &larr; P, P &larr; LAC, Q &larr; 2 000002R;	MAPVA &larr; P &larr; P+Q, SAMASK[22], CALL[WMDR];*Now update AC's for the iteration	P &larr; LAC, Q &larr; 2 000002R;	P &larr; P+Q, Q &larr; (2 000002R) RSH 1;	LAC &larr; P+Q, DECAC;	*DEST AC &larr; DEST AC+3	P &larr; A0, Q &larr; STEMP1;	PQ RCY [4], Q &larr; STEMP;	PQ RCY [40], SAMASK[10];	LAC &larr; P, DECAC;		*Byte carried to next iteration	P &larr; LAC, Q &larr; 2 000002R;	LAC &larr; P &larr; P+Q, INCAC, GOTO[WD1LP];	*Source AC%JMC, A CATCH-ALL INSTRUCTION ADDED TO THE PDP-10, IS PRIVILEGED.E[22,30] SELECTS ONE OF 128 MICROCODED ROUTINES FOR EXECUTION.THE TABLE OF MICROINSTRUCTIONS BEGINNING AT "ALEVX" IS USED TO DISPATCHTO THE SELECTED ROUTINE WITH E[31,43] IN P AND AC IN Q.I = 6 + NUJMCS + NJMCS + 72 = 116 (+8 COMMENTED OUT)%*MUST USE REFADRJMC:	REFADR&larr;P, PQ RCY [13], Q&larr;NPC, RETURN, SETSF[UM&amp;J], BAMASK[7];*JMC DISPATCH.  HERE WITH -1 IN RTEMP AND LTEMP, E[30,43] IN P, AC IN QALEVX:	X&larr;P, PQ RCY [6], SAMASK[3], GOTO[ASNLEV]; *0  PILEV P[33,35] TO DEVICE P[36,43]	Q&larr;44S, RTEMP&larr;Q, GOTO[ASNLOC];   *1  ASSIGN 24-BIT PARAM. TO DEV IN P	Q&larr;44S, RTEMP&larr;Q, GOTO[ALEVLOC];  *2  ASSIGN BOTH LEV AND PARAM	YKPTR&larr;P, GOTO[WECTR];		*3  WRITE EVENT COUNTER E	X&larr;P, SETSF[G], GOTO[IOCK];	*4  CLEAR INTERRUPT REQUEST FOR DEV P	X&larr;P, SETF[G], GOTO[IOCK];	*5  INITIATE INTERRUPT REQUEST FOR DEV P	RPGRT3&larr;Q, PQ RCY [0], SAMASK[3], GOTO[SPILEV];  *6  SET PI LEVEL					*FOR DEVICES SELECTED BY AC	P&larr;FINTS, GOTO[READIR];		*7  AC&larr;INTERRUPTING DEVICE MASK	P&larr;FINTS, BRKP[1], GOTO[ILLIO];		*10  INITIATE INTS FOR DEVICES IN AC MASK	CLEARF[PIACTIVE&amp;G], GOTO[CONINTCOND];	*11  TURN OFF PI SYSTEM	SETF[PIACTIVE&amp;MICRO], GOTO[CONINTCOND];	*12  TURN ON PI SYSTEM	SETF[INCMP&amp;K], RETURN;   *13  ENTER INCOMPATIBLE MODE	CLEARF[INCMP&amp;K], RETURN; *14  LEAVE INCOMPATIBLE MODE	X&larr;P, SETSF[G], GOTO[SIGNAL];		*15  SIGNAL NOVA DEVICE E (BIT 43-E)PRESC:	P&larr;GOTAB, IRET, INHINT, GOTO[PRES];	*16  PROCESSOR RESET	P&larr;777777R, AMASK[17], SETSF[INCMP&amp;K], GOTO[PIREAD];	*17  READ PI STATE	Q&larr;SLOCLOW, GOTO[SETSYSP];	*20 SET SYSTEM PARAMETER TO ACMAPRESET: CLEARF[CUM&amp;G], Y&larr;NULL, GOTO[MAPRES];	*21  TURNOFF MAPPING	P&larr;Y&larr;NULL, GOTO[SETPLO], Q&larr;P;	*22  SET PLO EQUAL TO E	READ&larr;PSWITCH, GOTO[ASWIT];	*23  RELOAD BASE REGS. WITHOUT MAP CLEAR	Q&larr;1000S, GOTO[VPGCLR];		*24  CLEAR VIRTUAL PAGE E	CLEARF[CUM&amp;G], Y&larr;A1, GOTO[MAPCLR];	*25  CLEAR ABSOLUTE PAGE E	GOTO[USWIT], P&larr;Y&larr;PLO;		*26  SWITCH MAP TO NEW PROCESS	YKPTR&larr;KUNIT&larr;P, GOTO[KOFF];	*27  DESELECT DISK UNIT E	YKPTR&larr;KUNIT&larr;P, GOTO[KON];	*30  SELECT DISK UNIT E WITH THE					*MAXIMUM DISK ADDRESS IN AC	P&larr;377 000000S, GOTO[KNOPDP];	*31  DISABLE PDP-10 SECTOR INTERRUPTS					*FOR THE PACK IN AC	P&larr;377 000000S, GOTO[KSEEK];	*32  ENABLE PDP-10 SECTOR INTERRUPTS					*AND SEEK IF ARM # CURRENT POSITION	READ&larr;DLSBS, GOTO[RESIO];	*33  I/O RESET	MAPVA&larr;P&larr;AQ, SAMASK[22], GOTO[KGO];	*34  DO DATA TRANSFER SPECIFIED					*BY COMMAND POINTED TO BY V.A. IN AC	WRITE&larr;P, INHINT, GOTO[WABS];	*35  MOVEM AC,E[31,43] ABSOLUTE	READ&larr;P, GOTO[RABS];             *36  MOVE AC,E[31,43] ABSOLUTE	MAPVA&larr;P&larr;AQ, SAMASK[22], GOTO[MVA]; *37  MAP VIRTUAL TO ABSOLUTE					*ADDRESS (1240,,E + 100000,,0 FOR READ					*40400,,0 FOR WRITE AND 20000 FOR XCT)	SETF[G], GOTO[RICT1];		*40  WRITE INST. COUNTER E	Q&larr;LAC, GOTO[CHECK];		*41  CHECK MICROMEMORY (MUST HAVE 0					*IN AC AT CALL.  CLOBBERS AC TO AC+4)	Q&larr;P, P&larr;NULL, SETF[J], GOTO[LEVX];	*42 TURN OFF PI LEVELS	Q&larr;P, P&larr;NULL, SETF[MICRO], GOTO[LEVX];	*43 TURN ON PI LEVELS	SETF[LOGF&amp;K], RETURN;		*44  ENABLE OPTIONAL MAIN LOOP PATH	CLEARF[LOGF&amp;K], RETURN;		*45  DISABLE OPTIONAL MAIN LOOP PATHDM[DLC,777]; DLC[E1[JMC] E2[JMC1] E3[ADD[4000,IP[ILC],NOT[IP[JMC]]]]];JMC1:	MDR&larr;P+Q, SETSF[G], GOTO[ILLIO,J=1];	Q&larr;STACK, LTEMP&larr;RTEMP&larr;A1;	P-Q, NPC&larr;MDR;	GOTO[ILLIO,ALU&gt;=0], P&larr;REFADR, Q&larr;LAC, AMASK[13], POP;UJMC:	REFADR&larr;P, PQ RCY [13], Q&larr;NPC, BAMASK[7], SETSF[J], RETURN;RICT1:	P&larr;10L, Q&larr;YKPTR&larr;P, GOTO[RICTR];	*0  READ INST. COUNTER E	YKPTR&larr;P, GOTO[RECTR];		*1  AC&larr;EVENT COUNTER E	P &larr; LAC, AQ, SAMASK[22], GOTO[CSUM16];	*2  CSUM16	RTEMP1 &larr; Q, INCAC, GOTO[BYTB0];	*3  BYTBLT	P &larr; LAC, INCAC, GOTO[WDMP0];	*4  WDUMP0	P &larr; LAC, INCAC, GOTO[WDMP1];	*5  WDUMP1DM[DLC,776]; DLC[E1[UJMC] E2[JMC1] E3[ADD[4000,IP[ILC],NOT[IP[UJMC]]]]];</pre>
  </body>
</html>
