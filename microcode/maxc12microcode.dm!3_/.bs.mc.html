<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12microcode.dm!3>bs.mc</title>
  </head>
  <body>
    <pre>
ER[BS];*I = 127TARGET[ILC];%BYTE INSTRUCTIONSBYTE POINTERS HAVE THE FORMAT:   B[0,5]   P-FIELD (NO. BITS TO RIGHT OF BYTE)   B[6,13]  S-FIELD (SIZE OF BYTE)   B[14]    IGNORED   B[15], B[16,21], B[22,43] I, X, AND E FOR EFF. ADDR. CALC.SPECIAL NOTES:   FOR P&gt;=44 NO BYTE IS PROCESSED   S + P &gt; 44 REFERS TO A BYTE OF SIZE 44-P   INCREMENTING THE BYTE POINTER IS AS FOLLOWS:  IF (P&larr;P-S) &lt; 0, THEN(P&larr;(44-S) MOD 100) AND (BP[15,43]&larr;BP[15,43]+1)   INCREMENTING THE BYTE POINTER TAKES PLACE BEFORE LOADING OR DEPOSITING%MC[BIS&amp;J,BIS,J];%TO "IBP" FROM MAIN LOOP AFTER MAPVA&larr;P&larr;E OR FROM "RMWBPC" WITH J=1.TIMING = M+R+W+5 (R+W=2 + (1 IF WORD BOUNDARY CROSSED) IF B.P. IN AC)I = 14%	LEFADR&larr;P OR Q, Q&larr;RMWMQ, CALL[LOADMAP];IBP:	RMWREF, Q&larr;LX, MDR&larr;X, INHINT, CALL[IBPAC,G=1], REFADR&larr;P;	GOTO[.-2,G=1], Q&larr;RMWLE;	P&larr;BSPLIT&larr;MDR, SETFC[BIS&amp;J,J=1], Q&larr;7777 777777R;	Q&larr;XTOP, SETF[J], RTEMP&larr;P AND Q;	MDR&larr;P-Q-NJ, P&larr;RTEMP;	RETURN[J=1], P&larr;P+1, WRESTART, X&larr;20S; *KNOW LTEMP=20	P&larr;(P) U (440000 000000S), INHINT;IBP1:	LX&larr;MDR&larr;P-Q, RETURN, SETF[J]; *RESULT INTO MDR FOR ISPLIT&larr; LATERIBPAC:	P&larr;BSPLIT&larr;Q, GOTO[RMWAMDR,H=1], Q&larr;7777 777777R;	Q&larr;XTOP, RTEMP&larr;P AND Q, POP, SETFC[BIS&amp;J,J=1];	X&larr;MDR, SETF[J];	MDR&larr;LX&larr;P-Q-NJ, P&larr;RTEMP, DGOTO[IBP1];	RETURN[J=1], P&larr;(P+1) U (440000 000000S);%"RMWBPC" ENTERED FROM THE MAIN LOOP AFTER MAPVA&larr;P&larr;E.  IT GOES TO "RBP"IF BIS WAS SET; OTHERWISE, IT SETS BIS AND J, INCREMENTS THE BYTEPOINTER, AND RETURNS WITH THE INCREMENTED BYTE POINTER IN MDR.TIMING = 7+R+W + (2+R PER BYTE POINTER INDIRECT) (R+W=5 FOR AC)I = 2%RMWBPC:	SETSF[BIS&amp;J], DGOTO[IBP];	SETF[J], GOTO[RBP,J=1];*TO "RBP" AFTER MAPVA&larr;P&larr;E IN THE MAIN LOOP.  RETURN AFTER MAPVA&larr;P&larr;E OF BYTE*WITH SIZE AND POSITION FIELDS OF BYTE POINTER IN RTEMP.SM[XCT0,IP[10 000000S]]; ***MC[XCT2&amp;K,XCT2,K];SM[XCT1,IP[4 000000S]];*I = 9RBP5:	P&larr;MAPVA&larr;(MDR) U (ACBASE), A1, CALL[RREFX];	Q&larr;RLE, RETURN[G=0]; *RETURN ALWAYS TO RBP0	LEFADR&larr;P OR Q, Q&larr;RMQ, CALL[LOADMAP];RBP:	RREF, Q&larr;LX, MDR&larr;X, REFADR&larr;P, GOTO[.-2,G=0], SETSF[XCT2&amp;K];	P&larr;ISPLIT&larr;Q, GOTO[RBP5,H=1];	Q&larr;LINDX, INSTR&larr;P, SETFB[XCT0,K=1], POP, GOTO[BINDE,K=1];	GOTO[BINDE];RBP0:	P&larr;ISPLIT&larr;MDR, DGOTO[BINDE];	Q&larr;LINDX, INSTR&larr;P, SETFB[XCT0,K=1], GOTO[BINDE,K=1];*MUST WAIT ONE CYCLE AFTER CHANGING XCT1 BEFORE REFSETXCT1: SETF[XCT1], GOTO[RETN];%ENTER AT "DPB" WITH BYTE POINTER IN INSTR AFTER MAPVA&larr;E OF BYTEK=1 IFF XCT3=1 (SET BY "BINDE")TIMING = 6+R+W + (2 IF FUNNY XCT) (R+W=5 IF DATA IN AC)I = 25%DPBX:	RTEMP&larr;P AND Q, CLEARFC[BIS&amp;J,J=1];PTOQ:	Q&larr;P, RETURN;	LEFADR&larr;P, Q&larr;RMWMQ, CALL[LOADMAP];DPB:	CALL[SETXCT1,K=1], P&larr;(REFADR&larr;P) U (RMWLE);	RMWREF, MDR&larr;X, Q&larr;INSTR, INHINT, CALL[DPBAC,G=1];	A0, GOTO[.-3,G=1];*ENTRY HERE FOR BLISP DATA TYPE STUFFBDPB:	BSPLIT&larr;Q, Q&larr;A0, GOTO[PMDR,ALU#0];	P&larr;A1, XMASK, Q&larr;LAC, X&larr;20S, CALL[DPBX]; *KNOW LTEMP=20	0Q RCY [44-Y], Q&larr;MDR;DPBY:	LTEMP&larr;NOT P AND Q, Q&larr;RTEMP, WRESTART, DECAC, RETURN[H=1];	0Q RCY [44-Y], Q&larr;LTEMP, INHINT;	LX&larr;MDR&larr;P OR Q, RETURN;DPBAC:	BSPLIT&larr;Q, GOTO[RMWAMDR,H=1];	P&larr;A1, XMASK, Q&larr;LAC, X&larr;MDR, CALL[DPBX];	0Q RCY [44-Y], Q&larr;LX, POP, GOTO[DPBY];*TO "LDB" WITH BYTE POINTER IN INSTR AFTER MAPVA&larr;E OF BYTE*TIMING = 5+R + (1 IF NO BYTE) + (2 IF FUNNY XCT) (R=1 IF DATA IN AC)	LEFADR&larr;P, Q&larr;RMQ, CALL[LOADMAP];LDB:	CALL[SETXCT1,K=1], P&larr;(REFADR&larr;P) U (RLE);	CALL[LDBAC,G=1], RREF, MDR&larr;X, Q&larr;INSTR;	GOTO[.-3,G=1];	BSPLIT&larr;Q, DGOTO[LDBAC1];	P&larr;MDR, Q&larr;A0, CLEARFC[BIS&amp;J,J=1], GOTO[LDBAC1,J=1];LDBAC:	P&larr;LX, BSPLIT&larr;Q, GOTO[RAMDR,H=1];	Q&larr;A0, CLEARFC[BIS&amp;J,J=1], POP;LDBAC1:	PQ RCY [Y], XMASK, DGOTO[SETZ];	LAC&larr;P, ENDM[H=0];DI[133,IBP,REMAPPC,SCRASH];DI[134,RMWBPC,RBP0,LDB];DI[135,RBP,RBP0,LDB];DI[136,RMWBPC,RBP0,DPB];DI[137,RBP,RBP0,DPB];%SHIFT INSTRUCTIONS:TIMING (SHIFT COUNT &lt;=44):   LSH    M + 5 = 14 CYCLES   ROT    M + 4(L) OR 5(R) = 13 CYCLES (LEFT) OR 14 (RIGHT)   ASH    M + 5(R) + 1 IF NUMBER &lt; 0 = 14 OR 15 CYCLES RIGHT          M + 5(L) + 1/SHIFT = 14 + E CYCLES LEFT   LSHC   M + 6(L) OR 7(R) = 15 CYCLES (LEFT) OR 16 CYCLES (RIGHT)   ROTC   M + 6(L) OR 7(R) = 15 CYCLES (LEFT) OR 16 CYCLES (RIGHT)   ASHC   M + 8(R) = 17 CYCLES RIGHT          M + 6(L) + 1/SHIFT = 15 + E CYCLES LEFTMICROINSTRUCTIONS:   SHFT   1   LSH    11   ROT    1   ASH    7   CSHFT  7   LSHCL  3   LSHCR  3   ROTCL  3   ROTCR  3   ASHC   16TOTAL     55%*ACCEPTS E IN P FROM MAIN LOOPSHFT:	YSHIFT&larr;P, P&larr;Q&larr;LAC, RETURN;LSH:	GOTO[LSHL0,Y&gt;=0], RTEMP&larr;P, Q&larr;NULL;LSHR0:	NEGY;LSHR:	PQ RCY [Y];	LAC&larr;P, RETURN[H=0];	LTEMP&larr;Q, P&larr;Y, Q&larr;44R, DGOTO[LSHR];	Y&larr;P-Q, P&larr;Q&larr;LTEMP, CALL[RETN];  *LOOP FOR ROT NOT LSHLSHL0:	Q&larr;RTEMP, P&larr;A0, GOTO[LSHL];ROT:	RTEMP&larr;P, GOTO[LSHR0,Y&lt;0];LSHL:	PQ RCY [44-Y], Q&larr;P;	LAC&larr;P, RETURN[H=0];	LTEMP&larr;Q, P&larr;Y, Q&larr;44R, DGOTO[LSHL];	Y&larr;P-Q, P&larr;Q&larr;LTEMP, CALL[RETN];  *LOOP FOR ROT NOT LSHASH:	GOTO[ASHL,Y&gt;=0], RTEMP&larr;P, Q&larr;NULL;	NEGY, GOTO[LSHR,ALU&gt;=0];ASHB:	Q&larr;A1, GOTO[LSHR];ASHL:	DECY;	RETURN[Y&lt;0], Q&larr;A0, DECY;	PQ LCY [1], ASHOVF, DECY, GOTO[.,Y&gt;=0];	RETURN;%CSHFT ACCEPTS E IN P.  ON E&lt;0 (RIGHT SHIFT), LEAVES AC INRTEMP AND STEMP, -E IN Y, AC+1 IN LTEMP AND Q, AND LOW PART OFRESULT IN P.  AC POINTS TO AC+1 AND RESULT IS VALID IFF H=0.STACK IS POPPED BEFORE RETURN.ON E&gt;=0 (LEFT SHIFT), LEAVES AC+1 IN RTEMP, TOP PART OF RESULT IN P,AC POINTS TO AC, E IS IN Y, AND AC IS IN Q.%CSHFT:	YSHIFT&larr;P, INCAC, Q&larr;LAC;	P&larr;LAC, RTEMP&larr;Q, GOTO[CSHFTL,Y&gt;=0];	NEGY, POP, LTEMP&larr;P, GOTO[.+2];CSHFTR:	LTEMP&larr;P;	PQ RCY [Y], Q&larr;P, STEMP&larr;Q, RETURN;*NOTE MANDATORY 1 CYCLE WAIT BETWEEN Y&larr; AND RCY[44-Y]CSHFTL:	RTEMP&larr;P;	PQ RCY [44-Y], DECAC, RETURN;LSHCL:	LAC&larr;P, P&larr;NULL, INCAC, Q&larr;RTEMP, POP, GOTO[LSHL, H=0];	LAC&larr;A0, P&larr;Y, Q&larr;44R, DGOTO[LSHL];	Y&larr;P-Q, Q&larr;RTEMP, P&larr;LAC, DECAC, CALL[RETN];LSHCR:	LAC&larr;P, DECAC, Q&larr;NULL, P&larr;RTEMP, GOTO[LSHR,H=0];	LAC&larr;Q, P&larr;Y, Q&larr;44R, DGOTO[LSHR];	Y&larr;P-Q, P&larr;RTEMP, Q&larr;LAC, INCAC, CALL[RETN];	Y&larr;P-Q, P&larr;LTEMP, Q&larr;RTEMP, CALL[CSHFTL];ROTCL:	P&larr;B, B&larr;Q, LAC&larr;P, INCAC, Q&larr;RTEMP, POP, GOTO[LSHL,H=0];	P&larr;Y, Q&larr;44R, LTEMP&larr;P, CALL[.-2]; *CALL TO CANCEL OUT POP	Y&larr;P-Q, Q&larr;LTEMP, P&larr;RTEMP, INCAC, CALL[CSHFTR];ROTCR:	LAC&larr;P, DECAC, P&larr;STEMP, GOTO[LSHR,H=0];	P&larr;Y, Q&larr;44L, RTEMP&larr;P, GOTO[.-2];*ACCEPTS E IN PASHC:	YSHIFT&larr;P, INCAC, Q&larr;LAC; **PATCHED	P&larr;LAC, RTEMP&larr;Q, GOTO[ASHCL,Y&gt;=0], POP, Q&larr;NULL, DECAC;	NEGY, POP, PQ LCY [1], Q&larr;RTEMP, DGOTO[ASHCRP,ALU&gt;=0];*Y CONTAINS THE SHIFT COUNT FOR A RIGHT SHIFT, RTEMP AND Q CONTAIN*LEFT HALF, P RIGHT HALF OF QUANTITY TO BE SHIFTED.  DGOTO IS PENDING IF*NUMBER &gt;= 0.	PQ RCY [Y], Q&larr;A0, INCAC;	PQ RCY [1], Q&larr;400000 000000S, GOTO[.+2,H=1];	LAC&larr;P OR Q, DECAC, P&larr;RTEMP, Q&larr;-1S, GOTO[LSHR];	DECAC, P&larr;Y, Q&larr;44R, LPGRT&larr;A1;	Y&larr;P-Q, P&larr;RTEMP, Q&larr;LPGRT;	LAC&larr;Q&larr;A1, PQ RCY [1], INCAC, GOTO[LSHR];ASHCRP: PQ RCY [1], Q&larr;(RTEMP) RSH 1, GOTO[LSHCR,H=0];	RTEMP&larr;Q, GOTO[LSHCR];ASHCL:	Q&larr;2P, P&larr;RTEMP, DECY, POP;	GOTO[REMAPPC,Y&lt;0], P, DECY; *NO SHIFT IF COUNT=0	PQ LCY [1], ASHOVF, Q LSH 1, DECY, P, GOTO[.,Y&gt;=0];	LAC&larr;P, Q RSH 1, P&larr;400000 000000S, INCAC, GOTO[QTOAC,ALU&gt;=0];POQA:	LAC&larr;P OR Q, ENDM;DI[242,SHFT,LSH,PTOAC];DI[241,SHFT,ROT,PTOAC];DI[240,SHFT,ASH,PTOAC];DI[244,ASHC,SCRASH,SCRASH];DI[245,CSHFT,ROTCL,ROTCR];DI[246,CSHFT,LSHCL,LSHCR];%BLT INSTRUCTIONE IS IN P AT THE CALL.RTEMP IS USED TO HOLD THE "UNTIL" FIELD, LAC THE FROM-TO, AND LTEMPTHE INCREMENTED FROM-TO.  AC IS CLOBBERED WITH AN UPDATED BLT POINTERBEFORE EACH WORD IS TRANSFERRED SO IT WINDS UP WITH FROM+UNTIL-TO IN THE L.H.AND WITH UNTIL IN THE R.H. (UNLESS IT IS THE LAST WORD WRITTEN BY BLT).AT LEAST ONE WORD IS TRANSFERRED REGARDLESS OF THE "UNTIL" FIELD.MUST ADVANCE AC AFTER THE WRITE AND AFTER THE END CHECK SO THAT THE BLT DOESN'TGO ASTRAY IF IT RANGES ACCROSS THE BLT POINTER AND SO THAT IF THE BLT AC IS THELAST WORD WRITTEN IT DOESN'T GET CLOBBEREDTIMING = M + 3 + (2 + R + W)/WORD TRANSFERRED WHERE R=3 AND W=6 FOR AC'SI = 23%BLT:	RTEMP&larr;P, P&larr;LAC, Q&larr;1 000000S, GOTO[.+3];BLTLP:	P&larr;LTEMP, SETSF[INTCONDH], GOTO[REMAPPC,ALU&gt;=0];	LAC&larr;P, GOTO[PI,H=1], Q&larr;1 000000S;	LTEMP&larr;P+Q+1, PQ RCY [22], SAMASK[22];	MAPVA&larr;REFADR&larr;P, GOTO[.+2];BLRML:	LEFADR&larr;Q, Q&larr;RMQ, CALL[LOADMAP];	RREF, Q&larr;LX, GOTO[.+3,G=0];	MDR&larr;Q, GOTO[.+3,H=0], P&larr;ICTR, Q&larr;P;	MAPVA&larr;P&larr;(Q) U (ACBASE), A1, CALL[RREFX];	GOTO[BLRML,G=1], Q&larr;(P) U (RLE), P&larr;ICTR;	P&larr;LAC, BAMASK[22], ICTR&larr;P+1, Q&larr;BLTWLE;	MAPVA&larr;REFADR&larr;P, CALL[.+1];*! MAXC1 ONLY	MDR;*!	WREF, LEFADR&larr;P OR Q, Q&larr;RTEMP, GOTO[BWM1,G=0];BWM0:	P-Q, Q&larr;MDR, GOTO[.+2,H=1];	LX&larr;Q, FRZBALUBC, GOTO[BLTLP];	MAPVA&larr;Q&larr;(X) U (ACBASE), A1;	WREFDXK, Q&larr;(Q) U (BLTWLE);	LEFADR&larr;Q, Q&larr;RTEMP;BWM1:	P-Q, GOTO[BLTLP,G=0], P&larr;LEFADR;*LOADMAP RETURNS TO WREF ABOVE AND CAN'T HAPPEN TWICE	P&larr;(P) U (WLE), Q&larr;LTEMP, GOTO[.+2,ALU&gt;=0];	LAC&larr;Q, Q&larr;WMQ, GOTO[LOADMAP];	LEFADR&larr;P, Q&larr;WMQ, GOTO[LOADMAP]; *DON'T DECREMENT PC IF LAST WRITE TRAPSDI[251,BLT,SCRASH,SCRASH];</pre>
  </body>
</html>
