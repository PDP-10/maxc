<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12microcode.dm!3>lisp.mc</title>
  </head>
  <body>
    <pre>
ER[LISP];*I = 426LM[CP,17]; LM[PP,16]; LM[BR,15]; LM[VP,14]; LM[CBS,13]; LM[TP,12];LM[CBSP,7]; LM[L6,6]; LM[L5,5]; LM[L4,4]; *L4 CAN ONLY BE READRVN[ROPCD];	*HOLDS OPCODE BEING EXECUTED FOR INSTRUCTION TRAPSSLC[@BOPXT: E1[BLOPXT]];SLC[@JCONDP: E1[JCONDP]];SM[BST,15];		*ADDRESSES WORD 15 IN KUNIT BLOCKS*FIELDS BELOW AND @WPCT ARE USED WITH XSPLIT&larr; TO LOAD AC&larr;1, X&larr;11,*Y&larr;ADDRESS OF WPC (BOUNDARY OF 4).F[OPCF,0,10]; F[ACF,11,14]; F[IXF,16,21];SLC[@WPCT: OPCF[B4TAB] ACF[1] IXF[11]];SM[BIS,IP[20000 000000S]];SM[MD2,IP[200 000000S]];	*BYTE-LISP FLAG IN FMC[BIS&amp;K,BIS,K];SM[NOTFLAGS&amp;BIS,IP[20037 777777S]];*! MAXC1 ONLYSVN[WPC];		*HOLDS INTERNAL REPRESENTATION OF BYTE POSITION*!SM[SZERO,IP[4000S]];	*LISP SMALL INTEGER 0*ST = ATOM "T"*SNIL = ATOM "NIL"*SKPRGLM = ATOM "PROGLM"*TYPTAB = ORIGINS OF BIT TABLE POINTERS AND TYPE TABLE - 1 (BTT,,TYPTAB-1)SM[LISTT,IP[10S]];	*PAGE TYPE = LISTSM[ATOMT,IP[14S]];	*PAGE TYPE = LITERAL ATOMSET[FLOATT,20];		*PAGE TYPE = FLOATING POINTSM[FIXT,IP[22S]];	*PAGE TYPE = LARGE INTEGERSM[SMALLT,IP[24S]];	*PAGE TYPE = SMALL INTEGER*DISPLACEMENT OF SMALL NUMBERS = 4000.  RANGE OF SMALL NUMBERS IS*-3000 TO 2777*MAIN MEMORY COMMUNICATION TABLE (AT 200)*40 LOCATIONS FOR EVEN OPCODE 600-676 TRAPS, THEN*40 UNUSED LOCATIONS, THENSM[CF,IP[300S]];	*POINTS AT CURRENT STACK FRAME*LSTSWF 301		*POINTS AT LAST SWAPPED FRAMESET[POPJTP,302];	*ADDRESS OF POPJ CP,SM[BXNUM,IP[3S]];	*TRAP TO BOX LARGE INTEGER WITH RESULT AT 0(PP)SM[BLIUBE,IP[104S]];	*TRAP FOR ARG NOT INTEGERSM[RPLERX,IP[5S]];	*TRAP FOR ARG NOT LISTSET[FNCTRP,306];	*ADDRESS OF TRAP FOR FUNCTION CALLS*307 TRAP ADDRESS FOR DATA TYPE ERRORS*310-316 UNUSEDSM[BRET,IP[317S]];	*ADDRESS OF FUNCTION RETURNSSET[BRET1,321];		*ADDRESS OF UNBIND RETURNSSET[BRET2,323];		*ADDRESS OF DUNBIND RETURNSSM[BNDTRP,IP[324S]];	*ADDRESS OF BIND TRAP-1 FOR XCT 1(2)SET[LFCALL,326];	*ADDRESS OF PUSHJ CP,5 FOR LINKED-FN CALLS-1SET[BRET3,130];		*ADDRESS OF BLOCK CALL RETURNSTARGET[ILC];CAR:	LAC&larr;P AND Q;*OPERATIONS WITH ONE ARGUMENT PRODUCING A RESULT EXIT HEREFIXSTK:	P&larr;PP, AMASK[22], Q&larr;777777R, GOTO[BWPPQ1X];SWAP:	Q&larr;LAC, P&larr;P AND Q, WRESTART;	MDR&larr;Q, LAC&larr;P, GOTO[FIXSTK];CDR:	PQ RCY[22], SAMASK[22];FIXSP:	LAC&larr;P, GOTO[FIXSTK];POQL22:	0Q RCY [22], Q&larr;P, INHINT, RETURN;PQQL22:	QQ RCY [22], Q&larr;P, BAMASK[22], RETURN;INCP:	P&larr;P+1, RETURN;*WRITE THE DATA IN MDR TO THE ADDRESS IN P AND EXIT.  MAPVA&larr; HAS*ALREADY BEEN DONE AND 777777 IS IN Q.  SET PDOVF IF J=1.*TIMING = 3XPUSH:	WREF, Q&larr;(REFADR&larr;P AND Q) U (WLE), GOTO[MILLEG,G=1];	P&larr;ICTR, SETFC[PDOVF,J=1];	ICTR&larr;P+1, GOTO[XCTBYT,G=0]; *CAREFUL OF CLOBBERING Y HERE*! MAXC1 ONLYBWRX1:	LEFADR&larr;Q, P&larr;ISPLIT&larr;WPC, Q&larr;10772 777777R, CALL[ADVPC];	Q&larr;P, P&larr;WMQ;	PC&larr;Q, Q&larr;P, CALL[LOADMAP];	WREF, REFADR&larr;P, GOTO[BWRQXX];*!*~ MAXC2 ONLYBWRX1:	LEFADR&larr;Q, P&larr;ISPLIT&larr;BPC, CLEARF[BIS], CALL[QBPC];	PC&larr;Q, Q&larr;P;	BPC&larr;Q;	Q&larr;WMQ, CALL[LOADMAP];*WREF CANNOT FAULT AGAIN IF LOADMAP RETURNS	WREF, GOTO[XCTBYT];QBPC:	Q&larr;BPC, RETURN;*~QPANDQ:	Q&larr;P AND Q, RETURN;*WRITE LAC AT P+Q+1 AND RETURN WITH RTEMP IN PBWPPQ1R: MAPVA&larr;P&larr;P+Q+1, SAMASK[22], Q&larr;LAC;BWRQR:	WREF, MDR&larr;Q, REFADR&larr;P, GOTO[MILLEG,G=1];	P&larr;RTEMP, Q&larr;(P) U (WLE), RETURN[G=0]; **NOTE: X # 11 HERERPUSH1:	Q&larr;(LEFADR&larr;Q) U (WLE), GOTO[.+2,K=1]; *SKIP IFF PC&larr;PC-1	LEFADR&larr;Q;	Q&larr;WMQ, CALL[LOADMAP];	WREF, SETSF[INTCONDH], GOTO[RPUSH2];*WRITE MDR TO THE ADDRESS IN P AND RETURN RTEMP IN P, LTEMP IN Q.*MAPVA&larr; HAS ALREADY BEEN DONE AND 777777 IS IN Q.  SET PDOVF IF J=1.*TIMING = 4RPUSH:	WREF, Q&larr;(REFADR&larr;P AND Q) U (BLTWLE), GOTO[MILLEG,G=1];	P&larr;ICTR, SETFC[PDOVF,J=1];	ICTR&larr;P+1, SETSF[INTCONDH], GOTO[RPUSH1,G=1];RPUSH2:	P&larr;RTEMP, Q&larr;LTEMP, X&larr;11S, RETURN[H=0];*CALL PI ROUTINE RETURNING P AND Q UNCHANGED, 11 IN X.*CLOBBERS LTEMP AND RTEMP.**THIS ROUTINE MUST WORK FOR THE BLISP PDP-10 INSTRUCTION AS WELL AS BYTE**LISP OPCODES, AND FOR BYTE LISP OPCODES ERRONEOUSLY EXECUTED FROM**PDP-10 MODE.****WORRY ABOUT NOT PRESERVING P BELOW****BPI:	LTEMP&larr;Q, Q&larr;777777R, SETSF[MD2&amp;G], GOTO[PI,K=1];	RTEMP&larr;P, Q&larr;PC, P&larr;Q, CALL[QPANDQ,G=0];	SETSF[NOVA&amp;H], DGOTO[RPUSH2];	P&larr;NOTFCOND, CALL[PIX];*PUSH VALUE IN P ON PARAMETER STACK, THEN EXIT*TIMING = 5PPPUSH:	MDR&larr;P, P&larr;PP, Q&larr;(2 000002R) RSH 1, SETSF[J];PPPSH1:	PP&larr;MAPVA&larr;P&larr;P+Q+J, Q&larr;777777R, GOTO[XPUSH];*HERE WITH PP IN P, RESULT TO BE PUSHED IN MDR AND QPPPSHX:	LAC&larr;Q, Q&larr;(2 000002R) RSH 1, SETSF[J], GOTO[.-1];*PUSH VALUE IN P ON PARAMETER STACK AND RETURNPPPSHR:	MDR&larr;P, P&larr;PP, Q&larr;(2 000002R) RSH 1, SETSF[J];PPSHR1:	PP&larr;MAPVA&larr;P&larr;P+Q+J, Q&larr;777777R, GOTO[RPUSH];*SUBROUTINE USED BY "CALLFN" TO ADVANCE STATE AND THEN PUSH THE VALUE*IN P ON THE CP STACKPDPCPP:	RTEMP1&larr;P, P&larr;CBS, Q&larr;767777 777777S;PDPCP1:	CBS&larr;P-Q-1, P&larr;RTEMP1;*PUSH VALUE IN P ON CONTROL STACK AND RETURN.*TIMING = 6CPPUSH:	MDR&larr;P, P&larr;CP, Q&larr;(2 000002R) RSH 1, SETSF[J];	CP&larr;MAPVA&larr;P&larr;P+Q+J, Q&larr;777777R, GOTO[RPUSH];	Q&larr;RMQ, CALL[LOADMAP];*TIMING = R+2BRMEM:	RREF, P&larr;(REFADR&larr;P) U (BRLE), GOTO[MILLEG,G=1];	LEFADR&larr;P, X&larr;11S, GOTO[.-2,G=1];	P&larr;MDR, Q&larr;777777R, SETSF[13S], RETURN[K=0];	PQ RCY [22], BAMASK[22], RETURN;BRMEM1:	RTEMP&larr;P, P&larr;PP, Q&larr;1S;FPMQ:	MAPVA&larr;P&larr;P-Q, SAMASK[22], GOTO[BRMEM];BRMEM2:	RTEMP&larr;P, P&larr;PP, Q&larr;2S, GOTO[FPMQ];CDRP:	PQ RCY [22];READP:	MAPVA&larr;P, SAMASK[22], GOTO[BRMEM];*HAVE AC1 IN Q, FRAME DEPTH IN P FROM NEXTBYTEARGX:	RTEMP&larr;P-1, P&larr;Q, CALL[UNBOX]; *P&larr;UNBOXED N, Q&larr;DEPTH-1AQQ:	AQ, RETURN;ARGX1:	P&larr;P-1, Q&larr;VP, CALL[PVAR,ALU&gt;=0];*FETCH P+Q+1IVAR:	MAPVA&larr;P&larr;P+Q+1, SAMASK[22], GOTO[BRMEM];	Q&larr;RMWMQ, CALL[LOADMAP];BRMWM:	RMWREF, REFADR&larr;P, Q&larr;BRMWLE, INHINT, GOTO[MILLEG,G=1];	LEFADR&larr;P OR Q, X&larr;11S, GOTO[.-2,G=1];	P&larr;MDR, Q&larr;777777R, SETSF[3S], RETURN;BRMWPP:	P&larr;PP, Q&larr;1S;BRMWPMQ: MAPVA&larr;P&larr;P-Q, SAMASK[22], GOTO[BRMWM];*TIMING = R+5SETL:	MAPVA&larr;P&larr;P+Q+1, SAMASK[22], CALL[BRMWM];	P&larr;P AND Q, Q&larr;LAC, WRESTART, CALL[POQL22];	MDR&larr;P OR Q, P&larr;PP, Q&larr;(2 000002R) RSH 1, SETSF[7S], RETURN;*TIMING = R+4SETR:	MAPVA&larr;P&larr;P+Q+1, SAMASK[22], CALL[BRMWM];	Q&larr;P AND NOT Q, P&larr;LAC, SAMASK[22], WRESTART, GOTO[.-2];*RETURN Q FOR OP OF 2 OR 3 ARGS IF ALU#0, ELSE RETURN WITH [P] IN P, 777777 IN QCRDPQ:	MAPVA&larr;P, SAMASK[22], GOTO[BRMEM,ALU=0];*REDUCE PP BY 1000001 IF H=0 OR BY 2000002 IF H=1, THEN STORE Q INTO 0(PP) AND EXIT.*TIMING = 5 (+1 IF H=1)PRQ:	LAC&larr;Q;PR1:	P&larr;PP, Q&larr;(2 000002R) RSH 1, MDR&larr;Q, CALL[QL1,H=1];	MAPVA&larr;P&larr;PP&larr;P-Q, SAMASK[22], DGOTO[MILLEG];	WREF, REFADR&larr;P, GOTO[BWRQXX,G=0];*READ THE ADDRESS IN P, RETURNING DATA IN MDR, RTEMP IN P,*22044,,ADDRESS IN Q FOR "GNBYT"	LEFADR&larr;P, P&larr;RTEMP, Q&larr;(Q) U (22044 000000S), RETURN[G=0];	Q&larr;RMQ, CALL[LOADMAP];BXMEM:	RREF, P&larr;(Q&larr;REFADR&larr;P) U (BRLE), GOTO[.-2,G=0];MILLEG:	Q&larr;REFADR, Y&larr;P&larr;NULL, SETF[MD2&amp;G], GOTO[MILEG1];*HAVE VARIABLE DEPTH IN P[33,35], DISPLACEMENT IN P[36,43]*RETURN FRAME POINTER IN Q, DISPLACEMENT IN P*TIMING = 3 (+2R+6 + (R+3)*DEPTH IF DEPTH # 0)LVARX:	Q&larr;P, PQ RCY [6], SAMASK[3]; *P&larr;FRAME DEPTH	RTEMP&larr;P-1, P&larr;Q, SAMASK[6]; *P&larr;DISPLACEMENT	Q&larr;VP, RETURN[ALU&lt;0];PVAR:	RTEMP1&larr;P, P&larr;MAPVA&larr;CF, ACFS, CALL[BRMEM]; *FETCH PTR TO CURRENT FRAME*HAVE FRAME POINTER IN P, REMAINING DEPTH IN RTEMP.  FETCH PP IN,,ALINK	MAPVA&larr;P&larr;P+1, SAMASK[22], CALL[BXMEM];	RTEMP&larr;P-1;	P&larr;MDR, GOTO[.-2,ALU&gt;=0];	MAPVA&larr;P&larr;P, SAMASK[22], CALL[BXMEM]; *FETCH PTR TO 1ST ARG -1	P&larr;RTEMP1, Q&larr;MDR, RETURN; **NOTE: X # 11 HEREXVARX:	Q&larr;NOT P, P&larr;PP, RETURN;BINDA0:	Q&larr;CBS, AC&larr;2S, GOTO[BNDRET,ALU&gt;=0];%HAVE CBS IN Q.  RETURNS CONSTANT [P]+CBS IN Q, ORIGINAL P IN P AND CBSP.CBS USED AS FOLLOWS:  [1,5]=STATE, [6,11]=DEPTH, [0] AND [22,43]=CONSTANT BASE REGISTER.TIMING = R+6 +1 IF EVEN HALF-WORD%GETCON:	Q LCY 1, CBSP&larr;P, SETSF[INTCONDH];GETC2:	(Q&larr;P+Q) ARSHC 1, CALL[BPI,H=1];	MAPVA&larr;P, SAMASK[22], DGOTO[BRMEM];	SETFB[K,Q EVEN], GOTO[BRMEM,Q EVEN]; *CAN'T TEST Q AFTER SLOW LOADGTCON:	Q&larr;CBS, GOTO[GETCON];PSNIL:	P&larr;PP, Q&larr;MDR&larr;SNIL, RETURN;PST:	P&larr;PP, Q&larr;MDR&larr;ST, RETURN;PSSTK:	P&larr;PP, Q&larr;MDR&larr;STACK, GOTO[PPPSHX];QNIL:	Q&larr;SNIL, P&larr;LAC, RTEMP&larr;P, BAMASK[22], RETURN;*Q&larr;BOXED 0, ALU=0 FOR "NTYP"QZERO:	Q&larr;SZERO, A0, RETURN;SIC:	Q&larr;STACK;	Q&larr;MDR&larr;P+Q, P&larr;PP, POP, GOTO[PPPSHX]; *Q&larr;MDR&larr;NEXTBYTE-400+4000*CONDITIONAL JUMP ON ALU#0.  HAVE JUMP BYTE IN P, 400 IN Q*TIMING = R+5 (+1 IF H=1) ON NO JUMP*	= R-X+13 ON JUMP NO POP*	= 2R-X+14 ON JUMP AND POPJNEQT:	P AND Q, SETSF[K], GOTO[JCONDP,ALU#0];*POP PP ONCE IF H=0, TWICE IF H=1.  JUMP WITH DISPLACEMENT IN Q IF K=1PPOP:	P&larr;PP, Q&larr;(2 000002R) RSH 1, STEMP&larr;Q, CALL[QL1,H=1];PPOP1:	RTEMP&larr;MAPVA&larr;P&larr;P-Q, SAMASK[22], CALL[BXMEM];	PP&larr;P, P&larr;ICTR, Q&larr;STEMP, GOTO[JMP1,K=1];	P&larr;MDR, Q&larr;777777R, GOTO[XCTBL];*HERE ON JUMP INSTRUCTIONS WITH JUMP DISPLACEMENT IN Q, ICTR IN P.*TIMING = R-X+10JMP1:	ICTR&larr;P+1, 0Q RCY [22], Q&larr;PC;	P&larr;P+Q, Q&larr;3 777777L, CLEARF[BIS&amp;K], DGOTO[LENTER,K=0];*Q&larr;NON-OVERFLOW, P&larr;OVERFLOW	Q&larr;P AND Q, PQ RCY [24], SAMASK[20], CALL[JMPNEG,ALU&lt;0];	Q&larr;P+Q, P&larr;MDR;	LAC&larr;P, P&larr;NULL, GOTO[LENTER];JMPNEG:	P&larr;(P) U (777777 600000S), RETURN;JMP0:	Q&larr;P-Q, P&larr;ICTR, CLEARFC[K,H=0], GOTO[JMP1,H=0];	P&larr;PP, Q&larr;(2 000002R) RSH 1, STEMP&larr;Q, GOTO[PPOP1];*HERE ON JUMPX, ARG BYTE IN PJUMPX:	Q&larr;777777 777400S, RETURN;*HERE ON JUMPXX, FIRST ARG BYTE IN Q, 2ND IN PJUMPXX:	Q&larr;(P) U (777777 400000S), PQ RCY [33];JMP:	Q&larr;P+Q, P&larr;ICTR, SETSF[K], GOTO[JMP1];*CONDITIONAL JUMP ON ALU=0.  HAVE JUMP BYTE IN P, 400 IN QJEQT:	P AND Q, SETSF[K], GOTO[PPOP,ALU#0];JCONDP:	P&larr;P AND NOT Q, Q&larr;(200R) RSH 1, SETF[K], GOTO[JMP0,ALU=0];	Q&larr;P-Q, GOTO[PPOP];PPOP2:	P&larr;PP, Q&larr;2 000002R, RETURN;PPOP3:	P&larr;PP, Q&larr;3 000003S, RETURN;*RETURN THE TYPE OF Q IN P, ORIGINAL P IN Q*TIMING = R+5LDT:	LTEMP&larr;P, QQ RCY [11], XMASK, Q&larr;TYPTAB, CALL[IVAR];	AMASK[6], Q&larr;LTEMP, MDR&larr;102S, RETURN; *MDR&larr;102 FOR DATA TYPE ERRORS*HAVE TYPE IN Q, CONDITIONAL JUMP BYTE IN P.*RETURN ALU=(TYPE OF LAC)-TYPE, CONDITION-JUMP BYTE IN P, 400 IN Q*TIMING = R+7TTYPE:	RTEMP&larr;P, P&larr;Q, Q&larr;LAC, CALL[LDT];JCOND1:	P-Q, P&larr;RTEMP, Q&larr;400S, RETURN;*JUMP IF P .G. Q*HAVE H=1 IF P-Q OVERFLOWED--THEN MUST DO COMPLEMENT TESTTG:	FRZBALUBC, NPC&larr;@JCONDP, GOTO[.+3,H=1];	P AND Q, SETF[H], GOTO[PPOP,ALU&lt;=0];TLE:	FRZBALUBC, NPC&larr;@JCONDP, GOTO[.-1,H=1];	P AND Q, SETF[H], GOTO[PPOP,ALU&gt;0];*JUMP IF P .GE. 0*HAVE H=1 IF P-Q OVERFLOWED--THEN MUST DO COMPLEMENT TESTTGE:	FRZBALUBC, NPC&larr;@JCONDP, GOTO[.+3,H=1];	P AND Q, SETF[H], GOTO[PPOP,ALU&lt;0];*JUMP IF P .L. 0TL:	FRZBALUBC, NPC&larr;@JCONDP, GOTO[.-1,H=1];	P AND Q, SETF[H], GOTO[PPOP,ALU&gt;=0];*TEST INTEGERS EQUALTEH:	P-Q, SETF[H], P&larr;L5, Q&larr;400R, RETURN;*COMPARE INTEGERS, H&larr;1 IF OVERFLOWTE:	P-Q, SETHOVF, P&larr;L5, Q&larr;400R, RETURN;*RETURN ALU=(P AND Q)#LAC, RTEMP IN P, 400 IN Q, H=1TEQ:	P&larr;P AND Q, Q&larr;LAC, SETF[H], GOTO[JCOND1];*RETURN P IN P, 400 IN Q, ALU=0 IFF TYPE OF Q=LISTTTTLIST:	RTEMP&larr;P, QQ RCY [11], XMASK, Q&larr;TYPTAB, CALL[IVAR];	AMASK[6], Q&larr;LISTT, GOTO[JCOND1];*RETURN ALU#0 IF TYPE OF LAC .L. STACK OR .G. SMALLT WITH NEXTBYTE IN P,*400 IN Q; ELSE RETURN ALU=0.TATTYP:	RTEMP&larr;P, QQ RCY [11], XMASK, Q&larr;TYPTAB, CALL[IVAR];	AMASK[6], Q&larr;STACK;	P-Q, Q&larr;SMALLT, POP;	P-Q-1, P&larr;RTEMP, Q&larr;400S, RETURN[ALU&lt;0];	AQ, RETURN[ALU&gt;=0];	A0, RETURN;*CLEAR STATE AND ADD Q TO CBSSSTATQ:	P&larr;CBS;*HERE WITH CBS IN P.  CLEAR STATE AND ADD QADVSTT:	Q&larr;(NOT P) U (370000 000000S), P&larr;Q;CBSPQ:	P&larr;CBS&larr;P-Q-1, Q&larr;RTEMP, RETURN;*HERE TO INCREMENT STATE IN CBSINCSTT:	P&larr;CBS, Q&larr;767777 777777S, GOTO[CBSPQ];*TRAP IF TYPE OF -1(PP) IS NOT LISTT, ELSE RETURN WITH -1(PP) IN P, 777777 IN Q.RPLSUP:	P&larr;PP, Q&larr;1R, CALL[FPMQ];	Q&larr;P&larr;P AND Q, CALL[TTLIST];	Q&larr;777777R, MDR&larr;100S, RETURN[ALU=0];*ALSO GET HERE WITH 102 IN MDR FOR DATA TYPE ERRORSTYPERR:	P&larr;(RPLERX) U (MDR), GOTO[FCALLX];RPL:	Q&larr;P&larr;REFADR, PP&larr;P-Q, SAMASK[22], GOTO[XCTBL];GETPLP:	L5&larr;P AND Q, P&larr;ICTR, SETSF[INTCONDH], DGOTO[GETP3];	ICTR&larr;P+1, P&larr;L5, CALL[BPI,H=1];GETP:	P&larr;PP, Q&larr;(2 000002R) RSH 1,  A0, GOTO[FPMQ,K=0]; *FPMQ RETURNS TO GETP1GETP2:	P&larr;L5, AMASK[22], Q&larr;SNIL, GOTO[PRQ,ALU#0];GETP3:	MAPVA&larr;P, SETF[BIS&amp;K], CALL[BRMEM]; *P&larr;PROPLIST OR CDR	RTEMP&larr;P, PQ RCY [11], XMASK, Q&larr;TYPTAB, CALL[IVAR];GETL2:	AMASK[6], Q&larr;LISTT;*EXIT WITH RESULT NIL IF CDR IS NOT A LIST, ELSE P&larr;CDDR,CADR	P#Q, P&larr;RTEMP, Q&larr;SNIL, CALL[CRDPQ];	RTEMP&larr;P, PQ RCY [33], XMASK, Q&larr;TYPTAB, CALL[IVAR];	AMASK[6], Q&larr;LISTT;	P#Q, P&larr;RTEMP, BAMASK[22], Q&larr;LAC; *CDDR A LIST?	P#Q, P&larr;RTEMP, Q&larr;SNIL, GOTO[PRQ,ALU#0]; *CADR EQ PROPERTY?	PQ RCY [22], Q&larr;777777R, GOTO[GETPLP,ALU#0];	MAPVA&larr;P&larr;P AND Q, CALL[BRMEM];PAQR:	Q&larr;LAC&larr;P AND Q, SETSF[H], GOTO[PR1];GETL1:	RTEMP&larr;L5&larr;P AND Q, PQ RCY [11], XMASK, Q&larr;TYPTAB, GOTO[IVAR];*HERE WITH -1(PP) IN P, 777777 IN QGETP1:	L5&larr;P AND Q, PQ RCY [11], XMASK, Q&larr;TYPTAB, CALL[IVAR];	AMASK[6], Q&larr;ATOMT, GOTO[JCOND1]; *RETURNS TO GETP2*HAVE ARG1 IN P, 777777 IN Q, ARG2 IN LAC.  DETERMINE IF ARG1 IS EQ*SOME ELEMENT OF THE LIST ARG2.FMEMB1:	P&larr;RTEMP, CALL[BPI,H=1];FMEMB:	RTEMP&larr;P, P&larr;LAC, Q&larr;SNIL, CALL[JCOND1]; *RTEMP&larr;ARG1, NIL TEST ON ARG2	P&larr;LAC, AMASK[22], Q&larr;SNIL, GOTO[PRQ,ALU=0];	MAPVA&larr;P, CALL[BRMEM]; *CAR(ARG2), CDR(ARG2)	Q&larr;P AND Q, PQ RCY [22], BAMASK[22], SETSF[INTCONDH]; *Q&larr;CAR, P&larr;CDR	LAC&larr;P, P&larr;RTEMP, BAMASK[22];	P#Q, P&larr;ICTR, DGOTO[PAQR];	ICTR&larr;P+1, Q&larr;LEFADR, P&larr;777777S, GOTO[FMEMB1,ALU#0];*HAVE ARG1 IN P, 777777 IN Q, REMAINING LIST IN RTEMP AND AC1ASSOC:	ROPCD&larr;P AND Q;ASSOC1:	P&larr;LISTT, Q&larr;LAC, CALL[LDT]; *P&larr;TYPE OF LAC, Q&larr;LISTT*EXIT WITH RESULT NIL IF LAC IS NOT A LIST, ELSE P&larr;CDR,,CAR	P#Q, P&larr;LAC, Q&larr;SNIL, CALL[CRDPQ];	MAPVA&larr;RTEMP&larr;P, SAMASK[22], CALL[BRMEM]; *P&larr;CDAR,,CAAR	SAMASK[22], Q&larr;ROPCD, CALL[JCOND1]; *P&larr;CDR,,CAR, ALU=0 IF CAAR=ARG1	Q&larr;REFADR, PQ RCY [22], SAMASK[22], GOTO[PRQ,ALU=0];	LAC&larr;P, P&larr;ICTR, SETSF[INTCONDH], DGOTO[ASSOC1];	ICTR&larr;P+1, CALL[BPI,H=1];%DEIMPLEMENTED FOR LACK OF STORAGE*HAVE REMAINING LIST IN AC1LENGTH:	P&larr;L5, CALL[ZEROP,K=0];*HAVE LENGTH IN P, POINTER TO REST OF LIST IN QLENG1:	SETSF[K], CALL[TTLIST]; *RTEMP&larr;P&larr;LENGTH, ALU=0 IF A LIST	Q&larr;3000S, RETURN[ALU#0];	P&larr;LAC, SETF[BIS&amp;K], CALL[READP]; *P&larr;CDR(AC1)	Q&larr;LAC&larr;P, P&larr;RTEMP, DGOTO[LBPCK];	L5&larr;P+1, P&larr;ICTR, SETSF[INTCONDH], DGOTO[LENG1];%*RETURN POINTER TO THE LAST ELEMENT OF A LISTLAST:	P&larr;SNIL, GOTO[TTLIST,K=0]; *TTLIST RETURNS TO LAST1*L5/ RESULT IF NOT A LIST, Q/ POINTER TO TAILLAST0:	P&larr;L5, AMASK[22], SETSF[K], CALL[TTLIST];*P/ RESULT IF NOT LIST, LAC/ TAIL OF LIST, ALU=0 IF TAIL IS A LISTLAST1:	Q&larr;LAC, SETF[BIS&amp;K], GOTO[FIXSP,ALU#0];	MAPVA&larr;L5&larr;P&larr;AQ, SAMASK[22], CALL[BRMEM]; *AC5&larr;AC1, P&larr;CDR(AC1)	Q&larr;LAC&larr;P, P&larr;ICTR, SETSF[INTCONDH], DGOTO[LAST0];LBPCK:	ICTR&larr;P+1, P&larr;L5, CALL[BPI,H=1];*DATA TYPE ROUTINESBFETCH:	RTEMP&larr;P AND Q, P&larr;LAC, SETF[J], GOTO[STORE];BFET1:	MAPVA&larr;RTEMP&larr;P&larr;P+Q, SAMASK[22], CALL[BXMEM];*RTEMP,P/ BYTE POINTER TO DATUM, MDR/ WORD AFFECTED	ISPLIT&larr;Q&larr;P, CALL[BDPB]; *G&larr;0 IF MUST BOX BYTE	PQ RCY [Y], XMASK, GOTO[IREMN,G=0];	LAC&larr;Q&larr;P, SETSF[H], GOTO[PR1];*TRAP IF THE TYPE OF THE DATUM IS .NE. TYPE OF DESCRIPTOR.*IF J=1, GOTO BFET1 WITH THE SELECTED ITEM IN P+Q, G=0 IF BOX/UNBOX.*AT CALL:  P/ POINTER TO DESCRIPTOR, RTEMP/ POINTER TO DATUMSTORE:	MAPVA&larr;P, SAMASK[22], CALL[BRMEM];	L6&larr;P, PQ RCY [11], SAMASK[7], DGOTO[.+1];	Q&larr;P, GOTO[.+2,ALU=0];	Q&larr;RTEMP, CALL[LDT];*P/ TYPE OF DATUM, Q/ TYPE OF DESCRIPTOR, 6/ DESCRIPTOR, RTEMP/ PTR TO DATUM*MDR/ TRAP DISPLACEMENT FOR DATA TYPE ERROR	P#Q, P&larr;L6, Q&larr;777000S, DGOTO[BFET1,J=1];	ISPLIT&larr;P&larr;P AND NOT Q, Q&larr;RTEMP, GOTO[TYPERR,ALU#0];	Q&larr;RTEMP&larr;P+Q, P&larr;LAC, INCAC, X&larr;11S, CALL[UNBOX,G=0];*HAVE BYTE TO BE STORED IN P, BYTE POINTER IN Q AND RTEMP	LAC&larr;P, P&larr;Q, Q&larr;NULL, CALL[BRMWPMQ];	Q&larr;RTEMP, A0, CALL[BDPB];	Q&larr;LAC, SETF[H], GOTO[PR1];*UNBOX RETURNS UNBOXED INTEGER P IN P, RTEMP IN Q*UNBOX1 RETURNS UNBOXED INTEGER -1(PP) IN P, RTEMP IN Q*UNBSP RETURNS UNBOXED Q IN Q, UNBOXED -1(PP) IN P, ORIGINAL P IN L5UNBSP:	L5&larr;P, P&larr;Q, CALL[UNBOX];UNBOX1:	RTEMP&larr;P, P&larr;PP, Q&larr;1S, CALL[FPMQ];UNBOX:	L6&larr;Q&larr;P, P&larr;SMALLT, CALL[LDT];	P#Q, Q&larr;FIXT;	P#Q, P&larr;L6, Q&larr;SZERO, GOTO[PMQ,ALU=0];	Q&larr;P, P&larr;BLIUBE, GOTO[FCALLY,ALU#0]; *ARG NOT INTEGER?	MAPVA&larr;P&larr;AQ, SAMASK[22], CALL[BXMEM];*! MAXC1 ONLY	X&larr;11S;	P&larr;MDR, Q&larr;RTEMP, RETURN;*!*~ MAXC2 ONLY	P&larr;MDR, Q&larr;RTEMP, BAX[11], RETURN;*~*ROUTINE TO BOX INTEGER RESULT IN "RTEMP" FOR OPERATION WITH TWO ARGUMENTSIBOX:	PP&larr;P-Q-1, P&larr;RTEMP, Q&larr;3000S;*ROUTINE TO BOX INTEGER RESULT IN P FOR OPERATION WITH ONE ARGUMENTIBOX0:	P-Q, MDR&larr;100S;	P+Q, Q&larr;SZERO, GOTO[.+2,ALU&gt;=0];IBOX1:	LAC&larr;P+Q, MDR&larr;100S, GOTO[FIXSTK,ALU&gt;=0]; *SMALL INTEGER RESULT	LAC&larr;P, P&larr;(BXNUM) U (MDR), GOTO[FCALLX];BIDIV:	Q&larr;P, P&larr;Q, GOTO[IDIV];IQUOT:	RTEMP&larr;Q, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];IREMN:	RTEMP&larr;P, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];IAND2:	RTEMP&larr;P AND Q, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];IOR2:	RTEMP&larr;P OR Q, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];IXOR2:	RTEMP&larr;P#Q, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];IDIF2:	RTEMP&larr;P-Q, SETOVPC01, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];IPLUS2:	RTEMP&larr;P+Q, SETOVPC01, P&larr;PP, Q&larr;1 000000S, GOTO[IBOX];*HAVE SHIFT COUNT IN Q, INTEGER IN PBLLSH:	YSHIFT&larr;Q, Q&larr;P, GOTO[LSH];BLASH:	YSHIFT&larr;Q, Q&larr;P, GOTO[ASH];IPLUS1:	P&larr;P+Q, SETOVPC01, Q&larr;3000S, GOTO[IBOX0];QFM1:	Q&larr;A1, RETURN;%DEIMPLEMENTED FOR LACK OF STORAGE*HAVE NEXTBYTE IN P, AC1 IN Q.  SETUP FOR ZERO TEST.ZEROT:	Q&larr;SZERO, P&larr;LAC, RTEMP&larr;P, BAMASK[22], RETURN;%*! MAXC1 ONLYFNOPC:	CALL[GOSTAT];	*HERE FOR FN0, FN1, FN2, AND FN3*!*HAVE NUMBER OF ARGS IN Q, NAME DISPLACEMENT IN RTEMP, 1 IN AC*TIMING = R + 43FNX:	LAC&larr;Q, P&larr;RTEMP, AC&larr;2S;	P&larr;NOT P, Q&larr;CBS, CALL[GETCON]; *P&larr;FUNCTION NAME, Q&larr;777777LFNC:	LAC&larr;P AND Q, DECAC;	P&larr;CBS, Q&larr;370000 000000S;*PUSH CP,CBS.  SAVED STATE = DON'T CARE	CBS&larr;P&larr;P AND NOT Q, SETF[BIS], CALL[CPPUSH];*! MAXC1 ONLYST0:	P&larr;ISPLIT&larr;WPC, Q&larr;10772 777777R, CALL[ADVPC];	RTEMP1&larr;P OR NOT Q, P&larr;CBS, Q&larr;767777 777777S, CALL[PDPCP1];*!*~ MAXC2 ONLYST0:	ISPLIT&larr;BPC, CLEARF[BIS], P&larr;CBS, Q&larr;7777 777777R;	CBS&larr;P+Q+1, Q&larr;TENF, SETF[BIS];	P&larr;(Q) U (BPC), CALL[CPPUSH];*~ST1:	Q&larr;BRET, P&larr;PP;PLAM:	RTEMP&larr;Q, BAMASK[22], Q&larr;LAC, AC&larr;17S; *VP&larr;POINTER TO ARG 0 - 1	VP&larr;Q&larr;P-Q, P&larr;RTEMP, CLEARF[BIS&amp;MD0&amp;MD1&amp;MD2&amp;J], CALL[POQL22];	MDR&larr;P OR Q, Q&larr;CBS, P&larr;7777 777777R, SETSF[J];	CBS&larr;P+Q+1, DGOTO[FNCTRP]; *INCREMENT STATE FOR "BIND" AND "DBIND"*FINISH WITH PDP-10 MODE PUSH CP,MDR	PC&larr;NPC, P&larr;LAC, Q&larr;(2 000002R) RSH 1, GOTO[PUSH0];*HAVE NUMBER OF ARGS IN Q, DISPLACEMENT OF TWO-WORD BLOCK IN RTEMP, 1 IN AC*EFNCAL WILL EXECUTE THE PUSHJ CP,5 AT LFCALL.LFNX:	LAC&larr;Q, P&larr;RTEMP, AC&larr;2S;	P&larr;CBS, Q&larr;P+1, CALL[FPMQ]; *P&larr;HCCALBITS,,DEF	MAPVA&larr;P&larr;40S, ACFS, Q&larr;P, CALL[BWRQR]; *SIMULATE UUO STORE	Q&larr;RTEMP, P&larr;CBS, CALL[FPMQ]; *P&larr;NAME,,JUMP ADDRESS	Q&larr;(P AND Q) U (324000 000000S), PQ RCY [22], BAMASK[22];	L6&larr;Q, Q&larr;201100 000000S, DGOTO[LFCALL]; *AC6&larr;JUMPA UUOROUTINE OR DEF	L5&larr;P OR Q, P&larr;NPC, Q&larr;777777R, GOTO[LFNC]; *AC5&larr;MOVEI 2,NAMEZUNBND:	P&larr;NULL, GOTO[UNBIND];*"RETURN" AND "XRETURN" COME HERE--SBCAL DOES THE SWAP FIX UP FOR "RETURN"BRETRN:	RTEMP&larr;P, P&larr;CBS, Q&larr;7400 000000S;*UNBIND COMES HERE WITH 0 IN PUNBIND:	P AND Q, P&larr;CBS, Q&larr;400 000000S, DGOTO[FCALLY];*RETURN TO "FCALLX" FOR "UNBIND" AND "RETURN", TO "XRETRN" FOR "XRETURN"	CBS&larr;P-Q, Q&larr;RTEMP, P&larr;102S, RETURN[ALU=0];%POP PP ACCORDING TO THE ARG BYTE.  PDP-10 CODE AT "BRET3" IS:	MOVEM 1,0(PP)	BFRET CBS,0(CP)%XRETRN:	QQ RCY [22];	Q&larr;P OR Q, P&larr;PP, DGOTO[BRET3];	PP&larr;P-Q, P&larr;NPC, GOTO[FCALLX];%BLOCK CALL TO BYTE LISP FUNCTION NOT BUILDING FRAME.  4 OPCODE BITS ANDNEXTBYTE FORM A 13-BIT NUMBER SUCH THAT NUMBER - 10000 IS THE DISPLACEMENTFROM THE WORD CONTAINING "LCALL" TO THE "BLISP INSTRUCTION BEGINNING THESUBROUTINE.%LCALL:*! MAXC1 ONLY	P&larr;(ROPCD) RSH [1], SAMASK[4], CALL[GNBYT];*!	Q&larr;(P) U (777777 770000S), PQ RCY [33];	P&larr;P+Q, Q&larr;PC;*K=1 IF ALREADY PUSHED CBS.  SAVE NEW PC IN "LTEMP" FOR "PUSHJ1"	LTEMP&larr;P+Q, AC&larr;17S, GOTO[.+2,K=1];	P&larr;CBS, SETF[BIS], CALL[CPPUSH];*! MAXC1 ONLY	P&larr;ISPLIT&larr;WPC, Q&larr;10772 777777R, CALL[ADVPC]; *ADVPC CLEARS BIS	MDR&larr;P OR NOT Q, P&larr;LAC, Q&larr;(2 000002R) RSH 1, CLEARF[BIS&amp;MD0&amp;MD1&amp;MD2&amp;J], GOTO[PUSHJ1];*!*~ MAXC2 ONLY	ISPLIT&larr;BPC, CLEARF[BIS&amp;MD0&amp;MD1&amp;MD2&amp;J], CALL[QBPC];	MDR&larr;(Q) U (TENF) U (MD2), P&larr;LAC, Q&larr;(2 000002R) RSH 1, GOTO[PUSHJ1];*~%6 AND Q/  -NARGS TO DO,,PTR TO NEXT-15/  NARGS ALREADY ON STACKCBSP/ DISPLACEMENT OF NEXT ARG RELATIVE TO CBS IN POINTER AREASTATE = CALLER OF BINDA%BINDA4:	L5&larr;P-1, P&larr;Q&larr;SNIL; *PUSH NIL FOR ANONYMOUS ARGS NOT ON STACK*PUSH VCELL-PTR,, OLD VALUE FOR NAMED ARGSBINDA3:	MDR&larr;P OR Q, P&larr;PP, Q&larr;(2 000002R) RSH 1, SETSF[J], CALL[PPSHR1,ALU&lt;0];ST7:BINDA2:	Q&larr;L6;BINDA:	ROPCD&larr;Q, P&larr;CBSP, CALL[BINDA0]; *GETCON OR EXIT IF DONE	RTEMP&larr;P AND Q, P&larr;L5, MDR&larr;SNIL; *RTEMP&larr;VCELL POINTER	RTEMP1&larr;P, P&larr;L6, SETFB[H,ALU=0], GOTO[BINDA1,ALU=0]; *GO IF ANONYMOUS	MAPVA&larr;P&larr;P+1, SAMASK[22], CALL[BXMEM,ALU&gt;0]; *MDR&larr;NEW VALUE (OR LEAVE NIL)	P&larr;MDR, Q&larr;777777R;	LTEMP&larr;P AND Q, P&larr;RTEMP, Q&larr;NULL, CALL[BRMWPMQ]; *LTEMP&larr;NEW VALUE	LPGRT&larr;P AND Q, WRESTART; *LPGRT&larr;OLD VALUE	P&larr;P AND NOT Q, Q&larr;LTEMP, SETSF[H], INHINT;BINDA1:	MDR&larr;P OR Q, P&larr;CBSP, Q&larr;(2 000002R) RSH 1; *R.H. MDR&larr;NEW VALUE	CBSP&larr;P+1, P&larr;ROPCD;	L6&larr;P+Q, P&larr;RTEMP1, GOTO[BINDA4,H=1];	L5&larr;P-1, Q&larr;RTEMP;	0Q RCY [22], Q&larr;LPGRT, FRZBALUBC, GOTO[BINDA3,ALU&lt;0];*WRITE VCELL-PTR,,OLD VALUE ON TOP OF NEW VALUE ON STACK	P&larr;L6, Q&larr;P OR Q, SAMASK[22], DGOTO[BINDA2];	MAPVA&larr;P, CALL[BWRQR];BIND:	CALL[GOSTAT];*HAVE N1.N2 IN Q, N IN RTEMP	QQ RCY [5], BAMASK[4]; *P&larr;N1 = NARGS TO NAME	MDR&larr;L5&larr;Q&larr;P, P&larr;Q, SAMASK[5]; *P&larr;N2 = NARGS TO GET NIL	LAC&larr;Q&larr;P+Q, P&larr;NULL, SETF[BIS]; *1&larr;NARGS TOTAL	RTEMP1&larr;P-Q, P&larr;PP, Q&larr;MDR, SAMASK[22]; *RTEMP1&larr;-NARGS TOTAL, Q&larr;NARGS TO NAME	P&larr;P-Q, Q&larr;RTEMP1, SAMASK[22], CALL[POQL22]; *P&larr;-NARGS TOTAL,,0  Q&larr;PTR TO 1ST ON STK-1	L6&larr;P OR Q, Q&larr;70000 000000S, CALL[SSTATQ];	CBSP&larr;Q, CALL[BINDA2]; *CBSP&larr; RTEMP = N*NOTE FANCY USE OF EXTRA RETURN IN STATE DISPATCH AFTER ST7*2&larr;BNDTRP-1 = DUMMY ATOM FOR XCT 1(2)*! MAXC1 ONLYBINDR:	LAC&larr;Q, Q&larr;(NOT F) U (NOTFLAGS), DECAC;	Q&larr;(NOT Q) U (PC), P&larr;PP;*!*~ MAXC2 ONLYBINDR:	LAC&larr;Q, Q&larr;(TENF) U (PC), DECAC;	P&larr;PP;*~	L6&larr;Q, Q&larr;STACK, GOTO[PLAM];*FUNCTION SETUP IN PDP-10 MODE RESUMES BIND AT ST8.ST8:	P&larr;CBS, Q&larr;10400 000000S;	CBS&larr;P+Q, P&larr;SKPRGLM, CALL[PPPSHR]; *PUSH FN NAME, ADD 1 TO DEPTH &amp; STATEST9:	P&larr;CBS, Q&larr;2S, CALL[BNDFIX];	P&larr;P AND Q, Q&larr;PP, WRESTART, AC&larr;1S, CALL[POQL22]; *HRLM PP,-2(CP)	MDR&larr;P OR Q, P&larr;LEFADR, Q&larr;1R, CALL[BRMWPMQ];	RTEMP&larr;P&larr;P AND Q, Q&larr;LAC, WRESTART, AC&larr;3S, CALL[POQL22];	MDR&larr;P OR Q, Q&larr;RTEMP, DGOTO[XCTBL]; *HRLM 1,-3(CP)	VP&larr;Q, MAPVA&larr;P&larr;CF, ACFS, CALL[BRMEM];*SKIP TWO MORE STACK ITEMS IN A SWAPPED FUNCTIONBNDFIX:	ISPLIT&larr;2P, P&larr;CP, DGOTO[BRMWPMQ];	MAPVA&larr;P&larr;P-Q, SAMASK[22], GOTO[BRMWM,G=1];	*GO IF NOT SWAPPED*RETURN WITH Q UNCHANGED, P IN RTEMP IF BIS=0, ELSE DISPATCH TO STATE*WITH 1 IN AC, K=0GOSTAT:	RTEMP&larr;P, P&larr;(CBS) RSH [1], BAMASK[42], SETSF[BIS&amp;K];	BSPLIT&larr;P, PQ RCY [35], BAMASK[1], RETURN[K=0];	POP, YKPTR&larr;Y; *FLUSH REGULAR RETURN FROM STACK	P, NPC&larr;STACK&larr;BST;	SETSF[K], GOTO[RETN,ALU#0]; *RETURN ILLEGAL AFTER STACK&larr;%HAVE BLISP INSTRUCTION IN "INSTR" IN PDP-10 MODE.  CARRY OUTFUNCTION ENTRY.  "INSTR" USED AS FOLLOWS:   B[11,14] = A = NUMBER OF ARGUMENTS EXPECTED (1 FOR NO-SPREAD)   B[15] = SWAPPED FUNCTION   B[16] = VARIABLE NUMBER OF ARGUMENTS (NO SPREAD)   B[17] = EVALUATE ARGUMENTS   B[20] = ALL ARGS LOCALVARS   B[21] = NO FRAME   B[22,43] = DISPLACEMENT IN HALF-WORDS TO FIRST CONSTANT FROM PCINSTRUCTION TRAP IF PC IS 0-17.  HAVE NARGS PASSED IN 1, FN NAME IN 2TIMING = M+2R+56 +[2+8/ARG IF ALL ARGS LOCALVARS]%BL:	P&larr;INSTR, AMASK[27], Q&larr;17 000000S;	*PRESERVE "SWAPPED" BIT	MAPVA&larr;Q&larr;PC, ACFS, P&larr;P AND NOT Q, CALL[BL0];*HAVE STATE 12 (STA), DEPTH 0, CBS IN Q, NO-FRAME BIT IN RTEMP[21]*HAVE REST OF STUFF IN "INSTR"	CBS&larr;Q, P&larr;Q&larr;RTEMP, BAMASK[22];	P#Q, P&larr;INSTR, DGOTO[QL1]; *"QL1" = Q LSH 1 RETURNS TO "BL6"*P&larr;NARGS EXPECTED, G&larr;SPREAD	ISPLIT&larr;Q&larr;2P, PQ RCY [27], SAMASK[4], GOTO[BLXIT,ALU#0];BL0:	P&larr;Q, Q&larr;(P) U (240000 000000S), GOTO[ILLIO,G=1]; *PC= 0 TO 17 TRAPS*BACKUP PC, SO THAT IF INSTRUCTION IS INTERRUPTED IT WILL BE*RESTARTED.  ADD PC TO RIGHT 18 INSTRUCTION BITS RCY 1 TO FORM "CBS"	OLDPC&larr;Q&larr;P-1, AC&larr;1S, QQ RCY [1], DGOTO[GOSTAT];	PC&larr;Q, Q&larr;P+Q, P&larr;INSTR, BAMASK[23]; *"GOSTAT" RETURNS TO "BL"+1*RTEMP&larr;L5&larr;NARGS EXPECTED, J&larr;1 IF SPREAD, G&larr;0 IF EVALUATE ARGSBL6:	RTEMP&larr;L5&larr;P, ISPLIT&larr;Q, SETFB[J,G=1], DGOTO[.+3,G=1];*P&larr;NARGS PASSED, Q[15]&larr;SWAPPED, LEAVE J=1 IF NOT LAMBDA ATOM	P&larr;LAC, Q&larr;INSTR, SETFC[J,G=1], GOTO[.+2,G=1];	RTEMP&larr;P+1; *NARGS ON STACK=NARGS PASSED+1 FOR LAMBDA ATOMS	ISPLIT&larr;Q, CBSP&larr;A0; *G&larr;0 IF SWAPPED	P&larr;CP, Q&larr;A1, AC&larr;4S, CALL[QF1,G=0];	P&larr;LAC&larr;P-Q-1, Q&larr;3S, CALL[BRMWPMQ]; *4&larr;CP IF UNSWAPPED, CP-2 IF SWAPPED	P&larr;P AND Q, Q&larr;RTEMP, AC&larr;1S, WRESTART, CALL[POQL22];*HRLM A,-3(CP) OR -5(CP), P&larr;NARGS PASSED, Q&larr;NARGS EXPECTED.	MDR&larr;P OR Q, P&larr;LAC, SETF[BIS], Q&larr;RTEMP, GOTO[BL3,J=0];	P&larr;Q&larr;P-Q, BAMASK[22]; *P&larr;Q&larr;SURPLUS ARGS	Q&larr;P, 0Q RCY [22], GOTO[BL7,ALU&gt;0]; *REDUCE PP IF SURPLUS	P&larr;LAC, Q&larr;RTEMP; *P&larr;NARGS PASSED, Q&larr;NARGS EXPECTED*P&larr;NARGS EXPECTED,,0.  Q&larr;NARGS PASSED.  SKIP IF NARGS EXPECTED IS .LE. PASSED	P-Q, 0Q RCY [22], Q&larr;LAC;	GOTO[.+2,ALU&gt;=0];	L5&larr;Q; *L5&larr;MIN(NARGS PASSED,NARGS EXPECTED)BL2:	P&larr;PP, SAMASK[22], Q&larr;P OR Q;BL4:	P&larr;L6&larr;P-Q, Q&larr;NULL; *L6&larr;-NARGS TO BIND,,PTR TO 1ST-1*SKIP THE BL1 CALL IF NO ARGS TO BIND	NOT(P)Q RCY [22], Q&larr;L5, DGOTO[BL5,ALU&gt;=0]; *P&larr;NARGS TO BIND-1	TP&larr;P-Q, CALL[INCSTT]; *TP&larr;NARGS TO BIND-NARGS ON STK-1STB:	P&larr;INSTR, Q&larr;2 000000S, CALL[BL1];BL5:	AC&larr;2S;		*NEEDED FOR NO-ARGS CASE	P&larr;CBS, Q&larr;767777 777777S, CALL[CBSPQ];	P&larr;LAC, CALL[PPPSHR]; *PUSH FUNCTION NAMESTC:	P&larr;L4, Q&larr;2S, CALL[BRMWPMQ];	P&larr;P AND Q, Q&larr;PP, WRESTART, CALL[POQL22]; *HRLM PP,-2(CP) OR -4(CP)	MDR&larr;P OR Q, CLEARF[BIS];BLXIT:	P&larr;PC, Q&larr;(2 000002R) RSH 1, GOTO[LENTER];*HERE ON EXACT OR SURPLUS ARGS PASSED WITH -SURPLUS IN P[0,21] AND Q[22,43]BL7:	P&larr;PP, Q&larr;P OR Q, DGOTO[BL2];	PP&larr;P-Q, P&larr;Q&larr;RTEMP, SAMASK[22], CALL[POQL22];*HERE FOR LAMBDA NO-SPREAD FUNCTIONSBL3:	MDR&larr;(SZERO) U (P), P&larr;PP, Q&larr;(2 000002R) RSH 1, CALL[PPSHR1];STA:	Q&larr;(2 000002R) RSH 1, P&larr;PP, SAMASK[22], GOTO[BL4];*CHOOSE "LBIND" OR "BIND" ACCORDING TO ALL-ARGS-ARE-LOCALVARS BITBL1:	P AND Q, AC&larr;2S, Q&larr;L6;	GOTO[BINDA,ALU=0];*TP/ COUNT OF PUSHES LEFT TO DO-1	P&larr;TP, SETSF[14S], DGOTO[.];	P, Q&larr;PP, MDR&larr;SNIL, CALL[.+1];	TP&larr;P-1, P&larr;Q, Q&larr;(2 000002R) RSH 1, AC&larr;2S, GOTO[PPSHR1,ALU&gt;=0];BNDRET:	Q&larr;BNDTRP, POP, GOTO[RETN];RMWHPPQ: MAPVA&larr;P&larr;P+Q, SAMASK[22], GOTO[RMWHARG];%PDP-10 INSTRUCTION "RETFR" REPLACING FUNCTION RETURN CODE IN LISP.MACHAVE [E]=0(CP)=CLINK IN RTEMP, 3 IN AC.TIMING = M + 6R + 41 + (2R+12)/NAMED VALUE UNBOUND + (R+9)/ANONYMOUS%RETFR:	P&larr;CBS, Q&larr;60000 000000S, CALL[ADVSTT];	LAC&larr;Q, MAPVA&larr;P&larr;CF, ACFS, CALL[RHARG]; *3&larr;0(CP), P&larr;CF, Q&larr;777777	MAPVA&larr;P&larr;P AND Q, CALL[RHARG]; *P&larr;NARGS,,PP OR 1ST ARG-1*P&larr;-NARGS-1,,PP OR 1ST ARG-1	P&larr;P=Q, Q&larr;(2 000002R) RSH 1, GOTO[RETFR5];*GOSTAT COMES HERE IF INTERRUPTED AFTER THE ABOVE STUFFST6:	P&larr;L5, Q&larr;A0, AC&larr;3S, SETSF[3S], GOTO[RETFR5];RETFR2:	MAPVA&larr;P&larr;AQ, CALL[RHARG]; *READ ARG ON STACK*RTEMP&larr;OLD VALUE AND P&larr;NAME OR ELSE P&larr;ZEROES IN ALL BITS EXCEPT 200	MDR&larr;P AND Q, PQ RCY [22], BAMASK[22], Q&larr;200R, SETSF[INTCONDH];	P AND NOT Q, STEMP&larr;MDR, GOTO[PI,H=1]; *TEST FOR ANONYMOUS	MAPVA&larr;P, CALL[RMWHARG,ALU#0];	MDR&larr;(P AND NOT Q) U (STEMP), WRESTART, P&larr;L5, Q&larr;(2 000002R) RSH 1;RETFR5:	L5&larr;P&larr;P+Q, Q&larr;777777R, SETF[BIS];	Q&larr;P AND Q, P&larr;LAC, GOTO[RETFR2,ALU&lt;0];	MAPVA&larr;P, SAMASK[22], CALL[RHARG]; *FETCH 0(3)	VP&larr;P AND Q, P&larr;(2 000002R) RSH [1], Q&larr;2 000002R;	P&larr;CP, Q&larr;P+Q;	MAPVA&larr;OLDPC&larr;P&larr;P-Q, SAMASK[22], CALL[SRARG]; *P&larr;PP OUT OF CALLER	RTEMP&larr;P, P&larr;LAC, Q&larr;2S, CALL[RMWHPPQ]; *RTEMP[22,43]&larr;PP OUT	Q&larr;P-Q-1, WRESTART; *DECREMENT USE COUNT IN L.H. OF P	STEMP&larr;Q, P&larr;PP, Q&larr;RTEMP, AMASK[22], INHINT, GOTO[.+2,ALU&lt;0];	MDR&larr;STEMP;	P&larr;Q&larr;P-Q, SAMASK[22], CALL[POQL22]; *Q&larr;PP-PP OUT, P&larr;PP-PP OUT,,0	Q&larr;P OR Q, P&larr;PP, B&larr;STEMP;	PP&larr;P-Q, P&larr;OLDPC, DGOTO[REMAPPC,B&gt;=0]; *EXIT TO PC+1 IF USE COUNT#0	CP&larr;P, CLEARF[BIS&amp;K], DGOTO[POPJTP];	PC&larr;NPC, P&larr;LAC, AMASK[22], GOTO[.+1]; *PC&larr;ADDRESS OF POPJ CP,	MAPVA&larr;P&larr;CF, ACFS, Q&larr;P, GOTO[WREFQ];%NEW OPCODE FOR DISPATCHING TO UUOS.  ACCEPTS ADDRESS OF DISPATCHTABLE IN E.  DOES A PUSHJ AC,@E+OPCODE (WHERE THE OPCODE IS OBTAINEDFROM LOCATION 40).TIMING = M+R+15%UPSHJ:	RTEMP&larr;P, P&larr;MAPVA&larr;40S, ACFS, CALL[RARG];	PQ RCY [33], AMASK[11], Q&larr;RTEMP, SETSF[G], GOTO[BINDE];*NEW OPCODE FOR LOADING THE TYPE OF A POINTERLDTYPE:	PQ RCY [11], AMASK[11], Q&larr;TYPTAB;BTLU1:	MAPVA&larr;P&larr;P+Q+1, SAMASK[22], GOTO[RHARG];*NEW PDP-10 OPCODE FOR BIT TABLE LOOKUP.  HAVE AC IN Q.*ALWAYS USED AS BTLU 1,--BTLU:	QQ RCY [11], Q&larr;TYPTAB, AMASK[11], CALL[PQQL22]; *P&larr;BTT, Q&larr;PAGE NUMBER	MAPVA&larr;P&larr;P+Q, SAMASK[22], CALL[RARG]; *FETCH POINTER TO BIT TABLE FROM "BTT"	Q&larr;P, QQ RCY [5], BAMASK[4]; *Q&larr;PTR TO BIT TABLE, P&larr;DISPLACEMENT	MAPVA&larr;P&larr;P+Q, SAMASK[22], CALL[RTOMDR]; *MDR&larr;BIT TABLE WORD, P&larr;LAC	BAMASK[5], Q&larr;400000 000000S;	Y&larr;P, P&larr;REFADR, INCAC, CALL[RETN];	QQ RCY [Y], LAC&larr;P, DECAC; *AC+1&larr;WORD POINTER	LAC&larr;P, Q&larr;MDR, GOTO[APANDQ];*ALWAYS GIVEN AS CHASE 1,CHASXCHASE:	INCAC, P&larr;LAC, RTEMP&larr;P, CALL[LDTYPE];	LAC&larr;P, Q&larr;100 000000S, DGOTO[RALUZ]; *Q&larr;SYSBIT	P AND Q, Q&larr;CP, P&larr;RTEMP, AC&larr;17S, DGOTO[PUSHJ];%REWIND OPCODE FOR REVERSING SHALLOW-DEEP BINDINGS IN A FRAME.CALLED WITH AN AOBJN POINTER TO THE ARGS OF A FRAME IN AC.IF AN ARG IS NOT A LOCALVAR THE CONTENTS OF THE VCELL AND THE FRAMEARE INTERCHANGED.  WHEN ALL ARGS ARE DONE, THE "SWPBIB" BIT ISCOMPLEMENTED.%REWIND:	P&larr;LAC, Q&larr;(2 000002R) RSH 1, SETSF[INTCONDH], INCAC; *USE AC+1 AS TEMPORARY	MAPVA&larr;RTEMP&larr;P+Q, P&larr;-1L, SAMASK[43], GOTO[PI,H=1];*AC+1&larr;SWPBIB	LAC&larr;P+1, P&larr;RTEMP, SAMASK[22], GOTO[RMWARG,ALU&gt;=0]; *EXIT?	DECAC, CALL[RHARG]; *P&larr;FRAME WORD, Q&larr;777777	Q&larr;RTEMP1&larr;P AND NOT Q, BAMASK[22]; *Q&larr;RTEMP1&larr;NAME, P&larr;VALUE	MDR&larr;P, QQ RCY [22], BAMASK[22], Q&larr;200R; *P&larr;VCELL PTR	STEMP&larr;MDR, P AND NOT Q; *STEMP&larr;FRAME VALUE, TEST LOCALVAR	MAPVA&larr;P, Q&larr;-1L, CALL[RMWHARG,ALU#0]; *CALL IFF NOT LOCALVAR*VCELL&larr;ORIGINAL L.H.,,FRAME R.H., WRESTART IS NOOP AND ALU=0 IF LOCALVAR	MDR&larr;(P AND NOT Q) U (STEMP), WRESTART, Q&larr;RTEMP, CALL[RETN];*HAVE VALUE FOR AC UPDATE IN Q, ALU=0 IFF LOCALVAR*IF NOT LOCALVAR, HAVE VCELL CONTENTS IN P	LAC&larr;MAPVA&larr;Q, SAMASK[22], Q&larr;RTEMP1, GOTO[REWIND,ALU=0];*WRITE ORIGINAL L.H.,VCELL R.H. BACK INTO FRAME.  NOTE THAT IF*A MEMORY TRAP OCCURS, WRITE WILL BE COMPLETED.	MDR&larr;P OR Q, WREF, P&larr;LAC, Q&larr;777777R, GOTO[ILLIO,G=1];	P&larr;(REFADR&larr;P AND Q) U (BLTWLE), GOTO[REWIND,G=0];	LEFADR&larr;P, Q&larr;WMQ, CALL[LOADMAP];	WREF, GOTO[REWIND]; *ANOTHER MAP FAULT IMPOSSIBLE%PDP-10 INSTRUCTION FOR RETURN TO BLISP FUNCTION EQUIVALENT TOMOVE AC,E; MOVE PC,E+1; SUB CP,[2,,2]ALWAYS USED AS BFRET CBS,-1(CP)HAVE [E] IN P, LAC IN Q AT ENTRYI = 7TIMING = M+2R+18%BFRET:	LAC&larr;P, P&larr;REFADR;	MAPVA&larr;P&larr;P+1, SAMASK[22], CALL[RHARG];	MDR&larr;P, P&larr;CP, Q&larr;2 000002R, SETF[MD2];	CP&larr;P-Q, SAMASK[0], Q&larr;MDR, GOTO[LENTER];%PDP-10 INSTRUCTION FOR LISP FUNCTION CALL EQUIVALENT TO	MOVEI AC,1(CP); EXCH AC,CF; HRLM CP,3(AC)	PUSH CP,VP; PUSH CP,AC; PUSH CP,AC; XCT EALWAYS USED AS CALLFN 3,0(CP)HAVE E IN RTEMP HERE (LEFT BY GOSTAT)I = 10 HERE + "PDPCPP" ROUTINE EARLIERTIMING = M+2R+44%CALLFN:	MAPVA&larr;P&larr;CF, ACFS, CALL[RMWHARG];	LAC&larr;P, WRESTART, SETF[BIS];	P&larr;CP, BAMASK[22], Q&larr;20000 000000S, INHINT;	MDR&larr;P+1, P&larr;CBS, CALL[ADVSTT]; *SET STATE=2ST2:	P&larr;LAC, Q&larr;3S, CALL[RMWHPPQ]; *HRLM CP,3(AC)	P&larr;P AND Q, Q&larr;CP, WRESTART, CALL[POQL22];	MDR&larr;P OR Q, P&larr;VP, SETF[K], CALL[PDPCPP]; *PUSH CP,VPST3:	P&larr;LAC, SETF[K], CALL[PDPCPP]; *PUSH CP,ACST4:	P&larr;LAC, SETF[K], CALL[PDPCPP]; *PUSH CP,ACST5:	P&larr;RTEMP, AC&larr;NULL, SETSF[K];	MAPVA&larr;P, GOTO[XCT]; *XCT E*B4TAB DEFINED IN PISYS*ST DISPATCH TABLETARGET[XSLC];SM[XSLC,415]; E1[ST0], E2[ST1], E3[SCRASH];SM[XSLC,435]; E1[ST2], E2[ST3], E3[SCRASH];SM[XSLC,455]; E1[ST4], E2[ST5], E3[SCRASH];SM[XSLC,475]; E1[ST6], E2[ST7], E3[BINDR];SM[XSLC,515]; E1[ST8], E2[ST9], E3[SCRASH];SM[XSLC,535]; E1[STA], E2[STB], E3[SCRASH];SM[XSLC,555]; E1[STC], E2[MILLEG], E3[SCRASH];SM[XSLC,575]; E1[MILLEG], E2[MILLEG], E3[SCRASH];*NOTE:  DIS DOES GNBYT, DI DOES NOT BEFORE TRIPLE DISPATCH*PDP-10 OPCODESDIS[107,BL,BL6,SCRASH];	*PDP-10 INSTRUCTION BLISPDM[DLC,110]; REPEAT[4,DLC[E1[UUOM] E2[60] E3[4061]]]; *ILLEGAL INSTS.DI[114,RARG,GOSTAT,RETFR];	*RETFR (ALWAYS USED AS RETFR 3,0(CP))DI[115,UPSHJ,PUSHJ,SCRASH];	*UPSHJDI[116,LDTYPE,PAQA,SCRASH];	*LDTDI[117,BTLU,ESKIP,SCRASH];	*BTLUDI[120,RARG,BFRET,SCRASH];	*BFRETDI[121,GOSTAT,CALLFN,SCRASH];	*CALLFNDM[DLC,122]; REPEAT[6,DLC[E1[UUOM] E2[60] E3[4061]]]; *ILLEGAL INSTS.DI[247,CHASE,REMAPPC,SCRASH];	*CHASEDI[257,REWIND,PXQM,SCRASH];	*REWIND</pre>
  </body>
</html>
