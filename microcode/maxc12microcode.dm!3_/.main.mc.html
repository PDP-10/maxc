<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12microcode.dm!3>main.mc</title>
  </head>
  <body>
    <pre>
ER[MAIN];*I = 212+2 FOR MAXC2%THIS FILE CONTAINS THE EMULATOR'S MAIN LOOP, PREPARATION ROUTINES,AND COMPLETION ROUTINES.  IT CONTAINS REFERENCES TO VARIABLES AND TAGSDEFINED IN "MAP" AND "PISYS" WHICH ARE ASSEMBLED AHEAD OF THIS FILE.THE INSTRUCTION-FETCH LOOP CONTAINS A BRANCH CONDITIONED ON THE "LOGF" FLAGTO A SPECIAL PROGRAM.  THIS PROGRAM CAN BE FILLED OUT BY  "LOGI", "BRKI",OR "TRACEI" (NORMAL = "LOGI").  TIMING COMMENTS APPLY WHEN "LOGF" = 0.THE ENTRY POINT TO THE MAIN LOOP IS CALLED "REMAPPC".  OPCODES MAYREENTER THE MAIN LOOP IN ANY OF THE FOLLOWING WAYS:	P&larr;MAPVA&larr;PC, Q&larr;1R, ACFS, GOTO[REMAP1]; *= "ENDM"	RETURN;		*IF THE STACK HAS BEEN POPPED ENOUGH TIMES	GOTO[REMAPPC];COMPLETION ROUTINES WHICH CAN SHOULD FINISH WITH "ENDM" (OR AN EQUIVALENTFOR JUMPS AND SKIPS) SINCE THAT SAVES ONE CYCLE."PC" IS ADVANCED IN THE MAIN LOOP (UNLIKE THE PDP-10) SO "LOADMAP" MUSTDECREMENT "PC" BEFORE TRAPPING EXCEPT ON PURE WRITES. "PI" DECREMENTS "PC".IT IS NECESSARY, BEFORE ENTERING THE INDIRECT ADDRESS LOOP, LOADING THEMAP, OR TRIPLE-DISPATCHING, TO CLEAR ALL FOUR XCTN FLAGS, J AND PICYCLE.THE MAIN LOOP MUST ALSO CHECK FOR INTERRUPT CONDITIONS.  ALL OFTHESE ARE REPRESENTED BY 1 BITS IN F SELECTED BY "INTCONDH."TIMING:	4 CYCLES + 1R	+4 CYCLES + 1R / INDIRECT	+1 CYCLE IF THE INSTRUCTION DOES NOT FINISH WITH "ENDM"DEEPEST STACK DEPTH = 4 DURING INDIRECT LOOP		= 7 DURING INDIRECT LOOP MAP LOADING		= 3 AT MAIN LOOP EXITNOTE:	R = 2 FOR AC INSTRUCTION FETCHES OR 0 FOR INDIRECT READS.  OTHERWISE,	IT IS THE NO. OF INSTRUCTIONS WHICH ELAPSE AFTER THE ONE INITIATING	THE READ BUT NOT INCLUDING THE ONE WHICH READS MDR."TFLAGS" CONTAINS 1'S FOR XCT0, XCT1, XCT2, XCT3, J, AND PICYCLE.IN THE SPECIAL VERSION OF THE MAIN LOOP USED BY TRAP AND PICYCLES,"TFLAGSPI" IS USED INSTEAD.  IT DOES NOT CLEAR J (J=UM) NOR PICYCLE (=1),AND DOES CLEAR UM (TO XCT THE INSTRUCTION IN MONITOR MODE).THE MAIN LOOP ZEROES "PC" LEFT HALF BEFORE CHECKING PI CONDITIONS ORCALLING "LOADMAP".  THIS MEANS THAT DURING EXECUTION OF AN INSTRUCTION,"PC" CAN ALWAYS BE MERGED WITH THE FLAGS WITHOUT CLEARING ITS LEFT HALFFIRST, AND INSTRUCTIONS WHICH CHANGE "PC" DON'T HAVE TO CLEAR THE LEFT HALFBEFORE REENTERING THE MAIN LOOP.  NOTE THAT THE TRAP CODE FOR "LOADMAP"NECESSARILY CLEARS THE LEFT HALF OF "PC".  FINALLY, NOTE THAT "PC" ISINVALID WHEN ENTRY IS MADE AT "REMAP1" SO THE NEW VALUE COMPUTED FROM PMUST BE SAVED BEFORE GOING TO "LOADMAP" OR "PI".  AT EXIT FROM THE MAINLOOP, "INSTR" CONTAINS THE INSTRUCTION, P THE EFFECTIVE ADDRESS E, Q THE AC,AC POINTS TO THE AC, G=1 IFF E POINTS TO AN AC K=0 IF NO INDIRECTIONELSE K=XCT3 (FOR BYTE INDIRECTION), J=0 (FOR UM COMPUTATION BY INTERRUPTINSTRUCTIONS), PC HAS BEEN INCREMENTED, AND ICTR HAS BEEN INCREMENTEDONCE PLUS ONCE PER INDIRECT ADDRESS.  "OLDPC" ALSO CONTAINS THE PC."REFADR" ALSO CONTAINS E WITH GARBAGE IN THE L.H.I = 24%MC[XCTN,XCTN];MC[TFLAGS,J,PICYCLE,XCTN];MC[XCT3&amp;K,XCT3,K];RVN[INSTR];*INTCONDH IS DEFINED IN PISYSTARGET[ILC];*SUBROUTINES TO HANDLE THE MONITOR'S FORCED REFERENCES TO USER AC'SRMWAMDR: P&larr;MAPVA&larr;(MDR) U (ACBASE), A1;	RMWREFDXK, INHINT, RETURN;RAMDR:	P&larr;MAPVA&larr;(MDR) U (ACBASE), A1;RREFX:	RREFDXK, RETURN;M[ENDM,(P&larr;MAPVA&larr;PC, Q&larr;1R, ACFS, GOTO[REMAP1,#1])];%SET UP TRIPLE DISPATCH.  CALL INDLP ONLY IF INDIRECT BIT IN INSTRUCTION=1 (BOTH G AND H =0) AND D[0]=1 (B[0]=0 SETS G=1).  NOTE THAT H REMEMBERSTHE SETTING OF THE INDIRECT BIT WHEN D[0]=0 FORCES A MAIN LOOP EXIT.%REMAPE:	NPC&larr;STACK&larr;D, Q&larr;LINDX, INSTR&larr;P, GOTO[LOGI,K=1];	MAPVA&larr;REFADR&larr;P&larr;P+Q, SAMASK[22], Q&larr;LAC, CALL[INDLP,G=0];INDLP1:	RTEMP&larr;P, Q&larr;LINDX, GOTO[PI,H=1]; *RTEMP HOLDS LAST MEM REF FOR JRST@*ALSO ENTER HERE FOR BYTE INDIRECT SEQUENCES (K&larr;XCT3 FOR BYTE STUFF)BINDE:	MAPVA&larr;REFADR&larr;P&larr;P+Q, BAMASK[22], Q&larr;LAC, RETURN[G=1], SETSF[XCT3&amp;K];*REENTER AT "INDLP" FOR JRST INDIRECT SEQUENCESINDLP:	IREF, MDR&larr;X, Q&larr;LX, REFADR&larr;P, GOTO[INDLP2,G=0];	ISPLIT&larr;P&larr;Q, SETSF[INTCONDH], GOTO[INDLP1,H=0];	P&larr;MAPVA&larr;(MDR) U (ACBASE), A1, CALL[RREFX];*INDIRECTING THROUGH AC DOESN'T INCREMENT ICTRINDLP2:	Q&larr;(P) U (ILE), P&larr;ICTR, GOTO[.+2,G=1];	ICTR&larr;P+1, P&larr;ISPLIT&larr;MDR, SETSF[INTCONDH], GOTO[INDLP1];	LEFADR&larr;Q, Q&larr;RMQ, CALL[LOADMAP];	GOTO[INDLP];XMAPL:	REFADR&larr;P&larr;Q, BAMASK[22], Q&larr;XLE;	LEFADR&larr;P OR Q, Q&larr;XMQ, CALL[LOADMAP];*ENTRY HERE WITH PC IN P AFTER MAPVA&larr;PC, 1 IN QREMAP1:	XREF, Q&larr;P+Q, P&larr;777777R, SETSF[INTCONDH], DGOTO[XRAC,G=1];	OLDPC&larr;P&larr;Q&larr;P AND Q, CLEARF[TFLAGS], GOTO[PI1,H=1];XR2:	PC&larr;Q, Q&larr;P-1, P&larr;ICTR, GOTO[XMAPL,G=1];XREMAP:	XSPLIT&larr;P&larr;MDR, ICTR&larr;P+1, SETSF[LOGF&amp;K], CALL[REMAPE];REMAPPC:	ENDM;XJAC:	OLDPC&larr;P&larr;Q&larr;P AND Q;XRAC:	PC&larr;Q, Q&larr;LX, P&larr;ICTR, DGOTO[REMAPPC];	SETSF[LOGF&amp;K], P&larr;XSPLIT&larr;Q, ICTR&larr;P+1, CALL[REMAPE];XJMP:	XREF, Q&larr;1R, SETSF[INTCONDH], DGOTO[XJAC,G=1];	Q&larr;P+Q, P&larr;777777R, CLEARF[TFLAGS], DGOTO[PI1,H=1];	OLDPC&larr;P&larr;Q&larr;P AND Q, GOTO[XR2,H=0];%NPC HOLDS 1ST INSTRUCTION DISPATCH.  INSTRUCTIONS BELOW ARE OPTIONALCONTINUATIONS FROM "REMAPE".I = 3%LOGI:	RMW&larr;(LOGT) U (Y), INHINT, CALL[LOGOP];%THE "LOGF" FLAG CAUSES THE OPCODE TO BE COUNTED IN THE TABLE POINTEDTO BY "LOGT" WHICH MUST BEGIN AT A 1000-WORD BOUNDARY.  "BLT" LOGGINGISN'T HANDLED CORRECTLY BY THIS, NOR IS INDIRECTION.%LOGOP:	P, CALL[PMDR];BRKRET:	MDR&larr;P+1, WRESTART, P&larr;INSTR, Q&larr;LINDX, GOTO[BINDE];%THE "LOGF" FLAG CAUSES THE BREAK AND SINGLE-STEP FEATURE TO BE INVOKED.SINGLE-STEP IF "LOGT" = 0, ELSE COMPARE "LOGT" TO "PC" AND BREAK IF THEYARE EQUAL.  CONTINUING FROM THE BREAK WORKS FINE.BRKI:	Q&larr;LOGT, CALL[BRKTST];BRKTST:	AQ, P&larr;PC;	P&larr;P-1, FRZBALUBC, DGOTO[BRKRET,ALU=0];	P#Q, SETSF[K], CALL[SPUNT,ALU=0];	CALL[SPUNT,ALU=0];%%ROUTINES TO SETUP THE ARGUMENTS FOR A TASK IN A STANDARD FORM.MOST PDP-10 INSTRUCTIONS COME IN GROUPS, EACH ELEMENT OF WHICHPERFORMS THE SAME CONCEPTUAL TASK BUT GETS ITS ARGUMENTS IN ADIFFERENT WAY OR STORES AWAY ITS RESULTS IN A DIFFERENT WAY.THE MAIN LOOP LEAVES E IN P AND AC IN Q.  THIS IS THE STANDARD FORMFOR IMMEDIATE INSTRUCTIONS.  NON-IMMEDIATE INSTRUCTIONS USUALLYLEAVE [E] IN P AND AC IN Q, ALSO.RARG AND RMWARG ARE CALLED AFTER MAPVA&larr;P&larr;E.  THEY LEAVE MEMORY DATA [E]IN P AND THE AC IN Q.  WHEN THE FETCH IS NOT FROM AN AC, THE MEMORYDATA IS ALSO LEFT IN WDATA.I = 13%RMAPL:	LEFADR&larr;P, Q&larr;RMQ, CALL[LOADMAP];RARG:	RREF, Q&larr;REFADR&larr;P, GOTO[.+3,G=0], P&larr;LX;	Q&larr;LAC, RETURN[H=0], STEMP&larr;Q;	MAPVA&larr;Q&larr;(X) U (ACBASE), A1, CALL[RREFX];  *FOR THE AC TEST MUST DO A1	GOTO[RMAPL,G=1], P&larr;(RLE) U (Q);TPMDR:	STEMP&larr;Q;	*FOR MULTIPLY AND ANY OTHER INSTRUCTIONS			*WHICH DO A READ FOLLOWED BY A WRITE			*RATHER THAN A READ-MODIFY-WRITE REFERENCERARG1:	WDATA&larr;P&larr;MDR, Q&larr;LAC, RETURN;RW0:	P&larr;(RMWLE) U (Q), GOTO[RARG1,G=0];	LEFADR&larr;P, Q&larr;RMWMQ, CALL[LOADMAP];RMWARG:	RMWREF, Q&larr;REFADR&larr;P, P&larr;LX, GOTO[RW0,G=0], INHINT;	Q&larr;LAC, RETURN[H=0];	MAPVA&larr;Q&larr;(X) U (ACBASE), A1;	RMWREFDXK, INHINT, GOTO[RW0];%THOSE SUBROUTINES WHICH CAN OVERLAP WORK WITH MEMORY FETCH TIMEGENERALLY LEAVE THE MEMORY ARGUMENT IN MDR.  RTOMDR RETURNS AC IN P,1 000001 IN Q.  USED BY PUSH, DATAO PII = 8%RM0:	P&larr;LAC, Q&larr;(2 000002R) RSH 1, RETURN[G=0], STEMP&larr;Q;	P&larr;STEMP, DGOTO[RTOMDR];	Q&larr;RMQ, LEFADR&larr;P, CALL[LOADMAP];*USED BY POP AND POPJPOPX:	RTEMP&larr;P, P&larr;Q, SETF[J], CALL[JUMPA];RTOMDR:	RREF, Q&larr;(REFADR&larr;P) U (RLE), P&larr;LX, GOTO[RM0,G=0];	MDR&larr;P, Q&larr;(2 000002R) RSH 1, RETURN[H=0], P&larr;LAC;	MAPVA&larr;Q&larr;(X) U (ACBASE), A1;	RREFDXK, Q&larr;(Q) U (RLE), GOTO[RM0];%IQARG, RQARG, AND RMWQARG REVERSE AC AND E (OR [E]) AS LEFT BYMAIN LOOP, RARG, AND RMWARG, RESPECTIVELY.I = 13%*USED BY SUBI, HRLI, HRLZI, HRLOI, HRLEI, HLROIIQARG:	Q&larr;P, P&larr;LAC, RETURN;*USED BY SUB, HRL,HRLZ, HLRZ, HLRO, HLR, HRLE, HRLO, KGORQL:	LEFADR&larr;P, Q&larr;RMQ, CALL[LOADMAP];RQARG:	RREF, REFADR&larr;P, GOTO[.+3,G=0], Q&larr;LX;	P&larr;LAC, RETURN[H=0];	MAPVA&larr;P&larr;(X) U (ACBASE), A1, CALL[RREFX];	GOTO[RQL,G=1], P&larr;(RLE) U (P);	WDATA&larr;Q&larr;MDR, P&larr;LAC, RETURN;*USED BY SUBM, SUBB, HLROS, HLRZS, HRLES, HRLOS, HRLZS, MOVSSRWQ0:	P&larr;(RMWLE) U (P), GOTO[.-1,G=0];	LEFADR&larr;P, Q&larr;RMWMQ, CALL[LOADMAP];RMWQARG: RMWREF, REFADR&larr;P, Q&larr;LX, GOTO[RWQ0,G=0], INHINT;	P&larr;LAC, RETURN[H=0];	MAPVA&larr;P&larr;(X) U (ACBASE), A1;	RMWREFDXK, INHINT, GOTO[RWQ0];%SRARG AND ESWAP ARE THE SAME AS RARG AND THE MAIN LOOP EXCEPT THATTHEY RCY THE MEMORY ARGUMENT 22 BEFORE RETURNING.  THESE ARE USED BY THETEST-AND-SET AND MOVS INSTRUCTIONS.I = 8%ESWAP:	Q&larr;P, SETSF[H];SRAC:	PQ RCY [22], Q&larr;LAC, RETURN[H=0];	MAPVA&larr;P&larr;(X) U (ACBASE), A1, CALL[RREFX];	GOTO[SRARG0,G=0], Q&larr;RLE;	LEFADR&larr;P OR Q, Q&larr;RMQ, CALL[LOADMAP];SRARG:	RREF, GOTO[SRAC,G=1], P&larr;Q&larr;LX, REFADR&larr;P;	GOTO[.-2,G=1], P&larr;REFADR, Q&larr;RLE;SRARG0:	P&larr;Q&larr;MDR, CLEARF[H], GOTO[SRAC];%ROUTINES TO SETUP THE ARGUMENTS FOR THE VARIOUS HALF-WORD INSTRUCTIONS.THESE ALL LEAVE THE INDICATED ARGUMENT IN P AND 777777 IN Q, WITHREFADR HOLDING E.***ELIMINATE AT THE COST OF 1 CYCLE BY USING "RARG" FOLLOWED BY "EHARG"I = 15%*USED BY HLL, HLLZ, HLLO, HLLE, HRR, HRRZ, HRRORHL:	LEFADR&larr;P, Q&larr;RMQ, CALL[LOADMAP];RHARG:	RREF, REFADR&larr;P, GOTO[.+3,G=0];	P&larr;LX, Q&larr;777777R, RETURN[H=0];	MAPVA&larr;P&larr;(X) U (ACBASE), A1, CALL[RREFX];	GOTO[RHL,G=1], P&larr;(P) U (RLE);	WDATA&larr;P&larr;MDR, Q&larr;777777R, RETURN;*USED BY HLLM , HRLM, HRLS, HLLZSRWH0:	GOTO[.-1,G=0], P&larr;(P) U (RMWLE);	LEFADR&larr;P, Q&larr;RMWMQ, CALL[LOADMAP];RMWHARG: RMWREF, INHINT, REFADR&larr;P, GOTO[RWH0,G=0];	P&larr;LX, Q&larr;777777R, RETURN[H=0];	MAPVA&larr;P&larr;(X) U (ACBASE), A1;	RMWREFDXK, INHINT, GOTO[RWH0];EHARG:	Q&larr;777777R, RETURN;*USED BY HLLI, HLLZM, HLLOM, HLLEM, HLRI, HRROMACHARG: REFADR&larr;P, P&larr;LAC, Q&larr;777777S, RETURN;*FREQUENT USAGEQ22H:	REFADR&larr;P, QQ RCY [22], INHINT, Q&larr;777777S, RETURN;%FINISHING ROUTINESACCEPT DATA IN Q, WRITE ADDRESS IN P.MOVEM GOES TO WREFQ DIRECTLY FROM THE MAIN LOOP SO IT IS IMPORTANT FOR THEINSTRUCTION AT WQTOP TO DO NO MORE THAN THE EXIT INSTRUCTION OF THEMAIN LOOP.I = 42%*"WQTOP" ALSO EXECUTED WITH A DGOTO PENDING AT IOD+10WQTOP:	MAPVA&larr;P&larr;P, SAMASK[22];WREFQ:	WREF, REFADR&larr;P, MDR&larr;Q, GOTO[QTOLX,G=1];WQTOP0:	P&larr;(P) U (WLE), GOTO[REMAPPC,G=0];	Q&larr;WMQ, CALL[LOADMAP], LEFADR&larr;P;	WREF, Q&larr;MDR&larr;WDATA, GOTO[WQTOP0,G=0];QTOLX:	GOTO[QTOMAC,H=0], P&larr;(X) U (ACBASE);	MAPVA&larr;P&larr;(P) U (WLE);	WREFDXK, MDR&larr;Q, GOTO[WQTOP0];%"WREFP" WRITES DATA IN P TO ADDRESS IN REFADR.MAPVA&larr;WRITE ADDRESS MUST ALREADY HAVE BEEN DONE.  USED BY MOVSM.%HLREM:	REFADR&larr;P, P&larr;LAC, B&larr;Q;HLREM1:	PQ RCY [22], SAMASK[22], Q&larr;777777R, GOTO[WPONQM,B&lt;0];WREFP:	WREF, MDR&larr;Q&larr;P, GOTO[QTOLX,G=1], P&larr;REFADR;	GOTO[WQTOP0];*FINISHING ROUTINE TO WRITE DATA ALREADY IN MDR TO ADDRESS IN P*MAPVA&larr;P ALREADY DONE.  ENTERED FROM HLLEM, POP, LMOVEMWTOP1:	WREF, REFADR&larr;P, GOTO[QTOLX,G=1], Q&larr;MDR;	GOTO[WQTOP0];MAGQTOP: GOTO[WREFQ,ALU&gt;=0]; *USED BY MOVMMNEGQTOP: REFADR&larr;P, P&larr;1S, WREF, DGOTO[QTOLX,G=1], INHINT;  *USED BY MOVNM*REMEMBER THAT SETOVPC01 WON'T WORK ON P+1	MDR&larr;Q&larr;P-Q-1, SETOVPC01, P&larr;REFADR;	GOTO[WQTOP0];*SAVE 1 UINST PER ROUTINE BELOW AT COST OF 1 CYCLE TIMEWPAQM:	WREF, P&larr;REFADR, MDR&larr;Q&larr;P AND Q, GOTO[QTOLX,G=1];	GOTO[WQTOP0];WPANQM:	WREF, MDR&larr;Q&larr;P AND NOT Q, P&larr;REFADR, GOTO[QTOLX,G=1];	GOTO[WQTOP0];WPOQM:	WREF, MDR&larr;Q&larr;P OR Q, P&larr;REFADR, GOTO[QTOLX,G=1];	GOTO[WQTOP0];WPONQM:	WREF, MDR&larr;Q&larr;P OR NOT Q, P&larr;REFADR, GOTO[QTOLX,G=1];	GOTO[WQTOP0];NQB:	WREF, MDR&larr;LAC&larr;Q&larr;NOT Q, GOTO[QTOLX,G=1];	REFADR&larr;P, GOTO[WQTOP0];NQM:	WREF, MDR&larr;Q&larr;NOT Q, GOTO[QTOLX,G=1];	REFADR&larr;P, GOTO[WQTOP0];SETZM:	WREF, MDR&larr;Q&larr;A0, GOTO[QTOLX,G=1];	REFADR&larr;P, GOTO[WQTOP0];SETZB:	WREF, MDR&larr;Q&larr;LAC&larr;A0, GOTO[QTOLX,G=1];	REFADR&larr;P, GOTO[WQTOP0];SETOM:	WREF, MDR&larr;Q&larr;A1, GOTO[QTOLX,G=1];	REFADR&larr;P, GOTO[WQTOP0];SETOB:	WREF, MDR&larr;LAC&larr;Q&larr;A1, GOTO[QTOLX,G=1];	REFADR&larr;P, GOTO[WQTOP0];HLLEM:	MDR&larr;P AND NOT Q, DGOTO[WTOP1];	Q&larr;P OR Q, GOTO[WREFQ,ALU&lt;0], P&larr;REFADR;HRREM:	REFADR&larr;P, QQ RCY [22];	B&larr;Q&larr;P, GOTO[HLREM1];%FINISHING ROUTINES WHICH LEAVE RESULT IN ACI = 25%MAGPTOAC: LAC&larr;P, DGOTO[REMAPPC];MINP:	P&larr;NOT P, Q&larr;1S, GOTO[.+1,ALU&lt;0]; *USED BY MOVN, MOVNIP+QA:	LAC&larr;P+Q, SETOVPC01, ENDM; *USED BY DFN, ADD, ADDIPIRDX:	Q&larr;200000S, GOTO[POQA,K=1]; *USED BY PIREAD JMCPTOAC:	LAC&larr;P, ENDM;*QTOAC: LAC&larr;Q, ENDM;  *IN "ARITH"*SETZ:  LAC&larr;A0, ENDM; *IN "ARITH"SETO:	LAC&larr;A1, ENDM;NPAQA:	LAC&larr;NOT P AND Q, ENDM;PXQA:	LAC&larr;P#Q, ENDM;NPANQA:	LAC&larr;NOT P AND NOT Q, ENDM;PEQA:	LAC&larr;P=Q, ENDM;NQA:	LAC&larr;NOT Q, ENDM;NPA:	LAC&larr;NOT P, ENDM;NPOQA:	LAC&larr;NOT P OR Q, ENDM;NPONQA:	LAC&larr;NOT P OR NOT Q, ENDM;PAQA:	LAC&larr;P AND Q, ENDM;PANQA:	LAC&larr;P AND NOT Q, ENDM;*POQA:	LAC&larr;P OR Q, ENDM; *IN "BS"PONQA:	LAC&larr;P OR NOT Q, ENDM;HLLA:	Q&larr;P AND NOT Q, P&larr;LAC, SAMASK[22], GOTO[POQA];HLLEA:	LAC&larr;P AND NOT Q, DGOTO[QTOAC];	Q&larr;P OR Q, GOTO[REMAPPC,ALU&gt;=0];HRRA:	MDR&larr;P AND Q, P&larr;LAC;	P&larr;(MDR) U (P AND NOT Q), GOTO[PTOAC];HRREA:	Q&larr;400000S, POP;	P AND Q, Q&larr;777777R, DGOTO[PONQA];	LAC&larr;P AND Q, RETURN[ALU=0];HLREA:	P, PQ RCY [22], SAMASK[22], Q&larr;777777R, DGOTO[PONQA], POP;	LAC&larr;P AND Q, RETURN[ALU&gt;=0];%FINISHING ROUTINES FOR RMW INSTRUCTIONS.  G MUST NOT HAVE CHANGEDDURING MODIFY.  HENCE G=0 ON NORMAL AND ACBASE REFERENCES ANDG=1 ONLY FOR AC REFERENCES.I = 62%PTOMAC:	LX&larr;P, ENDM;QTOMCHK: GOTO[REMAPPC,G=0];QTOMAC:	LX&larr;Q, ENDM;QTOM:	MDR&larr;Q, WRESTART, GOTO[QTOMCHK];PTOM:	MDR&larr;Q&larr;P, WRESTART, GOTO[QTOMCHK];PTOB:	LAC&larr;Q&larr;MDR&larr;P, WRESTART, GOTO[QTOMCHK];PTOS:	LACS&larr;Q&larr;MDR&larr;P, WRESTART, GOTO[QTOMCHK];PAQS:	LACS&larr;MDR&larr;Q&larr;P AND Q, WRESTART, GOTO[QTOMCHK];POQS:	LACS&larr;MDR&larr;Q&larr;P OR Q, WRESTART, GOTO[QTOMCHK];PONQS:	LACS&larr;MDR&larr;Q&larr;P OR NOT Q, WRESTART, GOTO[QTOMCHK];PANQS:	LACS&larr;MDR&larr;Q&larr;P AND NOT Q, WRESTART, GOTO[QTOMCHK];PAQM:	MDR&larr;Q&larr;P AND Q, WRESTART, GOTO[QTOMCHK];PAQB:	LAC&larr;MDR&larr;Q&larr;P AND Q, WRESTART, GOTO[QTOMCHK];PANQM:	MDR&larr;Q&larr;P AND NOT Q, WRESTART, GOTO[QTOMCHK];PANQB:	LAC&larr;MDR&larr;Q&larr;P AND NOT Q, WRESTART, GOTO[QTOMCHK];NPAQM:	MDR&larr;Q&larr;NOT P AND Q, WRESTART, GOTO[QTOMCHK];NPAQB:	LAC&larr;MDR&larr;Q&larr;NOT P AND Q, WRESTART, GOTO[QTOMCHK];PXQM:	MDR&larr;Q&larr;P#Q, WRESTART, GOTO[QTOMCHK];PXQB:	LAC&larr;MDR&larr;Q&larr;P#Q, WRESTART, GOTO[QTOMCHK];POQM:	MDR&larr;Q&larr;P OR Q, WRESTART, GOTO[QTOMCHK];POQB:	LAC&larr;MDR&larr;Q&larr;P OR Q, WRESTART, GOTO[QTOMCHK];NPANQM: MDR&larr;Q&larr;NOT P AND NOT Q, WRESTART, GOTO[QTOMCHK];NPANQB: LAC&larr;Q&larr;MDR&larr;NOT P AND NOT Q, WRESTART, GOTO[QTOMCHK];PEQM:	MDR&larr;Q&larr;P=Q, WRESTART, GOTO[QTOMCHK];PEQB:	LAC&larr;MDR&larr;Q&larr;P=Q, WRESTART, GOTO[QTOMCHK];PONQM:	MDR&larr;Q&larr;P OR NOT Q, WRESTART, GOTO[QTOMCHK];PONQB:	LAC&larr;Q&larr;MDR&larr;P OR NOT Q, WRESTART, GOTO[QTOMCHK];NPM:	MDR&larr;Q&larr;NOT P, WRESTART, GOTO[QTOMCHK];NPB:	LAC&larr;Q&larr;MDR&larr;NOT P, WRESTART, GOTO[QTOMCHK];NPOQM:	MDR&larr;Q&larr;NOT P OR Q, WRESTART, GOTO[QTOMCHK];NPOQB:	LAC&larr;MDR&larr;Q&larr;NOT P OR Q, WRESTART, GOTO[QTOMCHK];NPONQM:	MDR&larr;Q&larr;NOT P OR NOT Q, WRESTART, GOTO[QTOMCHK];NPONQB:	LAC&larr;MDR&larr;Q&larr;NOT P OR NOT Q, WRESTART, GOTO[QTOMCHK];*! MAXC1 ONLYHLLM:	WRESTART, MDR&larr;P AND Q, P&larr;LAC, DGOTO[QTOMAC];	Q&larr;(MDR) U (P AND NOT Q), INHINT, GOTO[WABS,G=0]; **SHORT PATH PROBLEMHRLM:	MDR&larr;P AND Q, Q&larr;LAC, DGOTO[.-1]; **SHORT PATH PROBLEM	REFADR&larr;P, QQ RCY [22], WRESTART, Q&larr;777777S, DGOTO[QTOMAC];*EXTRA WRESTART SHOULDN'T HURTHLRM:	MDR&larr;P AND NOT Q, P&larr;Q&larr;LAC, WRESTART;	PQ RCY [22], SAMASK[22], Q&larr;MDR, INHINT, GOTO[POQM];HRRM:	WRESTART, MDR&larr;P AND NOT Q, P&larr;LAC, DGOTO[QTOMAC,G=1]; **SHORT PATH PROBLEM	Q&larr;(MDR) U (P AND Q), INHINT, GOTO[WABS,G=0];*!*~ MAXC2 ONLY (READING MDR AFTER WRESTART ILLEGAL ON MAXC2)POQMAC:	LX&larr;P OR Q, ENDM;HLLM:	WRESTART, RTEMP&larr;P AND Q, P&larr;LAC;	P&larr;P AND NOT Q, Q&larr;RTEMP, INHINT, GOTO[POQMAC,G=1];POQMM:	MDR&larr;P OR Q, GOTO[REMAPPC];HRLM:	RTEMP&larr;P AND Q, Q&larr;LAC, DGOTO[.-2];	REFADR&larr;P, QQ RCY [22], WRESTART, Q&larr;777777S;HLRM:	RTEMP&larr;P AND NOT Q, P&larr;Q&larr;LAC, WRESTART, DGOTO[POQMM];	PQ RCY [22], SAMASK[22], Q&larr;RTEMP, INHINT, GOTO[POQMAC,G=1];HRRM:	WRESTART, RTEMP&larr;P AND NOT Q, P&larr;LAC, DGOTO[POQMM];	P&larr;P AND Q, Q&larr;RTEMP, INHINT, GOTO[POQMAC,G=1];*~HRLS:	P&larr;Q&larr;P AND Q, POP, WRESTART;	PQ RCY [22], INHINT, DGOTO[REMAPPC];	MDR&larr;LACS&larr;Q&larr;P OR Q, GOTO[QTOMAC,G=1];HLRS:	P&larr;Q&larr;P AND NOT Q, WRESTART, POP, GOTO[.-2];HLLES:	WRESTART, LACS&larr;MDR&larr;P AND NOT Q, GOTO[HLLESAC,G=1];	INHINT, RETURN[ALU&gt;=0];	LACS&larr;MDR&larr;P OR Q, RETURN;HLLESAC: LX&larr;P AND NOT Q, RETURN[ALU&gt;=0];	LACS&larr;Q&larr;P OR Q, GOTO[QTOMAC];HLRES:	P, PQ RCY [22], Q&larr;777777R, WRESTART, GOTO[HLRESAC,G=1];	LACS&larr;MDR&larr;P AND Q, INHINT, RETURN[ALU&gt;=0];	LACS&larr;MDR&larr;P OR NOT Q, RETURN;HLRESAC: LACS&larr;P&larr;P AND Q, GOTO[PTOMAC,ALU&gt;=0];	LACS&larr;Q&larr;P OR NOT Q, GOTO[QTOMAC];*~ MAXC2 ONLY (EXTRA WRESTART IS NO GOOD ON MAXC2)MAGPTOS: LACS&larr;MDR&larr;P, WRESTART, GOTO[MAGPTOSAC,G=1];	P&larr;NOT P, Q&larr;1S, INHINT, GOTO[REMAPPC,ALU&gt;=0];	LACS&larr;MDR&larr;Q&larr;P+Q, SETOVPC01, GOTO[REMAPPC];MAGPTOSAC: NOT(LX&larr;P)Q RCY [0], Q&larr;1R, GOTO[REMAPPC,ALU&gt;=0];	LACS&larr;Q&larr;P+Q, SETOVPC01, GOTO[QTOMAC];NEGPS:	P&larr;NOT P, Q&larr;1R, WRESTART, DGOTO[QTOMAC];	LACS&larr;MDR&larr;Q&larr;P+Q, SETOVPC01, GOTO[REMAPPC,G=0];*~*! MAXC1 ONLYMAGPTOS: LACS&larr;MDR&larr;P, WRESTART, GOTO[MAGPTOSAC,G=1];	P&larr;NOT P, Q&larr;1S, INHINT, GOTO[REMAPPC,ALU&gt;=0];P+QS:	LACS&larr;MDR&larr;Q&larr;P+Q, SETOVPC01, WRESTART, GOTO[QTOMCHK];MAGPTOSAC: LX&larr;P, GOTO[REMAPPC,ALU&gt;=0];NEGPS:	P&larr;NOT P, Q&larr;1S, GOTO[P+QS];*!NOOPR:	P&larr;P, FRZBALUBC;</pre>
  </body>
</html>
