ER[MAP];*I = 147TARGET[ILC];%IN THE MAP CURRENTLY 13-BIT PAGE NUMBERS ARE USED, CONSISTENT WITH THEBBN PAGER.  THIS CAN BE INCREASED TO 15 BITS IF DESIRED.  MAP_ AND MAP4_CAUSE THE 22-BIT ENTRY(IES) SELECTED BY CUM*1000 + Y TO RECEIVE B[22,43].THE ADDRESS LIMIT REGISTER (ALR) CONTAINS THE FIRST ILLEGAL PAGE NO. FORUSER MODE MAP LOADING.  THE THREE-BIT ALR IN 71 FROM WHICH THE PAGERLOADS ITSELF IS CONVERTED TO THE MICROSTORE ALR AS FOLLOWS:1 TO 7 BECOME (((1 TO 7) XOR 7) + 1) LCY 5; 0 BECOMES 1000.THE TIMING FOR MAP LOADING WHEN NO TRAPS OCCUR IS AS FOLLOWS:  UBR   20 CYCLES                 0 CYCLES        PRIVATE  MBASE 19 CYCLES   + 2R + 1W +   4 CYCLES + 1R   SHARED  MBR   20 CYCLES                 3 CYCLES + 1R   INDIRECT                        + 2 CYCLES ON THIRD PAGE TABLEI = 114 FOR MAP LOADINGS = ?DEEPEST STACK DEPTH (INCLUDING CALL) =3AT CALL:  "LEFADR" (HOLDS TRAP STATUS) IS SETUP AS BELOW, E IS IN "REFADR",Q SETUP AS BELOW, MDR HOLDS WRITE DATA, AND Y.CUM POINTS TO MAP ENTRY.THE E IN LEFADR IS THE SAME AS IN REFADR EXCEPT ON FORCED REFERENCES TO USERAC'S FROM MONITOR MODE (IN WHICH CASE E = ACBASE + E).  THE L.H. OF LEFADRCONTAINS APPROPRIATE INDIRECT, READ, WRITE, AND EXECUTE TRAP STATUSBITS WITH THE MONITOR MODE BIT ALWAYS SET AND WITH "PGRPIC" SET IF PC IS NOTTO BE DECREMENTED ON A TRAP.  THE VALUE IN Q CHECKS P.T.E.'S FOR TRAPS.IT CONTAINS USER, MONITOR, AND ACCESS TRAP BITS AND THE APPROPRIATEREAD, WRITE, AND EXECUTE PERMIT AND WRITE-COPY BITS.AT RETURN:  MAR, LEFADR, LPGRT, LPGRT2, LPGRT3, RPGRT, RPGRT2, RPGRT3,THIRDPT AND MONALT ARE CLOBBERED, THE MAP HAS BEEN LOADED, REFADR IS IN P,1 IS IN Q, MAPVA_REFADR, MDR PRESERVED.  LOADMAP RETURNS ONLY IF ITLOADS THE MAP.  OTHERWISE, IT TRAPS AS DESCRIBED BELOW:   LEFADR (MODIFIED BY TRAP CAUSE AND PICYCLE) IS STORED INTO [MBR + TSTAT];   WDATA.WDATAL IS STORED INTO [MBR + TSTAT + 1];   UNMAPPED LOCATION [MLTRAP] IS EXECUTED IN MONITOR MODE.* A PICYCLE MAP LOADING TRAP WILL ALSO SET BIT 40 000000 IN LEFADR.* "CST", "SPT", "MBASE" DO NOT HAVE TO BEGIN AT SPECIAL BOUNDARIES  AS THEY DO FOR THE BBN PAGER BECAUSE ADDRESSES INSIDE THEM  ARE COMPUTED BY AN "ADD" RATHER THAN AN "OR".*PLANS ARE AFOOT TO PUT IN BOUNDS CHECKS FOR SPT INDEX > BOUND AND AGE NO. > BOUND* "ACBASE" CONTAINS 775000 + PSWIT[22,26]*20* ON INDIRECT MAP LOADING, A TRAP OCCURS IF THE INDIRECT PAGE TABLE CST  ENTRY AGE < 100B (BBN PAGER DOESN'T DO THIS).* THE 3-BIT ALR LOADED FROM PSWIT MAY BE CHANGED INTO A 9-BIT QUANTITY%*PARAMETERS REFERRING TO BITS IN PAGE TABLE ENTRIES*PTE[0,1] IS CODED AS FOLLOWS:  0=PRIVATE, 1=SHARED, 2=INDIRECT, 3=ILLEGALMP[RA,2];  *READ ACCESS PERMISSIONMP[WA,3];  *WRITE ACCESS PERMISSIONMP[XA,4];  *EXECUTE ACCESS PERMISSION*MP[UT,10]; *USER TRAP BITMP[WCT,11];*WRITE COPY TRAP BITMP[MT,12]; *TRAP TO MONITOR BITMP[IMT,13];*IMMEDIATE TRAP BIT (WHEN MT=1, IMT=0 TRAPS AFTER LOADING           *A MAP REGISTER AND IMT=1 TRAPS IMMEDIATELY)MP[ACC,14];*ACCESSED BIT (TRAP IF ACC=0)PM[QBITS,1240 000000]; *UT, MT, ACCMC[CBITS,RA,WA,XA,ACC];  *BITS WHICH ARE COMPLEMENTED IN P.T.E.'S BEFORE                         *CHECKING FOR TRAPSMC[MT&ACC,MT,ACC];SM[UT,IP[1000 000000S]];       ***BECAUSE MICRO CAN'T MERGE IDENTICAL CONTS.MC[IMT&ACC,IMT,ACC];MC[MT&IMT&ACC,MT,IMT,ACC];MC[RA&XA,RA,XA];SM[WCT,IP[400 000000S]]; ***SM[WA,IP[40000 000000S]];      ****PARAMETERS REFERRING TO CORE STATUS TABLE ENTRIESSM[DIRTY,IP[400 000000S]];SV[CSTBITS,700000 000000];*PARAMETERS REFERRING TO THE TRAP STATUS WORD (LEFADR)*MP[PGRPARITY,11]; *PARITY ERROR ON CST, PTE, OR SPT REFERENCE*MP[PGRNXM,12];    *NON-EXISTENT MEMORY ERROR ON CST, PTE, OR SPT REF.*MP[PGRKEY,13];    *KEY CYCLE (N.I.)MP[PGRPIC,14];    *PI CYCLE IN PROGRESSMP[PGRIND,15];    *INDIRECT ADDRESS SEQUENCE IN PROGRESSMP[PGRRR,16];     *READ REQUESTMP[PGRWR,17];     *WRITE REQUESTMP[PGRXR,20];     *EXECUTE REQUESTMP[PGRMM,21];     *MONITOR MODEMC[PGRRR&PGRXR,PGRRR,PGRXR];*TRAP CODES FOR LEFT NINE BITS OF LEFADRSM[MALTRAP,IP[4000 000000S]];    *MONITOR AFTER-LOADING TRAP*300000 000000 TRAP CODE ISN'T USED*THE FOLLOWING CODES ALL HAVE BIT 1 SETSM[SHRNIC,IP[40000 000000S]];   *SHARED N.I.C.SM[PT2NIC,IP[20000 000000S]];   *PT2 N.I.C.*BBN PAGER'S 210000 000000 TRAP (3RD P.T. PRIV N.I.C.) N.I.  IT IS*INCLUDED IN THE 2ND P.T. PRIV. N.I.C. TRAPSM[INDSNIC,IP[4000 000000S]];  *INDIRECT-SHARED PAGE N.I.C.SM[PT3NIC,IP[2000 000000S]];   *PT3 N.I.C.SM[XSIND,IP[1000 000000S]];    *TOO MANY INDIRECT POINTERS*THE FOLLOWING CODES ALSO SET BIT 1 IF TRAP IS IN SECOND OR THIRD PTESV[PNIC,500000 000000];     *PRIVATE N.I.C.SM[WCTRAP,IP[440000 000000S]];  *WRITE COPY TRAPSV[USRTRAP,420000 000000];SV[ACCTRAP,410000 000000];  *ACC=0 OR MT=1 AND IMT=0SV[ILLRX,404000 000000];    *ILLEGAL READ OR XCTSV[ILLW,402000 000000];     *ILLEGAL WRITESV[ALRV,401000 000000];     *ADDRESS LIMIT REG. VIOLATION OR P.T.E.[0,1]=3*LEFADR (ADDRESS IN RH)        VALUE PUT IN Q       REFERENCE  PC CHANGEMC[XLE,PGRMM,PGRXR];         MC[XMQ,QBITS,XA];		*XREF	PC_PC-1MC[XNLE,PGRMM,PGRXR,PGRPIC];				*XREF	NO CHANGEMC[RLE,PGRMM,PGRRR];         MC[RMQ,QBITS,RA];		*RREF	PC_PC-1MC[ILE,PGRMM,PGRRR,PGRIND];				*IREF 	PC_PC-1MC[BRLE,PGRMM,PGRRR,PGRPIC];				*RREF	NO CHANGEMC[RMWLE,PGRMM,PGRRR,PGRWR]; MC[RMWMQ,QBITS,RA,WA,WCT]; *RMWREF	PC_PC-1MC[BRMWLE,PGRMM,PGRRR,PGRWR,PGRPIC];			*RMWREF	NO CHANGEMC[WLE,PGRMM,PGRWR,PGRPIC];  MC[WMQ,QBITS,WA,WCT];      *WREF	NO CHANGEMC[BLTWLE,PGRMM,PGRWR];					*WREF 	PC_PC-1*MAP VARIABLESSVN[UBR]; SVN[MBR]; SVN[WDATA]; SVN[WDATAL]; SVN[PURAGER];SVN[ALR]; SVN[ACBASE]; SVN[PLO];*STORAGE:*REFADR, RPGRT, RPGRT2, RPGRT3*LEFADR, LPGRT, LPGRT2, LPGRT3*G, H, MONALT, PICYCLE, CUM, AND THIRDPT ARE USED IN FMC[CUM&G,CUM,G];MC[PFLAGS,G,MONALT,THIRDPT];MC[MONALT&G,MONALT,G];MC[THIRDPT&G,THIRDPT,G];MC[MQBITS,RA,WA,XA,WCT,QBITS]; *UNION OF LEGAL BITS IN Q*777700 000000 MASKS THE BITS WHICH ARE ALWAYS 0 IN LEFADRLOADMAP: LPGRT_Q, P_MQBITS;	NOT P AND Q, P_7777 777777R, BAMASK[30], Q_LEFADR, WDATA_MDR;	NOT P AND Q, CALL[SCRASH,ALU#0], P_Y, SETSF[CUM&G];	RPGRT_P, Q_600S, CALL[SCRASH,ALU#0];	P-Q, WDATAL_MDRL, GOTO[LDUMAP,G=1];	GOTO[READMAP,ALU<0], LPGRT2_A0, Q_MBASE;*HERE IF MONITOR MODE REFERENCE AND PAGE NO. > 577	Q_MBR;READMAP: READ_P+Q, CLEARF[PFLAGS], CALL[CHKTRAPS];%RETURN HERE IFF AN INDIRECT POINTER WAS ENCOUNTERED AND NO TRAPHAS OCCURRED (HOWEVER, MONALT MAY BE SET IF A MONITOR-AFTER-LOADINGTRAP WAS REQUESTED).  THE 2ND PAGE TABLE ENTRY IS IN MDR, 1B1 IS IN Q,AND LEFADR IS IN P.%	LEFADR_P OR Q, CALL[CHKTRAPS], SETF[THIRDPT&G];%HERE IFF AN INDIRECT-INDIRECT SEQUENCE IS IN PROGRESS--3RD P.T.E.IS IN MDR.  CHKTRAPS WILL NOT RETURN.%	P_(MDR) U (177777 777777S), LEFADR_P OR Q;	P+1, CALL[CHKTRAPS,B>=0];  *SHARED OR PRIVATE*PICK UP OTHER TRAPS IF ILLFORM	P_LEFADR, AMASK[33], Q_200000 000000S, CALL[CHKTRAPS,ALU=0];	P_(P OR Q) U (XSIND), GOTO[PTRAP];LDUMAP:	LPGRT2_A0, Q_ALR;	P-Q, P_LEFADR, Q_777777R;	GOTO[READMAP,ALU<0], LEFADR_P-Q-1, Q_UBR, P_RPGRT; *CLEAR PGRMM	P_LEFADR, Q_ALRV, GOTO[PTRAPU];LEFSET:	FRZBALUBC, LEFADR_P_P OR Q, RETURN;%"CHKTRAPS" EXPECTS THE ACCUMULATED NOT ACCESS TO BE IN LPGRT2,THIRDPT TO BE SET IF THE THIRD P.T.E. IS IN MDR.  RPGRT IS USEDTO REMEMBER P.T.E.#CBITS.%CHKTRAPS: Q_CBITS, CALL[PMDR];*IF THE PAGE IS DIRTY AND WRITES PERMITTED, WRITE ACCESS WILL NEVERTHELESS*BE DISALLOWED IF THE WRITE-COPY TRAP IS SET.  HENCE STUFF BELOW.	RPGRT_P_P#Q, Q_WCT;	P AND Q, Q_LPGRT2;	GOTO[.+2,ALU=0], Q_(Q) U (WA), P, PQ LCY [1];	LPGRT2_Q, FRZBALUBC;	P, GOTO[INDILL,ALU<0], P_RPGRT, Q_LPGRT, MDR_SPT;	P AND Q, PQ RCY [11], SAMASK[15], Q_MDR, GOTO[SHARED,ALU<0];	Q_17 000000S, P_RPGRT, FRZBALUBC;	P AND Q, PQ RCY [0], SAMASK[13], DGOTO[.+3,ALU=0];	CALL[LEFSET,ALU#0], RPGRT2_P, P_LEFADR, Q_PNIC, FRZBALUBC;	CALL[SETTRAPS], P_RPGRT, Q_MT&ACC, A0;*RETURN HERE IFF ONLY TRAP IS MONITOR-AFTER-LOADING WITH ALU=0.*ENTER HERE FROM ABOVE WITH PRIVATE NOT-IN-CORE TEST PENDING.	Q_CST, P_RPGRT2, GOTO[LTRAP,ALU#0];%CSTCHK EXPECTS P.T.E.#CBITS IN RPGRT (GARBAGE IN OTHER BITS), CST IN PAND CORE PAGE NO. IN Q (CAN BE REVERSED), CORE PAGE NO. IN RPGRT2, ANDACCUMULATED NOT-ACCESS IN LPGRT2.%CSTCHK:	RMW_P+Q, INHINT, P_RPGRT, Q_LPGRT2;*POSITION NOT-ACCESS IN LPGRT2 FROM B[2,4] TO B[18,20]	NOT(NOT P AND NOT Q)Q RCY [20], Q_700000S;	P_P AND Q, Q_RPGRT2, SETSF[MONALT&G];	RPGRT2_P OR Q, P_WA, Q_LPGRT;	P AND Q, Q_CSTBITS, CALL[PMDR];	P AND Q, Q_DIRTY, GOTO[SETDIRTY,ALU#0];	GOTO[CSTTRAP, ALU=0], WRESTART, MDRL_WDATAL;SETD1:	P AND Q, Q_MALTRAP, PQ RCY [0], BAMASK[33], INHINT;	MDR_(P) U (PURAGER), P_Q, GOTO[.+2,ALU#0], POP, Q_RPGRT2;	Q_(Q) U (200000S);  *TURN-OFF WRITE PERMISSION	MAP_Q, P_LEFADR, SAMASK[33], Q_P, GOTO[PTRAPU,G=1];	YKPTR_NULL, P_REFADR, CALL[EVINC]; *INC. MAP LOADING COUNTER	MDR_WDATA;JUMPA:	MAPVA_P, Q_1R, BAMASK[22], RETURN;  *RETURN TO CALLER OF LOADMAP*P HAS CST ENTRY MERGED WITH PUR.  ALU=0 IFF CSTTRAP.SETDIRTY: P_P OR Q, GOTO[SETD1,ALU#0], WRESTART, MDRL_WDATAL;%CSTENTRY[3,4] DETERMINE THE TRAP CODE WHEN CSTENTRY[0,2]=0 AS FOLLOWS:   0   100000 000000   1    40000 000000   2    20000 000000   3    10000 000000%CSTTRAP: Q_40000 000000S;	P AND Q, Q_20000 000000S;	P AND Q, P_LEFADR, SAMASK[33], GOTO[.+3, ALU=0];	P_(Q_P) U (10000 000000S), GOTO[PTRAP,ALU#0];	P_(Q) U (20000 000000S), GOTO[PTRAP];	GOTO[PTRAP,ALU#0], P_(Q_P) U (40000 000000S);	P_(Q) U (100000 000000S), GOTO[PTRAP];%ON INDIRECT REFERENCES THE ACCESS FINALLY ALLOWED TO THE PAGE ISTHE LOGICAL AND OF THE ACCESS PERMITTED BY SUCCESSIVE P.T.E.'S.LPGRT2 HOLDS ACCUMULATED NOT ACCESS.  RPGRT WILL HOLDP.T.E.#CBITS.%INDILL:	P AND Q, Q_LPGRT2, GOTO[.+3,ALU>=0];*HERE FOR ILL. FORMAT PAGES WITH TRAP TESTS PENDING	P_LEFADR, Q_ALRV, FRZBALUBC, DGOTO[LTRAP];	LEFADR_P OR Q, CALL[STRAPS,ALU#0];	LPGRT2_P OR Q, GOTO[.+3,ALU=0], Q_777S;*P.T.E.#CBITS IN P, RPGRT AND MDR	Q_MT&ACC, CALL[SETTRAPS];*RETURN HERE IFF ONLY TRAP IS MONALT	P_RPGRT, Q_777S;*SAVE IND. PAGE NO. IN RPGRT	RPGRT_P AND Q, PQ RCY [11], Q_SPT, BAMASK[15];** EVENTUALLY PUT BOUNDS CHECK FOR SPT READS HERE	READ_P+Q;	Q_17 000000S, CALL[PMDR];	P AND Q, PQ RCY [0], BAMASK[13], SETSF[THIRDPT&G];	GOTO[INDNIC,ALU#0], Q_P, P_CST;** EVENTUALLY PUT BOUNDS CHECK HERE*READ CST, GET CORE PAGE LCY 11	RMW_P+Q, 0Q RCY [33], Q_RPGRT, INHINT;*PUT ADDRESS OF NEXT P.T.E. IN RPGRT	RPGRT_P+Q, Q_CSTBITS, CALL[PMDR];	P AND Q, PQ RCY [0], SAMASK[33], WRESTART, Q_MDR;	GOTO[CSTTRAP, ALU=0], INHINT, Q_P, P_Q;	MDR_(Q) U (PURAGER), Q_RPGRT, P_-1L, A0, BAMASK[42];	READ_Q, P_LEFADR, Q_P+1, FRZBALUBC, GOTO[RETN];INDNIC:	P_LEFADR, AMASK[33], Q_200000 000000S;	P_(Q_P OR Q) U (PT2NIC), GOTO[PTRAP,G=0];	P_(Q) U (PT3NIC), GOTO[PTRAP];*HERE WITH PTE#CBITS IN RPGRT AND P, WITH TRAP TESTS IN LPGRT AND QSHARED:	CALL[STRAPS,ALU#0], READ_P+Q;  *RETURN IFF ONLY TRAP IS MONALT	Q_17 000000S, CALL[PMDR];	P AND Q, BAMASK[13];	GOTO[CSTCHK,ALU=0], RPGRT2_P, Q_CST;*SHARED NOT-IN-CORE HERE	P_(LEFADR) LSH [1], Q_200000 000000S;	P, BAMASK[33], P_LEFADR;	GOTO[PTRAP,ALU<0], P_(Q_P OR Q) U (INDSNIC);	P_(Q) U (SHRNIC), GOTO[PTRAP];*MUST TOUCH MDR TO TERMINATE READ AT "SHARED" FOR MAXC2QPRPG:	Q_P AND Q, P_RPGRT, FRZBALUBC, MDR, RETURN;LEFPQF:	LEFADR_P OR Q, P_RPGRT, Q_UT, FRZBALUBC, RETURN;%"SETTRAPS" IS CALLED WITH P.T.E.#CBITS IN RPGRT AND P, MT&ACC IN Q,LEFADR PROPERLY SET, CORE PAGE NO. IN RPGRT2 (PRIV. PAGES), ACCUMULATED NOTACCESS IN LPGRT2, APPROPRIATE R, W, E, WCT, MT, AND ACC IN LPGRT, AND ONE ORMORE TRAPS DETECTED.  MDR CONTAINS READ[SPT+SPTNO] ON SHARED OR INDIRECT ENTRIES.RETURN WITH ALU=0 IFF ONLY TRAP IS MONALT, ELSE TRAP.%STRAPS:	P_RPGRT, Q_MT&ACC;SETTRAPS: P AND Q, Q_UT, GOTO[SETT5];SETT4:	P_LEFADR, Q_ACCTRAP, A0, CALL[LEFPQF];SETT5:	GOTO[SETT0,ALU=0], P AND Q, Q_RA&XA;*HERE IF MONITOR TRAP OR IF ACCESS BIT NOT SET	Q_IMT&ACC, P_RPGRT;	P AND Q, Q_MT&IMT&ACC;	GOTO[SETT4,ALU#0], RPGRT_Q_P AND NOT Q, P_LPGRT;*REMAINING TRAPS ARE IN Q, TRAP TESTS IN P	P AND Q, P_RPGRT, Q_UT, DGOTO[SETT5];*MUST TOUCH MDR TO TERMINATE READ AT "SHARED" FOR MAXC2	MDR, RETURN[ALU=0], SETFC[MONALT&G,ALU=0], A0;*HERE WITH USER TRAP TEST PENDINGSETT0:	Q_P AND Q, P_LPGRT, FRZBALUBC;	P_LEFADR, Q_USRTRAP, P AND Q, CALL[LEFPQF,ALU#0];	P_LPGRT, Q_WA, FRZBALUBC, CALL[QPRPG];*HERE WITH READ OR XCT VIOLATION TEST PENDING	P_LEFADR, P AND Q, Q_ILLRX, CALL[LEFPQF,ALU#0];*HERE WITH WRITE VIOLATION TEST PENDING	P_LPGRT, Q_WCT, FRZBALUBC, CALL[QPRPG];	P AND Q, P_LEFADR, Q_WCTRAP, GOTO[.+2,ALU=0];	P_(P) U (ILLW), FRZBALUBC, GOTO[PTRAP,ALU=0];	GOTO[PTRAP,ALU=0];*FALL THROUGH TO "PTRAPU"%ALL TRAPS WIND UP AT "PTRAP" WITH TRAP STATUS IN P.  TRAP STATUS ISSTORED IN (MBR U TSTAT), WDATA.WDATAL IN (MBR U TSTAT) + 1.PC IS DECREMENTED IFF PGRPIC=0 IN LEFADR.  PC[0,21] ARE ZEROED UNLESSMD2=1 (=BYTE LISP), IN WHICH CASE ONLY PC[0,17] ARE ZEROED.THE MACHINE CRASHES IF A PICYCLE IS IN PROGRESS AT THE TIME OF APAGER TRAP.%PTRAPU: P_P OR Q, GOTO[.+2];LTRAP:	P_LEFADR;PTRAP:	RPGRT_P, P_-1L, BAMASK[27], MDR_MBR;*USE DGOTO'S BELOW FOR THEIR INHINT EFFECT	Q_P+1, P_WRITE_(MDR) U (TSTAT), DGOTO[.+2]; *Q_PGRPIC=40 000000	LPGRT2_P+1, P_RPGRT, SETSF[PICYCLE&K], DGOTO[.+2];*STORE THE TRAP STATUS AFTER CLEARING THE "PGRPIC" BIT IN THE VALUE*J REMEMBERS UM DURING THE TRAP CYCLE.	MDR_P AND NOT Q, SETSF[UM&J], CALL[SCRASH,K=1];	P_PC, P AND Q; *TEST PGRPIC BIT--DON'T DECREMENT PC IF 1	MDR_WDATA, AMASK[24], Q_LPGRT2, GOTO[.+2,ALU#0];	P_P-1;	*CANNOT BE BYTE LISP	WRITE_Q, Q_777777R, SETSF[MD2&G], INHINT;*CLEAR L.H. IF NOT IN BYTE LISP MODE	MDRL_WDATAL, Q_P AND NOT Q, CALL[PMQ,G=0];	OLDPC_Q_P, CLEARF[TFLAGSPI];	PC_Q;	READ_MLTRAP, Q_A0, GOTO[XCTA];%JMC'S FOR MANIPULATING THE PAGER ARE AS FOLLOWS:   MAPRES	TURNS OFF MAPPING, LEAVES PLO=0, ALR=1000   SETPLO	SETS THE LOWER BOUND TO THE SWAPPABLE MONITOR   SPUR1	SETS AGE AND PROCESS USE REGISTERS   VPGCLR	CLEARS VIRTUAL PAGE FROM MAP   APGCLR	CLEARS ALL INSTANCES OF ABSOLUTE PAGE FROM THE MAP (=MAPCLR)   ASWIT	RELOAD BASE REGISTERS FROM [PSWITCH] AND [PSWITCH+1]   MAPCLR	CLEAR MAP ABOVE PLO   USWIT	SWITCH TO NEW PROCESS CLEARING MONITOR PAGES 600 TO 777		AND USER PAGES 0 TO ALR-1 AND RELOADING BASE REGISTERS		FROM [PSWITCH] AND [PSWITCH+1]I = 34%MAPRES:*~ MAXC2 ONLY	P;	*CAN'T READ/WRITE MAP AFTER CUM CHANGE*~	MAP_Y, INCY, GOTO[.,Y>=0], Q_P+1;	PLO_MAP_Y, INCY, GOTO[.,Y<0];  *PLO_0	ALR_Q, Q_RTEMP, RETURN[G=1]; *RETURN "RTEMP" IN Q FOR CONSOLE RESET	SETF[CUM&G], GOTO[MAPRES], Y_NULL, P_777L;*CALLED AFTER P_Y_NULL, Q_PSETPLO: PLO_Q;*"CLRMM1" ENTERED WITH SMALLEST MONITOR PAGE TO CLEAR IN P AND YCLRMM1:	Q_200S, PQ RCY [2], BAMASK[12];	Q_P-Q, P_(-1L) LSH [1], CLEARF[CUM&G];CLRUM1:	X_P-Q;		*MAP4_ COUNT - 2 IN X	Q_700000S;	MAP4_Q, GOTO[.,X>=0], DECX;RETN:	RETURN, FRZBALUBC;*ABSOLUTE PAGE NO. IN P--CURRENTLY CLEAR MAP FROM PLO TO ALR-1MAPCLR: P_Y_PLO, CALL[CLRMM1];	Q_ALR, P_1R;	QQ RCY [2], Y_NULL, Q_2P, SETF[CUM&G], GOTO[CLRUM1];%ROUTINE TO SET ACCESS TO 0 FOR ALL MAP ENTRIES BETWEEN PLO AND 1000 + UBRFOR WHICH MAP[25,43] = E[31,43]JMC DISPATCH INSTRUCTION = CLEARF[CUM&G], Y_A1, GOTO[APGCLR]I = 9, TIMING = 13 + (1024-PLO) + 4/MAP CLEAR*INSURE MATCH ON MAP ENTRY 777APGCLR:	Q_(P) U (700000S), CALL[APGC3];	Y_PLO;APGC0:	DGOTO[.+1];	P#Q, P_(MAP) U (700000S), INCY, GOTO[.,ALU#0];	DECY;	DECY, DGOTO[APGC0,Y<0];*JUMP UNLESS LAST EXEC OR LAST USER MAP ENTRY (CLEAR IT, TOO)	MAP_Q, INCY, GOTO[APGC0,Y>=0];*REPEAT FOR USER MAPAPGC2:	SETF[CUM&G], Y_A1, RETURN[G=1];*CLEAR MAP ENTRY AND RESUME LOOPING	MAP_Q, INCY, GOTO[APGC0];%*VIRTUAL PAGE NO. IN P[33,43] AND Y, USERMODE IN P[32]VPGCLR:	P AND Q, Q_700000S;	SETFC[CUM&G,ALU#0], Y_P, CALL[RETN,ALU#0]; *NEED NOOP AFTER SETF[CUM] ON MAXC2APGC3:	MAP_Q, RETURN;USWIT:	READ_PSWITCH, CALL[MAPCLR];ASWIT:	P_Q_MDR, DGOTO[340];%NOW HAVE BASE REGISTER WORD IN P AND IN Q.  BITS ARE USED AS FOLLOWS:   MBR      IN P[31,43]   UBR      IN P[7,21]   ACBASE   IN P[22,26] BECOMES 775000 + 20*P[22,26]   ALR      IN P[4,6]%	PQ RCY [30], Q_NPC, RTEMP_P, GOTO[.+1];	P_P AND Q, MDR_1000S;	P_P#Q, Q_40S, GOTO[.+2,ALU=0];	MDR_P+Q;	ALR_MDR, P_RTEMP;	PQ RCY [11], Q_3 777000S;	Q_P AND Q, PQ RCY [0], BAMASK[11];	UBR_Q, Q_P, P_777L, BAMASK[4];	MDR_(NOT P AND Q) U (775000S), Q_RTEMP;	ACBASE_MDR, 0Q RCY [33], BAMASK[24], Q_777L;	Q_P AND NOT Q, P_PSWITCH;	MBR_Q;*P_PSWITCH BEFORE CALLSPUR1:	READ_P+1, P_-1L, SAMASK[32], CALL[RETN]; *KNOW DIRTY=400 000000	P_MDR, Q_P+1, CALL[CLRPQ];	PURAGER_Q, RETURN;%THE PAGER SHOULD BE CONTROLLED BY USING THE JMC'S PROVIDED FOR THATPURPOSE.  HOWEVER, CURRENTLY THE CONO PGR FUNCTIONS FOR THE BBNPAGER ARE EMULATED AS CLOSELY AS POSSIBLE.CONO PGR IS EMULATED BY DISPATCHING TO ONE OF 8 ROUTINES SELECTEDBY E[33,35] AND DESCRIBED BELOW:   0  USWIT:  CLEAR MONITOR MAP FROM PLO TO 777 AND USER MAP FROM      0 TO ALR-1 AND RELOAD BASE REGISTERS FROM [PSWITCH] AND [PSWITCH+1]   1  REMOVE ALL ACCESS PERMISSION FOR MONITOR PAGES PLO TO 777.   2  GOTO ILLIO (TRAP AT LOCATION 60)   3  REMOVE ALL ACCESS PERMISSION FOR USER PAGES 0 TO ALR-1   4  MAPRESET:  TURN OFF MAPPING BY LOADING EVERY MAP ENTRY WITH A      POINTER TO THE CORRESPONDING ABSOLUTE PAGE NUMBER AND WITH ALL      ACCESS PERMITTED.  SET PLO TO 0 AND ALR TO 1000.   5  MAPRESET   6  SET PLO TO 100 AND CLEAR MONITOR MAP ABOVE 100   7  SET PLO TO 0 AND CLEAR MONITOR MAPI = 11, S = 7PGRCO:	PQ RCY [0], AMASK[3], Q_NPC, POP;	B_P+Q+1, NPC_B, GOTO[NOOPR];  *DISPATCH TO ONE OF 8 INST. BELOW	GOTO[USWIT], P_Y_PLO, POP;	GOTO[CLRMM1], P_Y_PLO, POP;	GOTO[ILLIO], POP;	GOTO[CLRUMAP], POP;	GOTO[MAPRESET], POP;	GOTO[MAPRESET], POP;	GOTO[.+2], P_Y_100S;	GOTO[CLRMM1], P_PLO_Y_NULL, POP;	PLO_Y, POP, GOTO[CLRMM1];%