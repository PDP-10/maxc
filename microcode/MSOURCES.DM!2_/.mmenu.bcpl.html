<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>MSOURCES.DM!2>mmenu.bcpl</title>
  </head>
  <body>
    <pre>
//mmenu.bcplget "mdecl.d"get "streams.d"external [// OS	Wss; Wns; Puts; Resets; MoveBlock; Zero	Gets; Closes; Endofs; CallSwat; Noop// MASM	ErrorProtect; SymbKeyComp; Min// MDISP	Blink; DisplayOff; @NewLx; @NewCx// MRGN	MarkRgnDispDirty; UpdateDisplay; PaintRgnLine	EveryTimeP; EveryTimeA; SelectedRegion// MTXTBUF	InputTextBuffer; InputTxtRgn; ClearInText// MSYMB	TVtoString// MCMD	CmdCommentStream; ShowActionForm; TextCmdOutStream; CmdMDFS	CFOutStream; DisplayError// MOVERLAY	KillOverlays// MINIT1	ScreenWidth// Defined here	CreateAction; ForgetTemporaryActions; @CurrentMDFS	DoTextAction; ExecuteTextCmdStream; MarkMenus; FormMenu	CommandCount; SkipCommandCount; CFileStream; AbortingCFile// Defined here for init only	ActionBlock; ActionPtr; LastPermanentAction	MenuBlock; @ItemV; MenuTVs; PutMenus	MenuMChange; SelectMenu; deSelectMenu; PaintMenu	ItemStream]manifest [ TopButton = 4; MiddleButton = 1; BottomButton = 2 ]static[ ItemStream; @ItemV; @CurrentMDFS; MenuTVs	ActionBlock; ActionPtr=0; LastPermanentAction; MenuBlock	CommandCount = 0; SkipCommandCount = 0; CFileStream = 0	AbortingCFile = 0]let LookUpMenu(Letter,LineN) = valof[	let LetterV = Letter-$A	LetterV = (LineN &lt; 0) ? LetterV,(LetterV*MaxLineN)+LineN+($Z-$A+1)	if LetterV &gt; MaxMenus then resultis 0	resultis MenuBlock!LetterV]//and ForgetMenu(MDFS) be//[	MoveRegion(MDFS, 0, 0, 0, 0, 0)//	let LetterV,LineN = MDFS&gt;&gt;MDFS.Letter - $A,MDFS&gt;&gt;MDFS.LineN//	LetterV = ((LineN &lt; 0) % (LineN &gt; MaxLineN)) ? LetterV,//		(LetterV*MaxLineN)+LineN+($Z-$A+1)//	if LetterV &gt; MaxMenus then CallSwat()//	MenuBlock!LetterV = 0//]and CreateAction(Name,lvProc,Arg,lvMProc,Char; numargs NA) = valof[	if ActionPtr ge MaxActions then CallSwat("Action table overflowed")	let B = ActionBlock+ActionPtr*(size Action/16)	B&gt;&gt;Action.Name = Name	B&gt;&gt;Action.lvProc = lvProc	B&gt;&gt;Action.lvMProc = ((NA &lt; 4)%(lvMProc eq 0) ? lv Noop, lvMProc)	B&gt;&gt;Action.Arg = Arg	B&gt;&gt;Action.Char = (NA&lt;5 ? 0,Char)	ActionPtr = ActionPtr+1	resultis B]and ForgetTemporaryActions() be ActionPtr = LastPermanentActionand LookUpAction(Name) = valof[	let B,C = ActionBlock,ActionBlock+(ActionPtr*(size Action/16))	while B &lt; C do	[ if SymbKeyComp(B&gt;&gt;Action.Name,Name) eq 0 then resultis B	  B = B+(size Action/16)	]	resultis 0]and DoTextAction(Char) be[	let Action = valof	[ let B,C = ActionBlock,ActionBlock+(ActionPtr*(size Action/16))	  while B &lt; C do	  [ if B&gt;&gt;Action.Char eq Char then resultis B	    B = B+(size Action/16)	  ]	  resultis 0	]	if Action eq 0 then [ Blink(); return ]	DoAction(Action,TopButton,CmdMDFS)]and DoAction(Action,MBunion,MDFS) be[	if TextCmdOutStream ne 0 then	[ WLogicalActToS(TextCmdOutStream,MBunion,MDFS)	  Puts(TextCmdOutStream,$*N)	]	ClearInText()		//Set flag so next in char clears	Resets(CmdCommentStream)	ErrorProtect(Action&gt;&gt;Action.lvProc,ItemStream,		MDFS&gt;&gt;MDFS.Arg,MBunion,Action&gt;&gt;Action.Arg)]and ExecuteTextCmdStream(S) be[ SkipCommandCount,CommandCount = 0,0  let OldCFileStream = CFileStream; CFileStream = S  while true do  [ let Action,Buttons,MDFS,Char = nil,nil,nil,nil    while true do // read in a good action    [ if Endofs(S) % (AbortingCFile ne 0) do      [	 Closes(S); CFileStream = OldCFileStream	 SkipCommandCount = (AbortingCFile ne 0) ? AbortingCFile-1,0	 if (CFileStream eq 0) % (AbortingCFile &gt; 0) then AbortingCFile = 0	 return      ]      Buttons,Action = 0,0      while true do		// Collect mouse buttons      [	if Endofs(S) then goto EndCF	Char = Gets(S)	if Char eq $*N then loop	// Extra &lt;cr&gt;'s ok for formatting	if Char eq $  then break	// Blanks terminate buttons	Buttons = Buttons logor selecton Char into	[ case $L:  TopButton	  case $M:  MiddleButton	  case $R:  BottomButton	  default: -1	]      ]//Assume lines not beginning with "L", "M", or "R" are comments      if Buttons ne -1 do      [ let N,N1 = -1,nil        if Endofs(S) then goto EndCF        Char = Gets(S)		// Collect menu char        while true do		// Collect menu line	[ if Endofs(S) then goto EndCF	  N1 = Gets(S); if (N1 &gt; $9) % (N1 &lt; $0) then break	  N = (N &lt; 0 ? N1,(N*10)+N1) - $0	]	MDFS = LookUpMenu(Char,N)	if (MDFS eq 0) &amp; (SkipCommandCount eq 0) do		DisplayError("Undefined menu")	let TVec = vec 80	Resets(MenuTVs, TVec, ScreenWidth)	while true do	[ if Endofs(S) then goto EndCF	  Char = Gets(S)	  if (Char eq $ ) % (Char eq $*N) % (Char eq $;) then break	  Puts(MenuTVs, Char)	]	let Str = TVtoString(TVec)	Action = LookUpAction(Str)	if (Action eq 0) &amp; (SkipCommandCount eq 0) do		DisplayError("Undefined action",0,Str)	if Char eq $  do	[ Resets(MenuTVs,(SkipCommandCount le 0 ? InputTextBuffer,TVec)		,ScreenWidth)	  while true do	  [ if Endofs(S) then goto EndCF	    Char = Gets(S)//";" begins command file comment	    if (Char eq $*N) % (Char eq $;) then break	    Puts(MenuTVs, Char)	  ]	  Closes(MenuTVs); MarkRgnDispDirty(InputTxtRgn)        ]      ]      until Char eq $*N do      [	if Endofs(S) then goto EndCF	Char = Gets(S)      ]      if Action ne 0 &amp; MDFS ne 0 then break    ] // end of "get a good action"    if SkipCommandCount &gt; 0 do    [ SkipCommandCount = SkipCommandCount-1; loop ]    if not DisplayOff do	// Show what's happening    [ ErrorProtect(lv SelectedRegion&gt;&gt;Rgn.deSelect,SelectedRegion)      let OldMenuItem = MDFS&gt;&gt;MDFS.SelectedItem      let PV, N = MDFS&gt;&gt;MDFS.ProcV, 0      for I = 1 to PV!0 do if PV!I eq Action then [ N = I; break ]      if OldMenuItem ne 0 then	  MenuMarkSItem(MDFS, OldMenuItem, false)      MenuMarkSItem(MDFS, N, true)      MDFS&gt;&gt;MDFS.SelectedItem = N      MarkRgnDispDirty(MDFS)      SelectedRegion = MDFS      for I = 1 to EveryTimeP!0 do	ErrorProtect(lv EveryTimeP!I,EveryTimeA!I)      UpdateDisplay()    ]		// End of display update    DoAction(Action,Buttons,MDFS)    CommandCount = CommandCount - 1EndCF:  ]]//  local proceduresand PaintMenu(MDFS) be[	let TextLines = MDFS&gt;&gt;MDFS.TextLines	let X = 0	for I = 0 to MDFS&gt;&gt;MDFS.inLine - 1 do	[ PaintRgnLine(I, TextLines+X)	  X = X + TextLines!X + 1	]	for I = MDFS&gt;&gt;MDFS.inLine to MDFS&gt;&gt;MDFS.Rgn.Height-1 do		PaintRgnLine(I, table [ 0 ] )]//Call the procedure for forming the menuand FormMenu(MDFS,Proc,Arg) be[	CurrentMDFS = MDFS	ItemV!0 = 0	MDFS&gt;&gt;MDFS.TextLines!0 = 0	MDFS&gt;&gt;MDFS.inLine = 1	MDFS&gt;&gt;MDFS.ProcV!0 = 0	MDFS&gt;&gt;MDFS.SizeV!0 = 0	Proc(ItemStream,Arg)	MDFS&gt;&gt;MDFS.SelectedItem = 0	MenuSelectItem(MDFS)]and MarkMenus(Proc) be[	let MDFS = CurrentMDFS	let TextLines = MDFS&gt;&gt;MDFS.TextLines	let ProcVec = MDFS&gt;&gt;MDFS.ProcV	let SizeVec = MDFS&gt;&gt;MDFS.SizeV	if ProcVec!0 ge MDFS&gt;&gt;MDFS.ProcNMax then	  test Proc eq 0; ifso return; ifnot CallSwat()	ProcVec!0 = ProcVec!0 + 1	ProcVec!(ProcVec!0) = Proc	let X,Z = 0,0	for I = 1 to (MDFS&gt;&gt;MDFS.inLine)-1 do	[ X = X + TextLines!X + 1; Z = Z + SizeVec!Z + 1 ]	let Size = ItemV!0	if TextLines!X +  Size &gt; MDFS&gt;&gt;MDFS.Rgn.Width then	[	if MDFS&gt;&gt;MDFS.inLine ge MDFS&gt;&gt;MDFS.Rgn.Height then return		MDFS&gt;&gt;MDFS.inLine = MDFS&gt;&gt;MDFS.inLine + 1		X = X + TextLines!X + 1		TextLines!X = 0		Z = Z + SizeVec!Z + 1		SizeVec!Z = 0	]	SizeVec!Z = SizeVec!Z + 1	SizeVec!(Z+SizeVec!Z) = Size	let Y = X + TextLines!X	MoveBlock(TextLines+Y+1,ItemV+1,ItemV!0)	TextLines!X = Y - X + ItemV!0	ItemV!0 = 0]and PutMenus(S, B) be	if ItemV!0 &lt; ScreenWidth then	  [ ItemV!0 = ItemV!0 + 1; ItemV!(ItemV!0) = B ]// deSelectMenu, SelectMenu, and MenuMChange are the entries to all of// this stuff from MRGN--they are called in orderand deSelectMenu(R) be[// Current deselect routines are Noop for command menu and Resets for MPD's	ErrorProtect(lv R&gt;&gt;MDFS.deSelect,R&gt;&gt;MDFS.Arg)	R&gt;&gt;MDFS.mIn = 0; MenuSelectItem(R)	if ShowActionForm then Resets(CmdCommentStream)]and SelectMenu(R, InR, MB, MBunion) be[	R&gt;&gt;MDFS.mIn = R eq InR ? 1,0	WActC(R,MBunion)]and MenuMChange(R, InR, MB, MBunion) be[	R&gt;&gt;MDFS.mIn = R eq InR ? 1,0	let N = R&gt;&gt;MDFS.SelectedItem	let PV = R&gt;&gt;MDFS.ProcV	let Action = PV!N	if (Action ne 0) &amp; (MB eq 0) &amp; (MBunion ne 0) &amp; (R eq InR) &amp;		(N ne 0) then DoAction(Action,MBunion,R)	Action = PV!N	if (N &gt; 0) &amp; (Action ne 0) then ErrorProtect(Action&gt;&gt;Action.lvMProc,		ItemStream,R&gt;&gt;MDFS.Arg,MB,Action&gt;&gt;Action.Arg)	WActC(R,MBunion)]and WActC(R,MBunion) be[	MenuSelectItem(R)	if ShowActionForm then	[ Resets(CmdCommentStream)	  WLogicalActToS(CmdCommentStream,MBunion,R)	]]and MenuSelectItem(MDFS) be[	let SizeVec = MDFS&gt;&gt;MDFS.SizeV	let X,N = 0,0	let rlx = NewLx-MDFS&gt;&gt;MDFS.Rgn.aLineX-1	let rcx = NewCx-MDFS&gt;&gt;MDFS.Rgn.aCharX-1	if MDFS&gt;&gt;MDFS.mIn ne 0 do	[ rlx = Min(rlx,MDFS&gt;&gt;MDFS.inLine-1)	  for I = 1 to rlx do	  [ N = N + SizeVec!X; X = X + SizeVec!X + 1 ]	  let Y = 0	  for I = 1 to SizeVec!X do	  [ Y = Y + SizeVec!(X+I)	    N = N + 1; if Y &gt; rcx then break	  ]	]	if MDFS&gt;&gt;MDFS.SelectedItem ne N then	[ if MDFS&gt;&gt;MDFS.SelectedItem ne 0 then	    MenuMarkSItem(MDFS, MDFS&gt;&gt;MDFS.SelectedItem, false)	  if N ne 0 logand MDFS&gt;&gt;MDFS.ProcV!N ne 0	    then MenuMarkSItem(MDFS, N, true)	  MDFS&gt;&gt;MDFS.SelectedItem = N	]	MarkRgnDispDirty(MDFS)]and MenuMarkSItem(MDFS, N, Flag) be[	if N eq 0 then return	let TextLines = MDFS&gt;&gt;MDFS.TextLines	let SizeVec = MDFS&gt;&gt;MDFS.SizeV	let X, Y, M = 0, 0, 0	while M + SizeVec!Y &lt; N do	[ X = X + TextLines!X + 1	  M = M + SizeVec!Y; Y = Y + SizeVec!Y + 1	]	for I = 1 to N-M-1 do [ Y = Y+1; X = X+SizeVec!Y ]// set indicated chars to white on black or normal, depending on Flag	Flag = Flag &amp; #200	let EndX = SizeVec!(Y+1)+X	for I = X+1 to EndX do	[ TextLines!I = (TextLines!I &amp; #177) % Flag	]]and WLogicalActToS(S, MB, MDFS) be[	let N = MDFS&gt;&gt;MDFS.SelectedItem	if N le 0 then return	if (MB &amp; TopButton) ne 0 then Puts(S, $L)	if (MB &amp; MiddleButton) ne 0 then Puts(S, $M)	if (MB &amp; BottomButton) ne 0 then Puts(S, $R)	Puts(S, $ )	Puts(S,MDFS&gt;&gt;MDFS.Letter)	let L = MDFS&gt;&gt;MDFS.LineN	if (L ge 0) &amp; (L le MaxLineN) then Wns(S,L,0,10)	Puts(S, $ )	Wss(S, ((MDFS&gt;&gt;MDFS.ProcV)!N)&gt;&gt;Action.Name)	Puts(S, $ )	for I = 1 to InputTextBuffer!0 do Puts(S, InputTextBuffer!I)]</pre>
  </body>
</html>
