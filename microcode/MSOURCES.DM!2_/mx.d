//mx.d//Definitions for Maxc 2 Loader//Manifest Constant Declarationsmanifest [//The memory interface to Maxc2 is accessed through the new machine//instructions below.  These instructions accept an address vector//ADVEC in AC0, data vector in AC1, and a word count in AC3 (multiword//instructions only).  The 20-bit addresses//are left-justified in two words, and the 40 data bits are left-justified//in three words.  The instructions return a code in AC0 about what//happened:  0 = AOK, 1 = read parity error (RMW has completed),//2 = read timed out (120 microseconds without interface free),//and 4 = interface busy when started (should never happen)FETCH=66000B		//Machine instruction to initiate a fetchSTORE=66001B		//Machine instruction to initiate a storeRMW=66002B		//Machine instruction to initiate RMWMBLKS=66003B		//Repeatedly store a single word from DVEC into MaxcMFBLK32=66004B		//Fetch a block of 32-bit words from MaxcMSBLK32=66005B		//Store a block of 32-bit words into MaxcMFBLK40=66006B		//Fetch a block of 40-bit words from MaxcMSBLK40=66007B		//Store a block of 40-bit words into MaxcRTN=1401B		//Used to continue Bcpl after FETCH or STORE//20-bit memory addresses are mapped by the hardware as follows://In four quadrant mode://  B[16,18] module number//  B[19,20] card group//  B[21,23] card row//  B[24,33] chip//  B[34,35] quadrant//  The module number is mapped due to bit scrambling as follows://    0 mapped into quadrant 4;//    1 into 0//    2 into 6//    3 into 2//    4 into 5//    5 into 1//    6 into 7//    7 into 3//In two-quadrant mode://  B[16]=0//  B[17,19] module number//  B[34]B[20] card group//  B[21,23] card row//  B[24,33] chip//  B[35] quadrant//  The module number is mapped as follows://    0 into 4//    1 into 5//    2 into 0//    3 into 1//    4 into 6//    5 into 7//    6 into 2//    7 into 3//The memory configuration for CONFR (see below) is as follows://  0  four quadrants JKLM//  1  JK//  2  JL//  3  JM//  4  KL//  5  KM//  6  LM//The maintenance interface is accessed by the Alto memory devices//given below.  At the beginning of the program @ERRENB should be//set to 16B.  @OUTREG and @OUTREGP are written and @INREG is read only//after @ADREG is loaded with a register number.  There are some//registers which, when selected in ADREG, inhibit certain hardware//activities such as memory refresh.  For this reason, it is good//practice to store 0 in @ADREG when not using it.//After @ADREG=below do foo = @INREG  PPSTAT=100B	//Port and processor power status		//B[14]=1 is port on, B[15]=1 is processor  CABST=20B	//CABST+2*cabinet is power status		//B[12,15] are ones for supplies 0 to 3 AOK  RUN=200B	//SMI address for run status read		//B[8] not running		//B[9] breakpoint		//B[10] not parity halt		//B[11] not memory parity error  B0=203B	//Processor bus B[0-15] complemented  B1=202B	//Processor bus B[16-31] complemented  B2=201B	//Processor bus B[32-35] in B[8,11] complemented  JKERRS=43B	//J & K quadrant error reporting		//B[2,7] for J and B[10,15] for K report errors		//B[2] timeout		//B[3] parity error on data sent to memory		//B[4] address parity error		//B[5] parity bit failure		//B[6] double error		//B[7] single error  LMERRS=44B	//L & M quadrant error reporting as above//After @ADREG=below do @OUTREGP=dataOUTREGP=177402B	//SMI write with pulse register  PLMR=40B	//SMI phys & log mod & EC reg address		//B[7]=1 disables error correction		//B[8,10] select logical module		//B[11,13] select physical module (see map)		//B[14,15] select quadrant (0=J, 1=L, 2=K, 3=M)//After @ADREG=below do @OUTREG=data  CR=210B	//Control register complemented  BR0=213B	//Processor bus B[0,15] complemented  BR1=212B	//Processor bus B[16,31] complemented  BR2=211B	//Processor bus B[32,35] from B[8,11] complemented  PIR0=217B	//Microinstruction B[0,15]  PIR1=216B	//Microinstruction B[16,31]  PIR2=215B	//Microinstruction B[32,47]  PIR3=214B	//Microinstruction B[48,63]  PPPWR=101B	//SMI address for port and processor power  CONFR=41B	//SMI configure & error mask reg address		//B[4] enable FER  		//B[5,7] configuration (see map)		//B[8,9], B[10,11], B[12,13], and B[14,15]		//apply to quadrants J, K, L, and M with		//the first bit = 1 meaning "single error fatal"		//and the second bit = 1 meaning "parity error fatal"  RESR=42B	//Reset error reg address.  Zeroes in B[8], B[10], B[12],		//and B[14] reset error latches for quadrants as for CONFR.		//Zeroes in B[9], B[11], B[13], and B[15] cause		//catastrophic resets (may clobber memory)  CABPWR=21B	//CABPWR+2*cabinet turns on power  		//B[12,15] select supplies 0-3ERRINF=177404B	//SMI read error info register		//B[12] COMA		//B[13] COMB		//B[14] NFER (correctable single error)		//B[15] FER (fatal error)ERRENB=177405B	//SMI test control register (16B is normal)		//B[12] = 0 forces FER = 1		//B[13] = 0 forces NFER = 1		//B[14] = 0 causes reading INREG to return ADREG, writing		//  OUTREG to set COMA, and writing OUTREGP to set COMB		//B[15] = 1 causes reading INREG to return last OUTREG//Pointers to microinstructions used by loader//**Also have to check declarations in MXA.BCPL when these change**	RDX=0; RDAC=RDX+5; RDY=RDAC+5; RDP=RDY+5; RDQ=RDP+5	RDF=RDQ+5; RDNPC=RDF+5; RDMAR=RDNPC+5; RDMDR=RDMAR+5;	RDMDRL=RDMDR+5; RDKMAR=RDMDRL+5; RDKMDR=RDKMAR+5	RDKMDRL=RDKMDR+5; RDARM=RDKMDRL+5; RDKUN=RDARM+5	RDEREG=RDKUN+5; RDBPC=RDEREG+5; CALL=RDBPC+5	RDSTK=CALL+5; POPSTK=RDSTK+5; RNIMA=POPSTK+5	BRNIMA=RNIMA+5; RDPP1=BRNIMA+5; RDBR=RDPP1+5	LDBR=RDBR; LDX=LDBR+5; LDAC=LDX+5; LDY=LDAC+5; LDP=LDY+5	LDQ=LDP+5; SETFLY=LDQ+5; LDNPC=SETFLY+5; LDMAR=LDNPC+5	LDMDR=LDMAR+5; LDMDRL=LDMDR+5; LDKMAR=LDMDRL+5	LDKMDR=LDKMAR+5; LDKMDRL=LDKMDR+5; LDARM=LDKMDRL+5	LDKUN=LDARM+5; LDEREG=LDKUN+5; LDBPC=LDEREG+5	RDSMF=LDBPC+5; LDSMF=RDSMF+5; CLRFLY=LDSMF+5	SETFLQ=CLRFLY+5; CLRFLQ=SETFLQ+5; SETFNQ=CLRFLQ+5	RDLM=SETFNQ+5; RDRM=RDLM+5; RDMAP=RDRM+5; RDDM=RDMAP+5	RDDM1=RDDM+5; RDDM2=RDDM1+5	RDSM=RDDM2+5; RDIML=RDSM+5; RDIMH=RDIML+5; RDKSTAT=RDIMH+5	LDLM=RDKSTAT+5; LDRM=LDLM+5; LDMAP=LDRM+5; LDDM=LDMAP+5	LDDM1=LDDM+5; LDDM2=LDDM1+5	LDSM=LDDM2+5; LDIML=LDSM+5; LDIMH=LDIML+5	CLRARM=LDIMH+5; INTRETN=CLRARM+5	SINSTP=INTRETN+5; MGO=SINSTP+5; MSTOP=MGO+5; WKWRES = MSTOP+5	CONFIG=WKWRES+5; MASK=CONFIG+5; DATA=MASK+5; GDATA=DATA+5	ARANGE=GDATA+5; COUNT=ARANGE+5; TSTINS=COUNT+5	NOP=TSTINS+5	LDRSIZ=88		//Size of LDR memory	NMEMS = 14	//Number of microprocessor memories	NREALMEMS = 12	//Number of real memories (omits LDR and KSTAT)	NREGS = 17	//Number of microprocessor registers	NREALREGS = 17	//Number of read-write registers	NPATS = 8	//Number of data test patterns	NFLDS = 12	//Number of microinstruction fields]external [//Subroutines defined in MXA.ASM//Execute a microinstruction, then read result of various sizes	XctR4; XctR8; XctR9; XctR12; XctR18; XctR20; XctR36//Load BR from DataVec's of various sizes then execute microinstruction	XctL4; XctL8; XctL9; XctL12; XctL18; XctL20; XctL36//Execute a microinstruction through PIR	XctMic	SetIMRd; SetIMLd	//IM DataVec transform//Restore registers clobbered incidentally during memory read/write	RestoreMRegs//Unpack AddrVec for MemX into MADDRL and MADDRH, checking legality//and load address register for memory (used only by PutMemData and//GetMemData)	ConvertAV	ZeroCore//Vectors defined in MXA.ASM (initialized by InitMPInterface)	@MEMWID		//table of memory widths	@MEMLEN		//table of memory lengths	@MEMNAM		//Table of memory names	MName	@MEMFORMS	//Table of memory ouput format vectors	MForm	@REGWID		//table of register widths	@REGNAM		//Table of register names	RName	@REGFORMS	//Table of register output format vectors	RForm	@LDRMEM		//LDR memory	@ITRCNT		//points at LDR COUNT	@INSTST		//points at LDR TSTINS	@MEMCFG		//points at LDR CONFIG	@ADRANG		//points at LDR ARANGE//Four-word vectors beginning at even word boundaries (for MAIN refs)	@TMP; @TMP1; @TMP2	@CUM		//pointa at 36-bit CUM = 400//When a test starts, the value in LDR MASK is copied into BITS-CHECKED.//When a test terminates, the values in GOODD and ACTD are copied into//LDR SHOULD-BE and DATA-WAS, so that they can be displayed.	@GOODD		//holds data written on tests	@ACTD		//holds data read on tests	@DMASK		//holds comparison mask	@RANDATA	//static for random-number generator	@RANDIX		//another static for random-number generator	@PATTERN	//index for test data pattern	@LOWADDR	//Low memory address tested	@HIGHADDR	//High memory address tested	@TAVEC		//Address vector for memory tests	@TestWidth	//Width of register or memory being tested	@REGACT		//Vector of register actions	@MEMACT		//Vector of memory actions	@PATACT		//Vector of pattern actions	@QUITact	//Action static for termination	@QuitF		//Flag or EveryTimeList function//Vectors holding the microprocessor state.  Only those registers clobbered//incidentally during reading/writing others are saved.  This is done to//avoid unnecessary state saving.  Other registers are directly read/written//in the microprocessor.	@SMFORF; @F; @Q; @EREG; @STK//Variables defined in MXA.ASM	@IMA; @NPC; @X; @Y	//microprocessor state	@MADDRL		//low part of memory address	@MADDRH		//high part of memory address (MAIN only)	@LADDR		//displacement into LDR for MADDRL	@MAINsize	//max. legal value in MADDRH for MAIN//SMI addresses defined in MXA.ASM	@ADREG; @INREG; @OUTREG//Other statics	FirstAct; TestAborted; ParityFatal; SingleFatal	AltRForms; AltMForms//Subroutines defined elsewhere in MIDAS	CmdCommentStream; Blink; SearchBlocks; CharInputRoutine	GetField; PutField; DisplayError; ClearInText; WssCSS	UpdateDisplay; QuitCmdOverlay; ErrorProtect	CreateAction; AddToEveryTimeList; RemoveFromEveryTimeList	MPDSwitchPhase; WsMarkA; DoubleNeg; FormMenu; FormCmdmenuText//Statics defined elsewhere in Midas	@LongOne; LoadDone; CmdMDFS; OverlayZone//Operating System stuff	Endofs; Gets; keys; Resets; Wss; Wns; Wos; Puts	Zero; MoveBlock; SetBlock; DoubleAdd; StartIO	CallSwat; Timer; Noop//Subroutines in MXI, MX, MXPOW, MXTST, or MXTALL used elsewhere in Midas	GetRegData; PutRegData; GetMemData; PutMemData	InitHardware; FinishHardware	MicGo; MicStop; SingleStepM; InsertBreak; RemoveBreak; StartM	MicTest; TestAll; FieldTest; DataTest; RepeatGo; RepeatSS	ProcOnTest; MGetMemData; MPutMemData; MPutRegData; MGetRegData	RestoreAfterLoad; ReadAllRegs//Subroutines used among the above and MCMD only	Wait; LeftAdjust; RightAdjust; CheckData; ReportPE; ScanForLMPE	NextGDATA; GetPattern; TestStop; ErrorStop; TestMenu	SetupNPCIMA; MaxcStopped; ResetMaxc; PrintIMA; PrintDM]structure [ lh byte; rh byte ]