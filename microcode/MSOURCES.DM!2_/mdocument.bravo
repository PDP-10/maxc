// mdocument.bravo--external procedures and statics of Midas//MIDASNmidas		// Main programPutField	// PutField(Bit1, NBits, DVec, Field) will copy NBits		// from Field (right adjusted word) to a position in		// DVec, starting with Bit number Bit1, where the bits		// are numbered starting from 0, and from high order bit		// to low order bit.  NBits must be le 16.GetField	// GetField(Bit1, NBits, DVec) returns the contents of the		// named field.  (will be right justified).StartTimer	// Put -time in TimeStart to begin interval timingElapsedTime	// (Initialization only) Allocate storage for timer and		// record elapsed time since TimeStart.MidasFinish	// Routine invoked by bcpl finish and by Run-Program command		// prior to RestoreState//STATEINITStorageInit	// StorageInit(FirstStatic,LastStatic,sysZoneSize,		//	StackSize,ErrRtn)		// init storage area, rebuild sysZone after Junta,		// Allocate the StateBlock for subsequent use of BeginSave		// and SaveState.  FirstStatic and LastStatic delimit		// the static area as given in the Layout vector passed to		// Nmidas by CallSubsys.SaveStatics	// Called with up to 20 args.  The args are pointers to		// page zero statics or other program locations which		// must be saved/restored by SaveState/RestoreState.//STATEBeginSave	// All storage allocated by GetStorage after BeginSave		// is preserved by SaveState and restored by RestoreState.GetStorage  	//  GetStorage(Size) returns pointer to permanent block of		// size Size, or calls Swat if not enough space.GetEvenStorage // GetEvenStorage(Size) returns pointer to block of size 		// Size which starts on an even addressStorageLeft	// returns the amount of free storage left for GetStorage.SaveState	// SaveState(S,Label) writes the program "state" on the		// stream S.  Label in the caller's frame is the location		// which is resumed to by RestoreState (should be right		// after call to SaveState).RestoreState	// RestoreState(S,reinitFlag) restores "state" from the		// stream S.  reinitFlag is true when RestoreState is		// called as part of program initialization, false when		// call is to reinitialize for Run-Program.//MASM		Hand-coded proceduresDummyCall	// DummyCall(lv Proc,NA,A1,A2,...,An) calls Proc with NA		//args so that the overlay machinery can intercept the		//call and return.ErrorProtect	// ErrorProtect(lv Proced, A1, A2, ... An) will result in		// a call on Proced with the n params, A1, ... An.		// Subsequently, DisplayError causes a return from this		// call.  If the overlay machinery was invoked, the		// overlays are killed.Mag		// Mag(X) is the magnitude of X.Max		// Max(X,Y) is the maximum of X and Y.Min		// Min(X,Y) is the minimum of X and Y.StrSize		// StrSize(StrPtr) is the length of the string in words.SearchBlock	// SearchBlock(Block,Boffset,Bname,Addr,MemX) is a		// subroutine which searches Block for the symbol		// in MemX whose value is the largest less than or equal to		// Addr (see MSYM).MoveUp		// MoveUp(To,From,Count) moves the block of words of length		// Count with last location at From to the block whose last		// location is at To (i.e. like MoveBlock but starting at the		// last location of the block).VertIntCode	// Vertical interrupt routine initialized in MDISPClearAndScanConvert		// ClearAndScanConvert(BitBuffer,TextVec) used by MDISPSymbKeyComp	// SymbKeyComp(Str1,Str2) compares the two strings		// returning 0 on equal, positive on Str1 >= Str2,		// negative on Str1 < Str2.BinScan		// BinScan(Block,Key) returns the index of the greatest		// record in Block with key le Key.GetBodySize	// Another subroutine for MSYM.FindBlock	// Another subroutine for MSYM.//MDISPPaintLine	// PaintLine(L, TV)  scan converts textvec TV onto		// screen line L, used only by  PaintScreen in mrgnGetMouseAndCursor// GetMouseAndCursor() places the current values of		//Mouse Buttons, Cursor, line index, and cursor char index		//into NewMB, NewLx, and NewCxFinishDisplay	// FinishDisplay() should be called before returning to		// operating system, if InitDisplay has been previously		// calledBlink		// Blink() will blink the entire display onceSetDisplay	// SetDisplay(Flag) turns off the display if Flag is true,		// turns it on if Flag is false.MakeDispZoneAvail		// MakeDispZoneAvail(FirstLine, NWords) blackens some		// of screen (FirstLine to FirstLine + NLines - 1),		// where NLines is computed to make at least NWords		// available, and		// returns a Zone constructed from the bit buffers		// of that portion of the screen.  Used only by 		// Moverlay.bcpl.ReUseDispSpace	// ReUseDispSpace() reverses the effect of		// MakeDispSpaceAvail.  Used only by ReUseScreenSpace		// of mrgn.bcpl and by moverlay.bcpl after init.PrepareCharInv	// PrepareCharInv(charlocinfont) is called by		// ClearAndScanConvert in MASM it invert black for		// white//MRGNDriverLoop	// DirverLoop() is called by Midas.  This is the main		// loop of midas.  It returns only for exit from midas.		// It is also called by StartCmdOverlay in MCMD to		// put up alternate command menus.MarkRgnDispDirty	// MarkRgnDispDirty(R) indicates that region R		// should paint during next display loopModifyRgnLine	// ModifyRgnLine(rlx, rcx, TV) is used by a regions 		// Paint routine to place text vec TV at relative location		// rlx, rcx.  Modifies chars rcx to rcx + TV!0 - 1		// Regions paint routine is at R>>Rgn.pPaint		// and is called by DisplayLoopPaintRgnLine	// PaintRgnLine(rlx, TV) is used like ModifyRgnLine,		// except paints the whole line within the region.		// TV is placed at rlc to rlc + TV!0 - 1, blanks followUpdateDisplay	// UpdateDisplay() causes the screen to be recomputed.		// It is called by DriverLoop and by actions which want		// the display updated before returing to DriverLoop.BeginError	// BeginError(Rgn) will start error processing.  The only		// region which will be active is Rgn.  This routine		// should only be called when mouse buttons are 0,		// else unpredictable results will occur.EndError	// EndError(P) will terminate error processing. 		// P will be returned as a result of the original call		// on BeginError.AddToEveryTimeList		// AddToEveryTimeList(Proc, Arg) assuures that a call		// will be made to "Proc(Arg)" once every time		// around the main driver loop.  AddTO... returns		// as result a pointer which can be used as an argument		// to RemoveFromEveryTimeList.RemoveFromEveryTimeList		// RemoveFromEveryTimeList(Entry) will stop the calls		// resulting from an earlier call on AddToEveryTimeList,		// where that earlier call returned Entry.//MTVStreamFromTextName		// StreamFromTextName(Act, TV, DotExt, ksType, ItemSize)		// returns a stream.  First, a string name for the file		// is computed.  It is a string constructed from		// TextVec TV, or such a string with DotExt appended		// to it. (DotExt is a string).  DotExt will be appended		// if no Periods appear in TV.  Finally, the stream is		// obtained by Act(Name, ksType, ItemSize)//MPARSEParseAddress	// ParseAddress(TV,lvX,PV,lvY)ParseTextList	// ParseTextList(TV,lvX,Pv,lvY)//MIOCMTexttoData	// MTexttoData(MemX,TV,DVec) andRTexttoData	// RTexttoData(RegX,TV,DVec) accept a memory or register		// index, a TextVec TV (one char/word		//		TV!1, TV!2, . . . TV!(TV!0), and a DataVec		// They convert the TextVec into a DataVec for the selected		// register or memorySimpleTexttoDVec		// SimpleTexttoDVec(TV,Nbits,DVec) converts an octal		// TextVec into a DataVec of size Nbits.  Blanks are		// flushed.  If characters other than octal chars and		// blanks are in TV, then the text is treated as an		// an address and offset which is evaluated.MDatatoStream	// MDatatoStream(Stream,MemX,DVec) andRDatatoStream	// RDatatoStream(Stream,RegX,DVec) format data in DVec		// and output the text to Stream under control of a		// formatting table pointed at by MEMFORMS!MemX or by		// REGFORMS!RegX.SimpleDVectoStream		// SimpleDVectoStream(Stream,NBits,DVec,flush0,LastFlag)		// converts NBits of DVec to an octal string output to		// Stream.  If flush0 eq 0 then leading zeroes in the		// output are suppressed.  If flush0 eq $0 then leading		// zeroes are printed.  If the entire result is 0,		// then LastFlag eq true will print the final 0, else not.//MOVERLAYUserReadOverlay		// Used by LPD's overlay package.  Constructs OverlayZone		// from the display bit buffers using MakeDispZoneAvail.		// This zone is used for the overlay.KillOverlays	// KillOverlays() will cause all overlays to be flushed.SwappedOut	// Dummy routine needed by BLDR.//MSYMEvalAText	// EvalAText(TV, lvX, AVal, ifExpectMore) will return		// true if the text starting at TV!(rv lvX) has the form		// of an address, and unless ifExpectMore, is not		// followed by more text.  In the case of a true return,		// AVal is filled with information describing the address.		// See later for the structure of AVal.  rv lvX is		// adjuested to point to the next field, after being		// stepped over one char, assumed to be a comma.SearchBlocks	// SearchBlocks(S,MemX,AVec,Addr) searches all symbol blocks		// for the address symbol in MemX whose value is the largest		// le AVec.  Optional fourth arg Addr causes ".-3" to ".+3"		// to be printed if no symbol exactly equals AVec and if		// AVec!1 is within 3 of Addr.  Otherwise, the symbol is		// printed on the stream S followed by the displacement "+n".UpdateRcd	// UpdateRcd(Key, Body, BodySize)		// either inserts a new or updates an existing record.SaveRcdFile	// SaveRcdFile(Stream,Block,Npages) writes out dirty		// symbol blocks on Midas.SymTab.RestoreRcdFile	// RestoreRcdFile(Stream,Block,Npages) restores itFindInTable	// FindInTable(Key, Body, lv BodySize) attempts		// to find a table entry.  Returns true if succeeded.		// Key is a pointer to a bcpl string.		// Body is place where result record will be placed.		// BodySize will contain actualsize of body.TVtoString	// TVtoString(TV) returns a sstring with same contents 		// as the textvec TV.  Only one such string may exist		// at a time. (They are stored in a fixed vector)		// useful for making entries in symbol table.//MTXTBUFClearInText	// ClearInText() flags input text buffer to go to empty		// if any new chars are typed.(1674)TxtBNewChar	// TxtBNewChar(Char) puts Char into the command line input		// buffer//MMENUCreateAction	// CreateAction(Name, lv Proc, Arg, lv MCProc, Char)		// creates an action for use in a menu item.		// (See above for Marks, in description of .)  Name is a		// text name for the action.  Proc is a procedure.		// (lv is used so if the contents of the static changes,		// e.g. during swapout, the action will use the changed value		// of the static.)  Arg will be supplied as Arg2 in the call to		// Proc.  (again, see above description.)  Storage is		// obtained from a resident table and the name string		// is not copied, so it must be resident also. If lv MCProc		// is given and non zero, that procedure will be		// called each time the mouse buttons change and this action		// is in the selected menu item.  Char is a character which		// invokes the action from the keyboard when ";" precedes		// it (and "=" and ":" not preceded by ";"ForgetTemporaryActions	// Deletes actions created during command overlay.DoTextAction	// DoTextAction(String) exectutes the action named String		// in the "CMD" menuExecuteTextCmdStream		// ExecuteTextCmdStream(Stream) is used by Cmd to 			// read commands from a text 		// stream, of the form created by the write cmd		// stream action.MarkMenus	// MarkMenus(Proc) is called to mark the last text output		// to ItemStream as a menu item such that Proc gets		// called when that text is bugged.  Marks as a null		// menu item if Proc is 0.FormMenu	// FormMenu(MDFS,Proc,Arg) rebuilds a menu by initializing		// and then calling Proc(ItemStream,Arg).//MMPRGNInitMPDispRegions	// InitMPDispRegions() define the address and value		// actions for the register area of the display.MPDSwitchPhase	// MPDSwitchPhase() must be called whenever the register		// display has changed, so that it gets updatedDoubleNeg	// DoubleNeg(N) negates the double-precision integer		// pointed to by NShowBadAddr	// ShowBadAddr([Str]) prints "Bad address" on		// CmdCommentStream if arg omitted else Str.ShowAddr	// ShowAddr(AVal) gives the alternate printout of an		// address or register on the command comment line.  This		// is both memory and offset and symbol and offset for		// addresses or is register and offset for registers.//MCMDInitCmd		// InitCmd(Father, rlx, rcx, H, W) initializes the		// command menu region.WssCSS		// WssCSS(str) prints string on command comment line.WsMarkA		// WsMarkA(Action) puts up the name of Action in the		// command menu followed by a blank.ConfirmAct	// ConfirmAct(Str,TV) temporarily turns on display (if off)		// and prints on the command comment line first Str, then TV,		// and finally "[Confirm]".  Returns false if not confirmed		// else true if confirmed, display restored to original state.DisplayError	// DisplayError(S1, S2) should only be called		// by routines running in response to a MouseButton		// going to zero, and only after at least one previous		// call to SetCmdAbortLabel.		//		// S1 is a string explaining the error.  S2 is an		// optional string which will be a selectable item		// to allow continuation.  The only other selectable		// item aborts.QuickOpenFile	// QuickOpenFile(Name,ksType,Item) first searches table		// of fp's for Name.  If found, opens file quickly with fp,		// else opens with OpenFile.StartCmdOverlayQuitCmdOverlay	// QuitCmdOverlay() is called by an overlay which		// has been called by a cmd menu item using 		// StartCmdOverlay.CmdAbort	// Routine used to abort command overlays invoked by		// control-C.FormCmdmenuText	// Procedure arg for FormMenu when a command overlay		// is rebuilding command menu.//MOSUTILSWss,Wns,Wos	// These routines defined--stripped version of OSUTILS.//MX		Resident hardware interface procedures		// Procedures below accept arguments of the		// following types:		//		//	DVec	Microprocessor data, multi word,		//		packed left justified, as in Micro		//		format.		//		//	AVec	a double precision memory address vectorPutMemData	// PutMemData(MemX,AVec,DVec) stores DVec in 		// memory MemX address AVecMPutMemData	// PutMemData(...), dirty display, and restore incidentally		// clobbered registers.GetMemData	// GetMemData(MemX,AVec,DVec) fetches data from AVec in		// MemX, stores the result in DVecMGetMemData	// GetMemData(...) and restore incidentally clobbered		// registers.PutRegData	// PutRegData(RegX,DVec) stores DVec into register RegXMPutRegData	// PutRegData(...), dirty display, and restore incidentally		// clobbered registers.GetRegData	// GetRegData(RegX,DVec) fetches register RegX into DVecMGetRegData	// GetRegData(...), restore incidentally clobbered		// registers, and dirty display.ReadAllRegs()	// Reads and saves much of machine state.  Called after		// changing registers and after halting.RestoreAfterLoad()	// Restores registers clobbered incidentally during		// loading of memories from .MB files by PutMemData.InsertBreak(Addr)	// Inserts breakpoint at IM address AddrRemoveBreak(Addr)	// Removes breakpoint at IM address Addr (at IMA		// if no argument)SingleStepM(Addr)	// Single-step microprocessor at Addr (at IMA-NPC		// if no argument passed).StartM(Addr)	// Start microprocessor at IMA = Addr, NPC = Addr+1 (at		// current IMA-NPC if no argument passed).  Returns a		// command menu procedure.ProcOnTest()	// Returns true if hardware cannot be loaded (e.g., power		// off) else true--called from mload.bcplInitHardware()	// Initialize hardware after other Midas initializationFinishHardware()	// Routine called before Midas exit to OS.//MINIT0	PostJunta first init.  Includes MINIT0, MDI, OVERLAYSINIT,//		MXI0, LOADRAM, MAXCALTOCODE23//		Flushed after execution.Init0		// Rebuilds sysZone, loads special Alto microcode,		// initializes allocator, checks auxiliary		// Midas files creating or giving errors for ones that don't		// exist.  If Midas/I does full init, else RestoreState.		// Code for Init0 is flushed later in init.//MINIT1	PostJunta second init (only called on Midas/I)Init1		// Continues initialization begun by Init0.NewRegion	// NewRegion(blocksize, father, rlx, rcx, Height, Width,		//		pPaint, PSelect, PMchange, PdeSelect)		// returns a new region, with the basic regions		// parameters initialized.  its father will be as		// specified, and the new region will be spliced at the		// end of the brother chain of sons.  blocksize is for		// the total region including the basic region.  Space is		// obtained using GetStorage.MakeMenuRegion	// MakeMenuRegion(Letter,LineN, rlx, rcx, H, W, MaxH, MaxW, 		//	MaxNItems, Arg, PdeSelect)		//		// creates a menu region, where:		//	Letter = letter part of menu name for comfiles		//	LineN = line number part of menu name for comfiles		//	rlx, rcx, H, W  give initial shape to the region		//	MaxH, MaxW	limits max future values		//	MaxNItems	maximum num menu items		//			//	PFormText should be proceded by:		//		Resets(S, Father, rlx, rcx, H, W)		//		Wss(S, ...); Marks(S, Act1)		//		Wss(S, text2); Marks(S, Act2)		//		etc.		//		where Texti is the text of item i		//		and Acti is the result of a previous		//		call to CreateAction.  The procedure		//		named in Acti will be called if itemi is		//		"bugged".  rlx, rcx, H, W should be new 		//		values for these properties of the		//		menu region, or old values.		//		If P1 is the procedure in Acti, then		//		Pi will be called (when bugged) as		//		  Pi(S, Argi, MBUnion, Arg2)		//			where		//			S is the stream of the menu		//			Arg1 is the original argument		//			   in the call that created 		//			    the menu.		//			Arg2 is the arg in the call		//			   which created Acti.		//		Acti = 0 is allowed, and the		//		item will never be selected.		//		Wss can be any thing that 		//		results in a series of Puts calls.		//		//	PSelect(S, Arg) will be called when the menu		//	region is selected.		//		//	PdeSelect(S, Arg) will be called when the menu		//	region is deselected.		//		//	these last two routines may call Reset(S)		//	to restructure the menu. In this case, 		//	PFormText will be called.		//		// Space is obtained using GetStorage, using Zone as a		// parameter. If zone not supplied, then 0 is used in		// call to GetStorage.DefineMemory	// DefineMemory(String,MemX,BitWidth,Hsize,Size)		// defines a memory.  String is the bcpl string name of		// the memory.  MemX is the internal memory number,		// used in the hardware interface to the microprocessor.		// BitWidth is the width of a single word in bits. Size 		// is  the number of words (of size BitWidth) in the		// memory.  Hsize is the high part of Size (0 unless		// more than 64K words in memory).DefineRegister	// DefineRegister(String,RegX,BitWidth)		// defines a register.  String is the bcpl string name		// of the register.  RegX is the internal register		// number, used in the hardware interface to the		// microprocessor.  BitWidth is the number of bits		// in the register.NewMPDispBlock	// NewMPDispBlock(L,C,Cnm,W) must be called to initialize		// each register display block (see InitMPInterface later)//MXIInitMPInterface	// InitMPInterface(), called by Init1,		// is expected to perform following calls:		//		// for each register to be defined:		//	DefineRegister(StringName,RegX,BitWidth)		//		// for each Memory to be defined:		//	DefineMemory(StringName,MemX,BitWidth,Hsize,Size)		//		// for each display block to be placed on the screen:		//	NewMPDispBlock(L, C, Cnm, W)//***OVERLAYS BEGIN HERE***//*INIT2* overlay//MINIT2	PostJunta second init loaded into the normal overlay zone//		constructed from the display bit buffers.Init2		// Init2() completes Midas initialization.//*INIT3* overlay//MINIT3Init3		// Does final display and region initialization, then		// parses Com.CM in preparation for doing a Read-Cmds.		// It returns true if Read-Cmds should be done.//*LOADER overlay*//MLOADInitLoad	// InitLoad(lvProc) brings in loader overlay and		// invokes lvProc (= LoadMB, LoadSyms, DumpMB, or		// MBCompare) after initialization.LoadMB		// Loads files specified by input textLoadSyms	// Loads symbols onlyDumpMB		// Dumps microprocessor state on .MB file specified		// by input text under control of .MB files used for		// previous MBLoad or MBSyms.MBCompare	// Compares microprocessor state against .MB file		// where .MB file must have been created by MBDump//*MICTST overlay* not documented here//*POWER overlay*MicGo		// MicGo() called from Cmd for power onMicStop		// MicStop() called from Cmd for power off//   external statics of Midas//MIDASInitializingZone // non-zero during Init1 only--the zone where the		// Init1 overlay is put.// MASMAbortLabel	// Statics used by ErrorProtect and DisplayErrorAbortFrame//MDISP@NewMB		//Mouse buttons left by GetMouseAndCursor@NewLx		//Cursor line index@NewCx		//Cursor character indexVertIntFlag	// Referenced in MASMNwdsPerScanLineFontP//MRGNScreenTextLines	// vector of textvecs for each line,		// used by GetMouseAndCursor in mdispFinishFlag	// any routine can force a finish at end of main loop		// by setting this flag = true//MTXTBUFInputTextBuffer	// a text vec containing typed in textInputTxtRgn	// Display region for input text//MOVERLAYOverlayZone	// Zone from which overlay space was obtained, can		// be used for space by the overlay code, so long as		// all use terminated when overlay flushedOverlayBusy	// True if an overlay is loaded else false.//MCMDCmdCommentStream	// a stream in which to write comments		// for display on screenTextCmdOutStream	// if non zero, a stream on which menu should		// write logical actionsShowActionForm	// if true, then menu should commment the 		// current logical actionSavedLoadText	// 73 word vector retaining file names of last load		// for use by subsequent DumpLoadDone	// True to enable the "Dump" action (after a previous load)ProgramStream	// One text-line stream between the register display and		// the command comment line on which the name of the		// last program loaded is displayed.CmdAltMenuP	// Non-zero if an alternate command menu is up (needed by		// TxtBNewChar to check for whether or not type-ahead is		// legal.//MINIT0MidasFP		// FP for Midas.run (Needed by overlay package)BlockStoreFP	// FP for Midas.SymTab (Alphabetically sorted symbol table)MidasRFP	// FP for Midas.Resume (state of Midas after init)mdsInitFP	// FP for Midas.MidasAltIOFP		// FP for AltIO.runFixUpFP		// FP for Midas.Fixups (temporary file during loading)ErrsFP		// FP for Midas.Errors (output of Compare action)//MINIT1ScreenHeight	// Number of lines in display (Due to bug it is two		// lines greater than that at present.)ScreenWidth	// Number of characters per screen line