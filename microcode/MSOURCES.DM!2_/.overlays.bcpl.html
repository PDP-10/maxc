<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>MSOURCES.DM!2>overlays.bcpl</title>
  </head>
  <body>
    <pre>
//// OVERLAYS.BCPL - Bcpl overlay package// last edited September 16, 1976  6:19 PM//	get "overlays.d"	get "altofilesys.d"	get "disks.d"external	// procedures used[		// O.S.	SetBlock	ActOnDiskPages	Usc	Dvec	CallSwat		// User-supplied	UserReadOverlay]external	// statics used[	sysDisk]external	// procedures defined[	LockPendingCode	// ()	FindOverlayFromPn	// (pn) -&gt; od	GeneratePresentOverlays	// (proc(od))	@OverlayFaultProc	DeclareOverlayPresent	// (od, core)	OverlayFirstPn	// (od) -&gt; pn	OverlayNpages	// (od) -&gt; npages	OverlayDiskAddr	// (od) -&gt; da	OverlayCoreAddr	// (od) -&gt; core	ReadOverlay	// (pn, core, npages)	ReleaseOverlay	// (od, doIt) -&gt; ok]external	// statics defined[	@OverlayNumber	OverlayFaults	FirstOD	LastOD	OverlayFp]static[	@OverlayNumber = 0	OverlayFaults	FirstOD	LastOD	OverlayFp	MinOverlayLoc = -1]let LockPendingCode(dummy) be[	for od = FirstOD by ODsize to LastOD do od&gt;&gt;OD.onstack = 0	let frame = (lv dummy)!-4	while Usc(@frame, frame) gr 0 do	 [ let pc = frame!1	   if Usc(pc, MinOverlayLoc) ge 0 then	// O.S. or overlay	    for od = FirstOD by ODsize to LastOD do	     if (od&gt;&gt;OD.core ne 0) &amp; ((pc-od&gt;&gt;OD.core) rshift 8 ls (od+ODsize)&gt;&gt;OD.firstPn-od&gt;&gt;OD.firstPn) then	      od&gt;&gt;OD.onstack = 1	   frame = @frame	 ]]and FindOverlayFromPn(pn) = valof[	let fpn = FirstOD&gt;&gt;OD.firstPn	for od = FirstOD by ODsize to LastOD do	 [ let npn = (od+ODsize)&gt;&gt;OD.firstPn	   if (pn ls npn) &amp; (pn ge fpn) resultis od	   fpn = npn	 ]	CallSwat("FindOD failed")]and GeneratePresentOverlays(proc) be	for od = FirstOD by ODsize to LastOD do	   if od&gt;&gt;OD.core ne 0 then proc(od)and OverlayFaultProc(ac0, ac1, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil, nil) = valof[	// *** Critical code began at JSR to missing procedure	let ovn = OverlayNumber	OverlayNumber = 0	// *** End critical code	let od = LastOD-ovn*ODsize	DeclareOverlayPresent(od, UserReadOverlay(od))	// Check to make sure overlay is now present	let callerframe = (lv ac0)!-4	let callerpc1 = callerframe!1	let callins = callerpc1!-1	let disp = (callins&amp;#177)-(callins&amp;#200)	let dif = (selecton (callins&amp;#177400) into	 [ case #64400: callerpc1!(disp-1)	// JSRII	   case #65000: callerframe!disp	// JSRIS	   case #6000: callins&amp;#377	// JSR @	   default: lv OverlayFaults	// no good	 ])!0-OverlayFaults	if (dif ge 0) &amp; (dif le (LastOD-FirstOD)/ODsize) then	   CallSwat("Bad overlay call")	// Re-execute call	callerframe!1 = callerpc1-2	resultis table[ #1401 ](ac0, ac1)	// load up ACs and exit]and DeclareOverlayPresent(od, base) be[	if Usc(base, MinOverlayLoc) ls 0 then MinOverlayLoc = base	let p = base+#21+base!1	let plim = p+2*p!-1	while p ne plim do	 [ @(p!0) = base+#20+p!1	   p = p+2	 ]	od&gt;&gt;OD.core = base]and OverlayFirstPn(od) = od&gt;&gt;OD.firstPnand OverlayNpages(od) = (od+ODsize)&gt;&gt;OD.firstPn-od&gt;&gt;OD.firstPnand OverlayDiskAddr(od) = od&gt;&gt;OD.daand OverlayCoreAddr(od) = od&gt;&gt;OD.coreand ReadOverlay(pn, core, np) be[	let DAs, CAs = np, np	Dvec(ReadOverlay, lv DAs, lv CAs)	for i = 0 to np-1 do CAs!i = core + i lshift 8	SetBlock(DAs, fillInDA, np+1)	DAs!0 = FindOverlayFromPn(pn)&gt;&gt;OD.da	ActOnDiskPages(sysDisk, CAs-pn, DAs-pn, OverlayFp, pn, pn+np-1, DCreadD)]and ReleaseOverlay(od, flag) = valof[	if od&gt;&gt;OD.onstack ne 0 resultis false	unless flag resultis true	let faultaddr = OverlayFaults+(od-FirstOD)/ODsize	let base = od&gt;&gt;OD.core	let p = base+#21+base!1	let plim = p+2*p!-1	while p ls plim do	 [ @(p!0) = faultaddr	   p = p+2	 ]	od&gt;&gt;OD.core = 0	resultis true]</pre>
  </body>
</html>
