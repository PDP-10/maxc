<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[Indigo]&lt;Maxc>MSOURCES.DM!2>mioc.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">//MIOC.BCPL<br><br>get "mdecl.d"<br><br>external [<br>// OS<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Puts; Zero<br><br>// MIDAS<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">PutField; GetField<br><br>// MSYM<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">EvalAText<br><br>// MCMD<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">DisplayError<br><br>// Machine Dependent<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">@MEMFORMS; @REGFORMS; @REGWID; @MEMWID; AltRForms; AltMForms<br><br>// Defined here<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">RTexttoData; MTexttoData; SimpleTexttoDVec<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">RDatatoStream; MDatatoStream; SimpleDVectoStream<br>]<br><br>//Subroutines for converting TextVec&rsquo;s to DataVec&rsquo;s.<br>//RTexttoData(RegX,TextVec,DataVec) and MTexttoData(RegX,TextVec,DataVec)<br>//convert a TextVec to a DataVec where the width is gotten from the table<br>//of register widths or of memory widths, respectively.  These routines<br>//use SimpleTexttoDVec(TextVec,NBits,DataVec) to do the work.<br><br>//GenlTexttoDVec(TextVec,Form,DataVec) is not presently used.<br><br>let RTexttoData(RegX,TV,DVec) be SimpleTexttoDVec(TV,REGWID!RegX,DVec)<br><br><br>and MTexttoData(MemX,TV,DVec) be SimpleTexttoDVec(TV,MEMWID!MemX,DVec)<br><br><br>and SimpleTexttoDVec(TV,NBits,DVec) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let Bit1 = NBits-3<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Zero(DVec,(NBits+15) rshift 4)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if TV!0 eq 0 then return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = TV!0 to 1 by -1 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ let X = TV!I<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if X ne $  do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ if (X &lt; $0) % (X &gt; $7) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    [ Zero(DVec,(NBits+15) rshift 4)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      let AVal = vec size AVal/16; X = 1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      if EvalAText(TV,lv X,AVal,false) then<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      [ if AVal&gt;&gt;AVal.TypeStorage eq MemTypeStorage do<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif"> [ let SBit1,DBit1,MBits = nil,nil,nil<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">   test NBits ge 32<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">   ifso [ SBit1,DBit1,MBits = 0,NBits-32,32 ]<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">   ifnot [ SBit1,DBit1,MBits = 32-NBits,0,NBits ]<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">   MoveLongField(lv AVal&gt;&gt;AVal.Addr,SBit1,MBits,DVec,DBit1)<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">   return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">        ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      DisplayError("Bad value")<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    test Bit1 &lt; 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    ifso<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    [ let T = Bit1+3; if T &gt; 0 then<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      PutField(0,T,DVec,(X-$0) & (table [ 1; 3; 7 ] !T))<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">      return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    ifnot [ PutField(Bit1,3,DVec,X-$0); Bit1=Bit1-3 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br>]<br><br>//and GenlTexttoDVec(TV, Form, DVec) be<br>//[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let Field,Ngrps,InGap = vec 5,0,true<br>//Count the groups<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = 1 to TV!0 do<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  test InGap<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">    ifso<br>//</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">if TV!I ne $   then<br>//</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ InGap = false; Ngrps = Ngrps+1 ]<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">    ifnot<br>//</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">if TV!I eq $   then InGap = true<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">if Ngrps &gt; Form!0 then Ngrps = Form!0<br><br>// now put out initial missing groups<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">let FormX = 1<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">Zero(Field,6)<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = 1 to Form!0 - Ngrps do<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">[ MoveLongField(Field,0,Form!(FormX+1),DVec,Form!FormX)<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  FormX = FormX+2<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br><br>// now handle groups with text<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">let TVX = 1<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = Form!0-Ngrps+1 to Form!0 do<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">[ let TempTV = vec 30<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  while TV!TVX eq $   do TVX = TVX+1<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  let X = 0<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  while TV!TVX ne $  logand TVX le TV!0 do<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ X = X+1<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">    if X le 30 then TempTV!X = TV!TVX<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">    TVX = TVX+1<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  ]<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  TempTV!0 = X<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  SimpleTexttoDVec(TempTV, Form!(FormX+1), Field)<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  MoveLongField(Field,0,Form!(FormX+1),DVec,Form!FormX)<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">  FormX = FormX+2<br>//</span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br>//]<br><br>//RDatatoStream(Stream,RegX,DataVec) and MDatatoStream(Stream,MemX,DataVec)<br>//are used, respetively, for outputting register values and memory values<br>//to a stream.  The format table for the register or memory is obtained<br>//from REGFORMS or MEMFORMS.  If this is 0, then SimpleDVectoStream is<br>//used to output a right-justified octal string with leading blank fill<br>//of a size equal to the width of the register/3.  If the REGFORMS or<br>//MEMFORMS entry is not 0, then GenlDVectoStream is used to do the work.<br><br>//GenlDVectoStream accepts a format table whose first entry is the<br>//number of format groups.  This is followed by pairs of integers<br>//which stand for the left-bit in the DataVec for a group and the<br>//number of bits in the group.<br><br>//SimpleDVectoStream accept a fill character as its last argument.<br>//If this character is 0, then no fillers are output for leading zeroes<br>//in the output.  The value of the output is the original fill character<br>//if all of the NBits are 0; otherwise it is 60B = "0".  If the fill<br>//character is 40B = " ", then blank fill is used; if 60B = "0" then<br>//0-fill is used.<br><br>//Note:  Leading blanks must be suppressed for mmprgn.bcpl<br><br><br>and RDatatoStream(Stream,RegX,DVec) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">test REGFORMS!RegX eq 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ifso RegX = SimpleDVectoStream(Stream,REGWID!RegX,DVec,0,true)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ifnot GenlDVectoStream(Stream,REGFORMS!RegX,DVec)<br>]<br><br>and MDatatoStream(Stream,MemX,DVec) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">test MEMFORMS!MemX eq 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ifso MemX = SimpleDVectoStream(Stream,MEMWID!MemX,DVec,0,true)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ifnot GenlDVectoStream(Stream,MEMFORMS!MemX,DVec)<br>]<br><br>and SimpleDVectoStream(Stream,NBits,DVec,flush0,LastFlag) = valof<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let Bit1,Size1,Byte = 0,NBits rem 3,nil<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if Size1 eq 0 then Size1 = 3<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">while Bit1 &lt; NBits-3 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ Byte = GetField(Bit1,Size1,DVec)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if Byte ne 0 then flush0 = $0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if flush0 ne 0 then Puts(Stream,Byte+flush0)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  Bit1 = Bit1+Size1; Size1 = 3<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Byte = GetField(Bit1,Size1,DVec)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if Byte ne 0 then flush0 = $0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if (flush0 ne 0) % LastFlag then Puts(Stream,Byte+$0)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">resultis flush0<br>]<br><br>and MoveLongField(Source,SBit1,NBits,Dest,DBit1) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">while NBits ge 16 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ PutField(DBit1,16,Dest,GetField(SBit1,16,Source))<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  DBit1,SBit1,NBits = DBit1+16,SBit1+16,NBits-16<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if NBits &gt; 0 then<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  PutField(DBit1,NBits,Dest,GetField(SBit1,NBits,Source))<br>]<br><br>and GenlDVectoStream(Stream,Form,DVec) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let Field,Foo,flush0 = vec 5,(Form!0)+(Form!0)-1,0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">for FormX = 1 to Foo by 2 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ if (FormX &gt; 1) & (flush0 ne 0) then Puts(Stream,$ )<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  MoveLongField(DVec,Form!FormX,Form!(FormX+1),Field,0)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  flush0 = SimpleDVectoStream(Stream,Form!(FormX+1),Field,<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">flush0,((FormX eq Foo) ? true,false))</span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span class="tab" val="63"></span><span style="font: 10pt serif">]<br>]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
