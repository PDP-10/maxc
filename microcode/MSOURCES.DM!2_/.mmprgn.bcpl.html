<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>[Indigo]&lt;Maxc>MSOURCES.DM!2>mmprgn.bcpl</title>
  </head>
  <body>
    <div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif">//mmprgn.bcpl<br><br>get "mdecl.d"<br><br>external [<br>// OS<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Wss; Wns; Resets; Puts; CallSwat; Noop; DoubleAdd; MoveBlock; Zero<br><br>// MASM<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">StrSize; ErrorProtect<br><br>// MDISP<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Blink<br><br>// MRGN<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">CharInputRoutine<br><br>// MIOC<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">RTexttoData; MTexttoData; RDatatoStream; MDatatoStream<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SimpleDVectoStream; SimpleTexttoDVec<br><br>// MMENU<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">CreateAction; MarkMenus; ItemStream; FormMenu<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SkipCommandCount<br><br>// MSYMB<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">EvalAText; TVtoString; SearchBlocks<br><br>// MTXTBUF<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">InputTextBuffer<br><br>// MCMD<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">CmdCommentStream; DisplayError; WsMarkA; WssCSS<br><br>// Machine interface<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MGetRegData; MGetMemData; MPutRegData; MPutMemData; @MEMNAM<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">AltRForms; AltMForms<br><br>// Defined here<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDSwitchPhase; DoubleNeg; ShowAddr; ShowBadAddr<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">@LongOne; LongMinOne<br><br>// Defined here for init only<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDAs; MPDAVec; MPDVs; MPDVVec; MPDEveryTime<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDlist; InitMPDispRegions; MPDdeSelect<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDrlx; MPDrcx; BugAddrAct; BugValAct; Plus1Act; Minus1Act<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SkipVEql; SkipVGr; SkipVLs<br>]<br><br><br>manifest [<br>//  form of the menu<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">StandardMenu = 1; AddressMenu = 2<br><br>//  Phases<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">BadValuePhase = 1; PhaseA = 2; PhaseB = 3<br><br>// mouse buttons<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">TopButton = #4; MiddleButton = #1; BottomButton = #2<br>]<br><br><br>static</span><span class="tab" val="63"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDAs; MPDAVec; MPDVs; MPDVVec<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDPhase = PhaseA; OldMPDPhase = PhaseA<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDrlx = 0; MPDrcx = 0; MPDlist = 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">@LongOne; LongMinOne<br><br>//  Actions<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">BugAddrAct; BugValAct; Plus1Act; Minus1Act<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br><br>let InitMPDispRegions() be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">LongOne = table [ 0; 1 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">LongMinOne = table [ -1; -1 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">BugAddrAct = CreateAction("Addr",lv SetAddr,0,lv AddrMChange)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">BugValAct = CreateAction("Val",lv SetValue,0,lv ValMChange)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Plus1Act = CreateAction("A+1",lv StepAddr,true,lv AddrMChange)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Minus1Act = CreateAction("A-1",lv StepAddr,false,lv AddrMChange)<br>]<br><br><br>and MPDSwitchPhase() be MPDPhase = ( OldMPDPhase eq PhaseA? PhaseB, PhaseA)<br><br><br>//This routine is called every time through DriverLoop.  It is<br>//responsible for repainting all of the MPD menus which have changed.<br>//The various action routines and the initialization code set<br>//phase = BadValuePhase which forces painting.  The microprocessor<br>//interface code reverses the current phase which causes only those<br>//items with changed values to paint<br>and MPDEveryTime(MPD,BuildingDisplay; numargs NA) be<br>[ while MPD ne 0 do<br>  [ if MPDPhase ne MPD&gt;&gt;MPD.Phase then<br>    [</span><span class="tab" val="63"></span><span style="font: 10pt serif">test MPD&gt;&gt;MPD.Idle ne 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifso if MPD&gt;&gt;MPD.Phase eq BadValuePhase then<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">FormMenu(MPD&gt;&gt;MPD.MDFS,FormMPDmenu,MPD)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifnot<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ let Val = vec ValSize; MoveBlock(Val,lv MPD&gt;&gt;MPD.Value,ValSize)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  switchon MPD&gt;&gt;MPD.AVal.TypeStorage into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [<br>  case RegTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    MGetRegData(MPD&gt;&gt;MPD.AVal.X,lv MPD&gt;&gt;MPD.Value); endcase<br><br>  case MemTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    MGetMemData(MPD&gt;&gt;MPD.AVal.X,lv MPD&gt;&gt;MPD.AVal.Addr,lv MPD&gt;&gt;MPD.Value)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    endcase<br><br>  default:  CallSwat()<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if ((MPD&gt;&gt;MPD.MenuMode eq StandardMenu) & valof<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ for I = 0 to ValSize-1 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    [ if Val!I ne (lv MPD&gt;&gt;MPD.Value)!I then resultis true ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    resultis false<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ] ) % (MPD&gt;&gt;MPD.Phase eq BadValuePhase) % (NA &gt; 1) then<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">FormMenu(MPD&gt;&gt;MPD.MDFS,FormMPDmenu,MPD)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPD&gt;&gt;MPD.Phase = MPDPhase<br>    ]<br>    MPD = MPD&gt;&gt;MPD.Rabove<br>  ]<br>  OldMPDPhase = MPDPhase<br>]<br><br>and FormMPDmenu(S, MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">if MPD&gt;&gt;MPD.Idle ne 0 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ for I = 1 to MPD&gt;&gt;MPD.TextSpace do Puts(S,$ )<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  MarkMenus(BugAddrAct); return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">switchon MPD&gt;&gt;MPD.MenuMode into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[<br>case StandardMenu: ShowMPDNormalPict(S, MPD); return<br><br>case AddressMenu:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">test MPD&gt;&gt;MPD.AVal.TypeStorage ne RegTypeStorage<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifso<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ WsMarkA(Plus1Act)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if ((lv MPD&gt;&gt;MPD.AVal.Addr)!0 ne 0)  logor<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">((lv MPD&gt;&gt;MPD.AVal.Addr)!1 ne 0) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ WsMarkA(Minus1Act) ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifnot ShowMPDNormalPict(S,MPD)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br>]<br><br><br>and ShowOffset(S,MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let Offs = lv MPD&gt;&gt;MPD.AVal.Offset<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let Sign = MPD&gt;&gt;MPD.AVal.Sign<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if (Offs!0 ne 0) % (Offs!1 ne 0) % (Sign eq 0) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ Puts(S,(Sign ne 0 ? (Offs!0 &lt; 0 ? $-,$+),$ ))<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  let Offset = vec 1; MoveBlock(Offset,Offs,2)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if Offset!0 &lt; 0 then DoubleNeg(Offset)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  SimpleDVectoStream(S,32,Offset,0,true)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br>]<br><br><br>and ShowBadAddr(Str; numargs NA) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">WssCSS((NA &lt; 1 ? "Bad address",Str)); Blink()<br>]<br><br>and ShowMPDNormalPict(S, MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">Resets(MPDAs); Resets(MPDVs)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if MPD&gt;&gt;MPD.NoName eq 0 then Wss(MPDAs, lv MPD&gt;&gt;MPD.AVal.SName)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">switchon MPD&gt;&gt;MPD.AVal.TypeStorage into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">case RegTypeStorage:<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">RDatatoStream(MPDVs,MPD&gt;&gt;MPD.AVal.X,lv MPD&gt;&gt;MPD.Value)<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">endcase<br><br></span><span class="tab" val="63"></span><span style="font: 10pt serif">case MemTypeStorage:<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">if MPD&gt;&gt;MPD.NoName eq 0 then ShowOffset(MPDAs,MPD)<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">MDatatoStream(MPDVs,MPD&gt;&gt;MPD.AVal.X,lv MPD&gt;&gt;MPD.Value)<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">endcase<br></span><span class="tab" val="63"></span><span style="font: 10pt serif"><br></span><span class="tab" val="63"></span><span style="font: 10pt serif">default: CallSwat()<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br><br>//If the name and value do not fill the text space available, the<br>//code below leaves a null zone no bigger than 2 chars between them.<br>//If the name is less than 5 characters, extra blanks extend the name<br>//up to 5 characters.  Any more blanks beyond that extend the value.<br>//If the value overlaps the name, then the name is truncated except that<br>//one character of name is always printed (unless the NoName flag is set,<br>//in which case no name characters are ever printed).<br>//Note:  DVtoS routines never print leading 0&rsquo;s and blanks<br><br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let ALim = MPDAVec!0</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">//Size of name<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let BlankSpace = MPD&gt;&gt;MPD.TextSpace - ALim - MPDVVec!0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let VStart = 1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if BlankSpace &lt; 0 do</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">//Overlap?<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ ALim = ALim + BlankSpace</span><span class="tab" val="63"></span><span style="font: 10pt serif">//Then truncate name<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  BlankSpace = 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if ALim &lt; 0 do</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">//Name completely overlapped?<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ VStart = 1 - ALim; ALim = 0 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">test MPD&gt;&gt;MPD.NoName ne 0<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifso [ BlankSpace = BlankSpace+ALim; ALim = 0 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifnot</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">//Extend name up to 5 chars<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ if ALim le 0 do [ ALim = 1; VStart = VStart+1 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  for I = 1 to ALim do Puts(S,MPDAVec!I)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  while (BlankSpace &gt; 2) & (ALim &lt; 5) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ Puts(S,$ ); BlankSpace = BlankSpace-1; ALim = ALim+1 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  MarkMenus(BugAddrAct)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if BlankSpace &gt; 0 do</span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">//But leave gap if possible<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">//2 char gap if value big enough<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [ Puts(S,$ ); BlankSpace = BlankSpace-1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    if (BlankSpace &gt; 0) & ((MPDVVec!0 + BlankSpace) ge 5) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    [ Puts(S,$ ); BlankSpace = BlankSpace-1 ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">    MarkMenus(0)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = 1 to BlankSpace do Puts(S, $ )</span><span class="tab" val="63"></span><span style="font: 10pt serif">//Rest of blanks extend value<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = VStart to MPDVVec!0 do Puts(S, MPDVVec!I)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MarkMenus(BugValAct)<br>]<br><br>and MPDMChange(TopMenuMode,MiddleMenuMode,BottomMenuMode,MPD,MB) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let NewMode = selecton MB into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[<br>case TopButton: TopMenuMode<br>case MiddleButton: MiddleMenuMode<br>case BottomButton: BottomMenuMode<br>default: StandardMenu<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if MPD&gt;&gt;MPD.MenuMode ne NewMode do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ MPD&gt;&gt;MPD.MenuMode = NewMode; MPD&gt;&gt;MPD.Phase = BadValuePhase ]<br>]<br><br><br>and AddrMChange(S, MPD, MB, N) be<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDMChange(StandardMenu,StandardMenu,AddressMenu,MPD,MB)<br><br><br>and ValMChange(S, MPD, MB, N) be<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPDMChange(StandardMenu,StandardMenu,StandardMenu,MPD,MB)<br><br><br>and GetVal(S,MPD,V1,V2) = valof<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">SimpleTexttoDVec(InputTextBuffer,ValSize*16,V1)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SetValue(S,MPD,BottomButton)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SimpleTexttoDVec(InputTextBuffer,ValSize*16,V2)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">for I = 0 to ValSize-1 do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ let X = V1!I - V2!I<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  if X ne 0 then resultis X<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">resultis 0<br>]<br><br><br>//Invisible command (command files only)--skip if value in selected<br>//menu is equal to InputTextBuffer<br>and SkipVEql(S,MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let V1,V2 = vec ValSize-1,vec ValSize-1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if GetVal(S,MPD,V1,V2) eq 0 then SkipCommandCount = 1<br>]<br><br><br>//Skip next command if value in selected menu is greater than text arg<br>and SkipVGr(S,MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let V1,V2 = vec ValSize-1,vec ValSize-1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if GetVal(S,MPD,V1,V2) &lt; 0 then SkipCommandCount = 1<br>]<br><br><br>and SkipVLs(S,MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let V1,V2 = vec ValSize-1,vec ValSize-1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if GetVal(S,MPD,V1,V2) &gt; 0 then SkipCommandCount = 1<br>]<br><br>and SetAddr(S,MPD,MBunion) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">NewStandard(MPD)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let X,AVal = 1,vec size AVal/16<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if ((MBunion & MiddleButton) ne 0) & (MPD&gt;&gt;MPD.Idle eq 0) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ ShowAddr(lv MPD&gt;&gt;MPD.AVal); return ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPD&gt;&gt;MPD.Idle = 1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if InputTextBuffer!0 eq 0 then return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">unless EvalAText(InputTextBuffer, lv X, AVal, false) do<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ ShowBadAddr(); return ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MoveBlock(lv MPD&gt;&gt;MPD.AVal,AVal,size AVal/16)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">switchon MPD&gt;&gt;MPD.AVal.TypeStorage into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[<br>case MemTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if not MGetMemData(MPD&gt;&gt;MPD.AVal.X,lv MPD&gt;&gt;MPD.AVal.Addr,<br></span><span class="tab" val="63"></span><span class="tab" val="63"></span><span style="font: 10pt serif">lv MPD&gt;&gt;MPD.Value) do [ ShowBadAddr(); return ]<br>case RegTypeStorage: endcase<br>default: CallSwat()<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">MPD&gt;&gt;MPD.Idle = 0<br>]<br><br><br>//The +1 and -1 menu items only come up when they are legal, but<br>//maybe the error checks here will be useful if keyboard stuff is added<br>and StepAddr(S, MPD, MBUnion, Sign) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let AVec = vec 1; MoveBlock(AVec,lv MPD&gt;&gt;MPD.AVal.Addr,2)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">DoubleAdd(AVec,(Sign ? LongOne,LongMinOne))<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let DVec = vec 10<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">test MGetMemData(MPD&gt;&gt;MPD.AVal.X,AVec,DVec)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifso<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ MoveBlock(lv MPD&gt;&gt;MPD.AVal.Addr,AVec,2)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  DoubleAdd(lv MPD&gt;&gt;MPD.AVal.Offset, (Sign ? LongOne, LongMinOne))<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  NewStandard(MPD)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">ifnot ShowBadAddr() <br>]<br><br><br>and ShowAddr(AVal) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">switchon AVal&gt;&gt;AVal.TypeStorage into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[<br>case RegTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">WssCSS("Register ")<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Wns(CmdCommentStream,AVal&gt;&gt;AVal.X,0,10)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">endcase<br>case MemTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">WssCSS(MEMNAM!(AVal&gt;&gt;AVal.X))<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Puts(CmdCommentStream,$ )<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SimpleDVectoStream(CmdCommentStream,32,lv AVal&gt;&gt;AVal.Addr,0,true)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">WssCSS(" = ")<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">SearchBlocks(CmdCommentStream,AVal&gt;&gt;AVal.X,lv AVal&gt;&gt;AVal.Addr)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br>]<br><br>//TopButton going up evaluates input text and stores value.<br>//MiddleButton going up shows alternate value form on command comment line.<br>//BottomButton going up treats the value as input text.<br>and SetValue(S, MPD, MBunion) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">let X = MPD&gt;&gt;MPD.AVal.X</span><span class="tab" val="63"></span><span style="font: 10pt serif">//= RegX or MemX<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">let Value,TypeS = lv MPD&gt;&gt;MPD.Value,MPD&gt;&gt;MPD.AVal.TypeStorage<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if (MBunion & TopButton) ne 0 do</span><span class="tab" val="63"></span><span style="font: 10pt serif">//Set value from InputTextBuffer<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ switchon TypeS into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [<br>  case RegTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  RTexttoData(X,InputTextBuffer,Value)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  MPutRegData(X,Value); endcase<br><br>  case MemTypeStorage:<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  MTexttoData(X,InputTextBuffer,Value)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  MPutMemData(X,lv MPD&gt;&gt;MPD.AVal.Addr,Value); endcase<br><br>  default: CallSwat(); endcase<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  NewStandard(MPD); return<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if (MBunion & BottomButton) ne 0 do</span><span class="tab" val="63"></span><span style="font: 10pt serif">//Append to InputTextBuffer<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ Resets(MPDVs); switchon TypeS into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [<br>case RegTypeStorage: RDatatoStream(MPDVs,X,Value); endcase<br>case MemTypeStorage: MDatatoStream(MPDVs,X,Value); endcase<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  for I = 1 to MPDVVec!0 do CharInputRoutine(MPDVVec!I)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">if (MBunion & MiddleButton) ne 0 do</span><span class="tab" val="63"></span><span style="font: 10pt serif">//Alternate printout<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">[ Resets(CmdCommentStream)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ErrorProtect((selecton TypeS into<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  [<br>case RegTypeStorage: AltRForms<br>case MemTypeStorage: AltMForms<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">  ] )!X ,CmdCommentStream,X,Value,lv MPD&gt;&gt;MPD.AVal.Addr)<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">]<br>]<br><br><br>and MPDdeSelect(MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">if MPD&gt;&gt;MPD.MenuMode ne StandardMenu do NewStandard(MPD)<br>]<br><br><br>and NewStandard(MPD) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">MPD&gt;&gt;MPD.MenuMode = StandardMenu; MPD&gt;&gt;MPD.Phase = BadValuePhase<br>]<br></span></div>
<div style="width: 442pt; margin-left: 84pt; margin-top: 0pt; text-align: left">
<span style="font: 10pt serif"><br>and DoubleNeg(Ptr) be<br>[</span><span class="tab" val="63"></span><span style="font: 10pt serif">Ptr!1 = - Ptr!1<br></span><span class="tab" val="63"></span><span style="font: 10pt serif">Ptr!0 = (not Ptr!0)+(Ptr!1 eq 0 ? 1,0)<br>]<br></span></div>
<script>function do_tabs() { // unit = px
  var tabs = document.getElementsByClassName("tab");
  for (var i = 0; i < tabs.length; ++i) {
    var span = tabs[i];
    var val = span.getAttribute("val");
    if (val == null) console.log("Couldn't get val");
    var rect = span.getBoundingClientRect();
    var tabstop;
    if (val > 0) tabstop = Math.ceil(rect.left / val) * val;
    else tabstop = -val;
    console.log("do_tabs", val, tabstop)
    if (tabstop > 0) {
      var width = tabstop - rect.left;
      span.style.display = "inline-block";
      span.style.width = width + "px";
    }
  }
}
do_tabs();
</script>
  </body>
</html>
