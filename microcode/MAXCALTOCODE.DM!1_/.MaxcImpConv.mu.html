<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>MAXCALTOCODE.DM!1>MaxcImpConv.mu</title>
  </head>
  <body>
    <pre>
; MaxcImpConv.mu -- conversion between Maxc and Imp packet formats;	Last modified April 13, 1978  10:49 AM; This microcode runs only on Alto-I.; It contains emulator-level microcode, intended to be called via trap; opcodes, for converting between the Imp and Maxc2 data formats.; The Imp format is just a continuous bit stream, packed into 16-bit words.; The Maxc format is the same continuous bit stream, but packed either; 32 or 36 bits per Maxc word and stored in Alto memory in the correct; format for (36-bit) Maxc memory operations.; All instructions assume that the first 72 bits of a message (Imp and; Host leader) have been dealt with by the software.  Thus, transfers start; with the 73rd bit, which happens to fall in the middle of an Alto word; in Imp format.; In the descriptions of block formats:;	00, 01, etc., are names for 4-bit nibbles.;	** is a nibble whose value is undefined (source) or may be;	   clobbered arbitrarily (destination).;	XX is a nibble that must be preserved (destination).;	-- is a zero nibble.!1, 2, T32May, T32No;!1, 2, T32Int, T32Dis;!1, 2, CT32Lp, CT32Dn;!1, 2, T36May, T36No;!1, 2, T36Int, T36Dis;!1, 2, CT36Lp, CT36Dn;!1, 2, CT36L1, CT36D1;!1, 2, CT36L2, CT36D2;!1, 2, CT36L3, CT36D3;!1, 2, F32May, F32No;!1, 2, F32Int, F32Dis;!1, 2, CF32Lp, CF32Dn;!1, 2, F36May, F36No;!1, 2, F36Int, F36Dis;!1, 2, CF36Lp, CF36Dn;!1, 2, CF36L1, CF36D1;!1, 2, CF36L2, CF36D2;!1, 2, CF36L3, CF36D3;$170000	$170000;$177777	$177777;; Convert Imp message to Maxc 32-bit format.; It is assumed that the first 8 bits of the source block have; already been consumed.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Source block format:;	** ** 00 01	&lt;- AC1;	02 03 04 05;	06 07 ** **; Destination block format:;	00 01 02 03	&lt;- AC0;	04 05 06 07;	** ** ** **ConvTo32:	MAR&larr; AC1;			Fetch (** ** 00 01) from source block	T&larr; 377;				Mask just right byte	L&larr; MD AND T, TASK;	SAD&larr; L;				Save as leftover; Main loop.; AC1 points to last word read, AC0 to next word to write.; Each time through the loop, AC1 is incremented by 2, AC0 incremented by 3,; and AC3 decremented by 1.; Store first 16 bits of Maxc word (00 01 02 03).; SAD has (-- -- 00 01).CT32Lp:	MAR&larr; T&larr; AC1+1;			Fetch next source word (02 03 04 05)	L&larr; NWW, BUS=0;			Test for interrupt	L&larr; T, T&larr; 377, SH&lt;0, :T32May;	[T32May, T32No]T32No:	AC1&larr; L;				Update source addressT32Dis:	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 04 05), T&larr; (02 03 04 05)	T&larr; 177400 . T;			T&larr; (02 03 -- --)	T&larr; SAD OR T;			T&larr; (02 03 00 01)	MAR&larr; AC0;			Store into destination block	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 04 05)	MTEMP&larr; L LCY 8;			MTEMP&larr; (00 01 02 03)	TASK;	MD&larr; MTEMP;; Now store second 16 bits of Maxc word (04 05 06 07).; SAD has (-- -- 04 05).	MAR&larr; L&larr; AC1+1;			Fetch next source word (06 07 00 01)	AC1&larr; L;	T&larr; 377;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 00 01), T&larr; (06 07 00 01)	T&larr; 177400 . T;			T&larr; (06 07 -- --)	T&larr; SAD OR T;			T&larr; (06 07 04 05)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 00 01)	MAR&larr; T&larr; AC0+1;			Store into destination block	MTEMP&larr; L LCY 8, T&larr; 0+T+1;	MTEMP&larr; (04 05 06 07)	L&larr; AC3-1;			Decrement Maxc word count	MD&larr; MTEMP;			Store (04 05 06 07)	AC3&larr; L, L&larr; 0+T+1, SH=0, TASK;	Update count, skip over unused word	AC0&larr; L, :CT32Lp;		[CT32Lp, CT32Dn]; Here when doneCT32Dn:	L&larr; PC, SWMODE, :CnvXit;; Here when possible interrupt (SH&lt;0 branch pending)T32May:	AC1&larr; L, :T32Int;		[T32Int, T32Dis]T32Int:	L&larr; AC1-1, TASK;			Back up source pointer	AC1&larr; L;CnvInt:	L&larr; PC-1, SWMODE;		Back up PCCnvXit:	PC&larr; L, :START;; Convert Imp message to Maxc 36-bit format.; It is assumed that the first 8 bits of the source block have; already been consumed.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Source block format:;	** ** 00 01	&lt;- AC1;	02 03 04 05;	06 07 08 09;	10 11 12 13;	14 15 16 17;	18 19 20 21;	22 23 24 25;	26 27 28 29;	30 31 32 33;	34 35 ** **; Destination block format:;	00 01 02 03	&lt;- AC0;	04 05 06 07;	08 ** ** **;	09 10 11 12;	13 14 15 16;	17 ** ** **;	18 19 20 21;	22 23 24 25;	26 ** ** **;	27 28 29 30;	31 32 33 34;	35 ** ** **ConvTo36:	MAR&larr; AC1;			Fetch (** ** 00 01) from source block	L&larr; AC0-1;			Back up destination to first word -1	AC0&larr; L;	T&larr; 377;				Mask just right byte	L&larr; MD AND T, TASK;	SAD&larr; L;				Save as leftover; Main loop.; Each iteration converts 9 Alto words to 4 Maxc words (the latter are; stored in 12 Alto words).  Hence each iteration increments AC1 by 9,; increments AC0 by 12, and decrements AC3 by 4.; AC1 points to last word read, AC0 to last word written.; Store first 16 bits of first Maxc word (00 01 02 03).; SAD has (-- -- 00 01)CT36Lp:	MAR&larr; T&larr; AC1+1;			Fetch next source word (02 03 04 05)	L&larr; NWW, BUS=0;			Test for interrupt	L&larr; T, T&larr; 377, SH&lt;0, :T36May;	[T36May, T36No]T36No:	AC1&larr; L;				Update source addressT36Dis:	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 04 05), T&larr; (02 03 04 05)	T&larr; 177400 . T;			T&larr; (02 03 -- --)	T&larr; SAD OR T;			T&larr; (02 03 00 01)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 04 05)	MAR&larr; T&larr; AC0+1;			Store into destination block	MTEMP&larr; L LCY 8, L&larr; T;		MTEMP&larr; (00 01 02 03)	AC0&larr; L, TASK;	MD&larr; MTEMP;; Store second 16 bits of first Maxc word (04 05 06 07).; SAD has (-- -- 04 05).	MAR&larr; L&larr; AC1+1;			Fetch next source word (06 07 08 09)	AC1&larr; L;	T&larr; 377;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 08 09), T&larr; (06 07 08 09)	T&larr; 177400 . T;			T&larr; (06 07 -- --)	T&larr; SAD OR T;			T&larr; (06 07 04 05)	SAD&larr; L LCY 8, L&larr; T;		SAD&larr; new leftover (08 09 -- --)	MAR&larr; T&larr; AC0+1;			Store into destination block	MTEMP&larr; L LCY 8, L&larr; T;		MTEMP&larr; (04 05 06 07)	AC0&larr; L, TASK;	MD&larr; MTEMP;; Store last 4 bits of first Maxc word (08 ** ** **).; SAD has (08 09 -- --).	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L, SH=0, TASK;	MD&larr; SAD, :CT36L1;		[CT36L1, CT36D1] Store (08 ** ** **); Store first 16 bits of second Maxc word (09 10 11 12).; SAD has (08 09 -- --)CT36L1:	T&larr; SAD;				T&larr; (08 09 -- --)	T&larr; 7400 . T;			T&larr; (-- 09 -- --)	MAR&larr; L&larr; AC1+1;			Fetch next source word (10 11 12 13)	AC1&larr; L, L&larr; T;	XREG&larr; L LCY 8;			XREG&larr; (-- -- -- 09)	T&larr; 17;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- -- 13), T&larr; (10 11 12 13)	SAD&larr; L;				SAD&larr; (-- -- -- 13)	T&larr; 177760 . T;			T&larr; (10 11 12 --)	L&larr; T&larr; XREG OR T;		L&larr; T&larr; (10 11 12 09)	XREG&larr; L MRSH 1;			Right-cycle (10 11 12 09) 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MRSH 1;	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;			XREG&larr; (09 10 11 12)	MD&larr; XREG;; Store second 16 bits of second Maxc word (13 14 15 16).; SAD has (-- -- -- 13)	MAR&larr; L&larr; AC1+1;			Fetch next source word (14 15 16 17)	AC1&larr; L;	T&larr; 17;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- -- 17), T&larr; (14 15 16 17)	XH&larr; L LSH 1;			XH&larr; (-- -- -- 17) LSH 1	T&larr; 177760 . T;			T&larr; (14 15 16 --)	L&larr; T&larr; SAD OR T, TASK;		L&larr; T&larr; (14 15 16 13)	XREG&larr; L MRSH 1;			Right-cycle it 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MRSH 1;	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;			XREG&larr; (13 14 15 16)	MD&larr; XREG;; Store last 4 bits of second Maxc word (17 ** ** **).; XH has (-- -- -- 17) LSH 1.	L&larr; T&larr; XH;			= (-- -- -- 17) LSH 1.	L&larr; T&larr; M+T+1;			= 4*X +1, where X = (-- -- -- 17)	L&larr; T&larr; M+T+1;			= 8*X +3	L&larr; M+T+1;			= 16*X +7 = (-- -- 17 **)	SAD&larr; L LCY 8;			SAD&larr; (17 ** -- --)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L, SH=0, TASK;		Update count, done?	MD&larr; SAD, :CT36L2;		[CT36L2, CT36D2] Store (17 ** ** **); Store first 16 bits of third Maxc word (18 19 20 21).; There are no leftover bits.CT36L2:	MAR&larr; L&larr; AC1+1;			Fetch next source word (18 19 20 21)	AC1&larr; L;	T&larr; MD;				T&larr; (18 19 20 21)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L, L&larr; T, TASK;	MD&larr; M;				Store (18 19 20 21); Store second 16 bits of third Maxc word (22 23 24 25).; There are no leftover bits.	MAR&larr; L&larr; AC1+1;			Fetch next source word (22 23 24 25)	AC1&larr; L;	T&larr; MD;				T&larr; (22 23 24 25)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L, L&larr; T, TASK;	MD&larr; M;				Store (22 23 24 25); Store last 4 bits of third Maxc word (26 ** ** **).; There are no leftover bits.	MAR&larr; L&larr; AC1+1;			Fetch next source word (26 27 28 29)	AC1&larr; L;	T&larr; 7777;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- 27 28 29), T&larr; (26 27 28 29)	SAD&larr; L;				SAD&larr; new leftover (-- 27 28 29)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L, L&larr; T, SH=0, TASK;	Update it, done?	MD&larr; M, :CT36L3;			[CT36L3, CT36D3] Store (26 ** ** **); Store first 16 bits of fourth Maxc word (27 28 29 30).; SAD has (-- 27 28 29).CT36L3:	MAR&larr; L&larr; AC1+1;			Fetch next source word (30 31 32 33)	AC1&larr; L;	T&larr; 7777;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- 31 32 33), T&larr; (30 31 32 33)	T&larr; 170000 . T;			T&larr; (30 -- -- --)	T&larr; SAD OR T;			T&larr; (30 27 28 29)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- 31 32 33)	XREG&larr; L MLSH 1;			Left cycle (30 27 28 29) 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MLSH 1;	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;			XREG&larr; (27 28 29 30)	MD&larr; XREG;; Store second 16 bits of fourth Maxc word (31 32 33 34).; SAD has (-- 31 32 33).	MAR&larr; L&larr; AC1+1;			Fetch next source word (34 35 00 01)	AC1&larr; L;	T&larr; 7777;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- 35 00 01), T&larr; (34 35 00 01)	T&larr; 170000 . T;			T&larr; (34 -- -- --)	T&larr; SAD OR T;			T&larr; (34 31 32 33)	SAD&larr; L, L&larr; T, TASK;		SAD&larr; new leftover (-- 35 00 01)	XREG&larr; L MLSH 1;			Left cycle (34 31 32 33) 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MLSH 1;	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;			XREG&larr; (31 32 33 34)	MD&larr; XREG;; Store last 4 bits of fourth Maxc word (35 ** ** **).; SAD has (-- 35 00 01).	T&larr; 377;	L&larr; SAD AND T, T&larr; SAD;		L&larr; (-- -- 00 01), T&larr; (-- 35 00 01)	SAD&larr; L, L&larr; T;			SAD&larr; (-- -- 00 01) for next iteration	L&larr; T&larr; M+T+1;			= 2*X +1, where X = (-- 35 00 01)	L&larr; T&larr; M+T+1;			= 4*X +3	L&larr; T&larr; M+T+1;			= 8*X +7	T&larr; M+T+1;			= 16*X +15 = (35 ** ** **)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; AC3-1;			Decrement and test word count	AC3&larr; L, L&larr; T, SH=0, TASK;	MD&larr; M, :CT36Lp;			[CT36Lp, CT36Dn] Store (35 ** ** **); Here when doneCT36Dn:	L&larr; PC, SWMODE, :CnvXit;CT36D1:	L&larr; PC, SWMODE, :CnvXit;CT36D2:	L&larr; PC, SWMODE, :CnvXit;CT36D3:	L&larr; PC, SWMODE, :CnvXit;; Here when possible interrupt (SH&lt;0 branch pending)T36May:	AC1&larr; L, :T36Int;		[T36Int, T36Dis]; Here to interruptT36Int:	L&larr; AC0+1;			Un-back-up destination pointer	AC0&larr; L, :T32Int;		Go back up source pointer and quit; Convert Imp message from Maxc 32-bit format.; It is assumed that the first 8 bits of the destination block have; already been filled.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Note:  The last 8 bits of the block are not transferred.  The caller; must specify a Maxc word count one larger than the number of Maxc; words actually present, and provide 2 words of extra space in the; destination block.; Source block format:;	00 01 02 03	&lt;- AC1;	04 05 06 07;	** ** ** **; Destination block format:;	XX XX 00 01	&lt;- AC0;	02 03 04 05;	06 07 ** **ConvFrom32:	MAR&larr; T&larr; AC0;			Fetch first word of destination block	L&larr; 177777+T;			Back up destination pointer	AC0&larr; L;	T&larr; 177400;	L&larr; MD AND T, TASK;		L&larr; (XX XX -- --)	SAD&larr; L LCY 8;			SAD&larr; (-- -- XX XX); Main loop.; AC1 points to next word to read, AC0 at last destination word written.; Each time through the loop, AC0 is incremented by 2, AC1 incremented by 3,; and AC3 decremented by 1.; Transfer first 16 bits of source (00 01 02 03).  SAD has (-- -- XX XX)CF32Lp:	MAR&larr; AC1;			Fetch next source word (00 01 02 03)	L&larr; NWW, BUS=0;			Test for interrupts	T&larr; 377, SH&lt;0, :F32May;		[F32May, F32No]F32No:	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 02 03), T&larr; (00 01 02 03)F32Dis:	T&larr; 177400 . T;			T&larr; (00 01 -- --)	T&larr; SAD OR T;			T&larr; (00 01 XX XX)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 02 03)	MAR&larr; T&larr; AC0+1;			Store into destination block	MTEMP&larr; L LCY 8, L&larr; T;		MTEMP&larr; (XX XX 00 01)	AC0&larr; L, TASK;	MD&larr; MTEMP;; Transfer second 16 bits of source (04 05 06 07).  SAD has (-- -- 02 03)	MAR&larr; T&larr; AC1+1;			Fetch next source word (04 05 06 07)	L&larr; 2+T;				Skip over unused word	AC1&larr; L;	T&larr; 377;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 06 07), T&larr; (04 05 06 07)	T&larr; 177400 . T;			T&larr; (04 05 -- --)	T&larr; SAD OR T;			T&larr; (04 05 02 03)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 06 07)	MTEMP&larr; L LCY 8;			MTEMP&larr; (02 03 04 05)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L, SH=0, TASK;	MD&larr; MTEMP, :CF32Lp;		[CF32Lp, CF32Dn] Store (02 03 04 05); Here when done.CF32Dn:	L&larr; PC, SWMODE, :CnvXit;; Here when possible interrupt (SH&lt;0 branch pending)F32May:	L&larr; MD AND T, T&larr; MD, :F32Int;	[F32Int, F32Dis]F32Int:	MAR&larr; T&larr; AC0+1;			Store leftover word	L&larr; SAD;				L&larr; (-- -- XX XX)	SAD&larr; L LCY 8, L&larr; T;		SAD&larr; (XX XX -- --)	AC0&larr; L, TASK;	MD&larr; SAD, :CnvInt;		Go back up PC and quit; Convert Imp message from Maxc 36-bit format.; It is assumed that the first 8 bits of the destination block have; already been filled.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Note:  The last few bits of the block are not transferred.  The caller; must specify a Maxc word count one larger than the number of Maxc; words actually present, and provide 3 words of extra space in the; destination block.; Source block format:;	00 01 02 03	&lt;- AC1;	04 05 06 07;	08 ** ** **;	09 10 11 12;	13 14 15 16;	17 ** ** **;	18 19 20 21;	22 23 24 25;	26 ** ** **;	27 28 29 30;	31 32 33 34;	35 ** ** **; Destination block format:;	XX XX 00 01	&lt;- AC0;	02 03 04 05;	06 07 08 09;	10 11 12 13;	14 15 16 17;	18 19 20 21;	22 23 24 25;	26 27 28 29;	30 31 32 33;	34 35 ** **ConvFrom36:	MAR&larr; T&larr; AC0;			Fetch first word of destination block	L&larr; 177777+T;			Back up destination pointer	AC0&larr; L;	T&larr; 177400;	L&larr; MD AND T;			L&larr; (XX XX -- --)	SAD&larr; L LCY 8;			SAD&larr; (-- -- XX XX)	L&larr; AC1-1, TASK;			Back up source pointer	AC1&larr; L;; Main loop.; Each iteration converts 4 Maxc words to 9 Alto words.  Hence each; iteration increments AC1 by 12, increments AC0 by 9, and decrements; AC3 by 4.  AC1 points to last word read, AC0 to last word written.; Fetch first 16 bits of first Maxc word (00 01 02 03).; SAD has (-- -- XX XX)CF36Lp:	MAR&larr; T&larr; AC1+1;			Fetch next source word (00 01 02 03)	L&larr; NWW, BUS=0;			Test for interrupts	L&larr; T, T&larr; 377, SH&lt;0, :F36May;	[F36May, F36No]F36No:	AC1&larr; L;				Update source addressF36Dis:	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 02 03), T&larr; (00 01 02 03)	T&larr; 177400 . T;			T&larr; (00 01 -- --)	T&larr; SAD OR T;			T&larr; (00 01 XX XX)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 02 03)	MAR&larr; T&larr; AC0+1;			Store into destination block	MTEMP&larr; L LCY 8, L&larr; T;		MTEMP&larr; (XX XX 00 01)	AC0&larr; L, TASK;	MD&larr; MTEMP;; Fetch second 16 bits of first Maxc word (04 05 06 07).; SAD has (-- -- 02 03)	MAR&larr; L&larr; AC1+1;			Fetch next source word (04 05 06 07)	AC1&larr; L;	T&larr; 377;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- 06 07), T&larr; (04 05 06 07)	T&larr; 177400 . T;			T&larr; (04 05 -- --)	T&larr; SAD OR T;			T&larr; (04 05 02 03)	SAD&larr; L, L&larr; T;			SAD&larr; new leftover (-- -- 06 07)	MAR&larr; T&larr; AC0+1;			Store into destination block	MTEMP&larr; L LCY 8, L&larr; T;		MTEMP&larr; (02 03 04 05)	AC0&larr; L, TASK;	MD&larr; MTEMP;; Fetch last 4 bits of first Maxc word (08 ** ** **).; SAD has (-- -- 06 07).	MAR&larr; L&larr; AC1+1;			Fetch next source word (08 ** ** **)	AC1&larr; L;	T&larr; 170000;	T&larr; MD . T;			T&larr; (08 -- -- --)	T&larr; SAD OR T;			T&larr; (08 -- 06 07)	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L, L&larr; T, SH=0, TASK;	SAD&larr; L LCY 8, :CF36L1;		[CF36L1, CF36D1] SAD&larr; (06 07 08 --); Fetch first 16 bits of second Maxc word (09 10 11 12).; SAD has (06 07 08 --).CF36L1:	MAR&larr; L&larr; AC1+1;			Fetch next source word (09 10 11 12)	AC1&larr; L;	T&larr; 7777;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- 10 11 12), T&larr; (09 10 11 12)	XH&larr; L;				XH&larr; new leftover (-- 10 11 12)	L&larr; T&larr; 170000 . T;		L&larr; T&larr; (09 -- -- --)	XREG&larr; L MLSH 1;			Left cycle it 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MLSH 1;			XREG&larr; (-- -- -- 09)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	T&larr; SAD;				T&larr; (06 07 08 --)	L&larr; XREG OR T, TASK;		L&larr; (06 07 08 09)	MD&larr; M;; Fetch second 16 bits of second Maxc word (13 14 15 16).; XH has (-- 10 11 12).	MAR&larr; L&larr; AC1+1;			Fetch next source word (13 14 15 16)	AC1&larr; L;	T&larr; 7777;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- 14 15 16), T&larr; (13 14 15 16)	SAD&larr; L;				SAD&larr; new leftover (-- 14 15 16)	T&larr; 170000 . T;			T&larr; (13 -- -- --)	L&larr; T&larr; XH OR T;			L&larr; T&larr; (13 10 11 12)	XREG&larr; L MLSH 1;			Left cycle 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MLSH 1;	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;			XREG&larr; (10 11 12 13)	MD&larr; XREG;; Fetch last 4 bits of second Maxc word (17 ** ** **).; SAD has (-- 14 15 16).	MAR&larr; L&larr; AC1+1;			Fetch next source word (17 ** ** **)	AC1&larr; L;	T&larr; 170000;	T&larr; MD . T;			T&larr; (17 -- -- --)	L&larr; SAD OR T, TASK;		L&larr; (17 14 15 16)	XREG&larr; L MLSH 1;			Left cycle 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MLSH 1;			XREG&larr; (14 15 16 17)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L, SH=0, TASK;	MD&larr; XREG, :CF36L2;		[CF36L2, CF36D2] Store (14 15 16 17); Fetch first 16 bits of third Maxc word (18 19 20 21).; There are no leftover bits.CF36L2:	MAR&larr; L&larr; AC1+1;			Fetch next source word (18 19 20 21)	AC1&larr; L;	T&larr; MD;				T&larr; (18 19 20 21)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L, L&larr; T, TASK;	MD&larr; M;				Store (18 19 20 21); Fetch second 16 bits of third Maxc word (22 23 24 25).; There are no leftover bits.	MAR&larr; L&larr; AC1+1;			Fetch next source word (22 23 24 25)	AC1&larr; L;	T&larr; MD;				T&larr; (22 23 24 25)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L, L&larr; T, TASK;	MD&larr; M;				Store (22 23 24 25); Fetch last 4 bits of third Maxc word (26 ** ** **).; There are no leftover bits.	T&larr; 170000;	MAR&larr; L&larr; AC1+1;			Fetch next source word (26 ** ** **)	AC1&larr; L;	L&larr; AC3-1;			Decrement and test Maxc word count	AC3&larr; L;	L&larr; MD AND T, SH=0, TASK;	L&larr; (26 -- -- --)	SAD&larr; L, :CF36L3;		[CF36L3, CF36D3]; Fetch first 16 bits of fourth Maxc word (27 28 29 30).; SAD has (26 -- -- --).CF36L3:	MAR&larr; L&larr; AC1+1;			Fetch next source word (27 28 29 30)	AC1&larr; L;	T&larr; 17;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- -- -- 30), T&larr; (27 28 29 30)	XH&larr; L;				XH&larr; new leftover (-- -- -- 30)	L&larr; T&larr; 177760 . T;		L&larr; T&larr; (27 28 29 --)	XREG&larr; L MRSH 1;			Right cycle it 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MRSH 1;			XREG&larr; (-- 27 28 29)	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	T&larr; SAD;				T&larr; (26 -- -- --)	L&larr; XREG OR T, TASK;		L&larr; (26 27 28 29)	MD&larr; M;; Fetch second 16 bits of fourth Maxc word (31 32 33 34).; XH has (-- -- -- 30).	MAR&larr; L&larr; AC1+1;			Fetch next source word (31 32 33 34)	AC1&larr; L;	T&larr; 17;	L&larr; MD AND T, T&larr; MD;		L&larr; (-- 14 15 16), T&larr; (31 32 33 34)	SAD&larr; L;				SAD&larr; new leftover (-- -- -- 34)	T&larr; 177760 . T;			T&larr; (31 32 33 --)	L&larr; T&larr; XH OR T;			L&larr; T&larr; (31 32 33 30)	XREG&larr; L MRSH 1;			Right cycle 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;	L&larr; T&larr; XREG, TASK;	XREG&larr; L MRSH 1;	MAR&larr; L&larr; AC0+1;			Store into destination block	AC0&larr; L;	L&larr; T&larr; XREG;	XREG&larr; L MRSH 1;			XREG&larr; (30 31 32 33)	MD&larr; XREG;; Fetch last 4 bits of fourth Maxc word (35 ** ** **).; SAD has (-- -- -- 34).	MAR&larr; L&larr; AC1+1;			Fetch next source word (35 ** ** **)	AC1&larr; L;	T&larr; 170000;	T&larr; MD . T;			T&larr; (35 -- -- --)	L&larr; SAD OR T, TASK;		L&larr; (35 -- -- 34)	XREG&larr; L MLSH 1;			Left cycle 4 bits	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; T&larr; XREG;	XREG&larr; L MLSH 1;	L&larr; AC3-1;	AC3&larr; L;	L&larr; T&larr; XREG, SH=0, TASK;	SAD&larr; L MLSH 1, :CF36Lp;		[CF36Lp, CF36Dn] SAD&larr; (-- -- 34 35); Here when doneCF36Dn:	L&larr; PC, SWMODE, :CnvXit;CF36D1:	L&larr; PC, SWMODE, :CnvXit;CF36D2:	L&larr; PC, SWMODE, :CnvXit;CF36D3:	L&larr; PC, SWMODE, :CnvXit;; Here when possible interrupt (SH&lt;0 branch pending)F36May:	AC1&larr; L, :F36Int;		[F36Int, F36Dis]; Here to interruptF36Int:	:F32Int;			Store leftover word and quit</pre>
  </body>
</html>
