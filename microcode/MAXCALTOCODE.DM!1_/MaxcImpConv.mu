; MaxcImpConv.mu -- conversion between Maxc and Imp packet formats;	Last modified April 13, 1978  10:49 AM; This microcode runs only on Alto-I.; It contains emulator-level microcode, intended to be called via trap; opcodes, for converting between the Imp and Maxc2 data formats.; The Imp format is just a continuous bit stream, packed into 16-bit words.; The Maxc format is the same continuous bit stream, but packed either; 32 or 36 bits per Maxc word and stored in Alto memory in the correct; format for (36-bit) Maxc memory operations.; All instructions assume that the first 72 bits of a message (Imp and; Host leader) have been dealt with by the software.  Thus, transfers start; with the 73rd bit, which happens to fall in the middle of an Alto word; in Imp format.; In the descriptions of block formats:;	00, 01, etc., are names for 4-bit nibbles.;	** is a nibble whose value is undefined (source) or may be;	   clobbered arbitrarily (destination).;	XX is a nibble that must be preserved (destination).;	-- is a zero nibble.!1, 2, T32May, T32No;!1, 2, T32Int, T32Dis;!1, 2, CT32Lp, CT32Dn;!1, 2, T36May, T36No;!1, 2, T36Int, T36Dis;!1, 2, CT36Lp, CT36Dn;!1, 2, CT36L1, CT36D1;!1, 2, CT36L2, CT36D2;!1, 2, CT36L3, CT36D3;!1, 2, F32May, F32No;!1, 2, F32Int, F32Dis;!1, 2, CF32Lp, CF32Dn;!1, 2, F36May, F36No;!1, 2, F36Int, F36Dis;!1, 2, CF36Lp, CF36Dn;!1, 2, CF36L1, CF36D1;!1, 2, CF36L2, CF36D2;!1, 2, CF36L3, CF36D3;$170000	$170000;$177777	$177777;; Convert Imp message to Maxc 32-bit format.; It is assumed that the first 8 bits of the source block have; already been consumed.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Source block format:;	** ** 00 01	<- AC1;	02 03 04 05;	06 07 ** **; Destination block format:;	00 01 02 03	<- AC0;	04 05 06 07;	** ** ** **ConvTo32:	MAR_ AC1;			Fetch (** ** 00 01) from source block	T_ 377;				Mask just right byte	L_ MD AND T, TASK;	SAD_ L;				Save as leftover; Main loop.; AC1 points to last word read, AC0 to next word to write.; Each time through the loop, AC1 is incremented by 2, AC0 incremented by 3,; and AC3 decremented by 1.; Store first 16 bits of Maxc word (00 01 02 03).; SAD has (-- -- 00 01).CT32Lp:	MAR_ T_ AC1+1;			Fetch next source word (02 03 04 05)	L_ NWW, BUS=0;			Test for interrupt	L_ T, T_ 377, SH<0, :T32May;	[T32May, T32No]T32No:	AC1_ L;				Update source addressT32Dis:	L_ MD AND T, T_ MD;		L_ (-- -- 04 05), T_ (02 03 04 05)	T_ 177400 . T;			T_ (02 03 -- --)	T_ SAD OR T;			T_ (02 03 00 01)	MAR_ AC0;			Store into destination block	SAD_ L, L_ T;			SAD_ new leftover (-- -- 04 05)	MTEMP_ L LCY 8;			MTEMP_ (00 01 02 03)	TASK;	MD_ MTEMP;; Now store second 16 bits of Maxc word (04 05 06 07).; SAD has (-- -- 04 05).	MAR_ L_ AC1+1;			Fetch next source word (06 07 00 01)	AC1_ L;	T_ 377;	L_ MD AND T, T_ MD;		L_ (-- -- 00 01), T_ (06 07 00 01)	T_ 177400 . T;			T_ (06 07 -- --)	T_ SAD OR T;			T_ (06 07 04 05)	SAD_ L, L_ T;			SAD_ new leftover (-- -- 00 01)	MAR_ T_ AC0+1;			Store into destination block	MTEMP_ L LCY 8, T_ 0+T+1;	MTEMP_ (04 05 06 07)	L_ AC3-1;			Decrement Maxc word count	MD_ MTEMP;			Store (04 05 06 07)	AC3_ L, L_ 0+T+1, SH=0, TASK;	Update count, skip over unused word	AC0_ L, :CT32Lp;		[CT32Lp, CT32Dn]; Here when doneCT32Dn:	L_ PC, SWMODE, :CnvXit;; Here when possible interrupt (SH<0 branch pending)T32May:	AC1_ L, :T32Int;		[T32Int, T32Dis]T32Int:	L_ AC1-1, TASK;			Back up source pointer	AC1_ L;CnvInt:	L_ PC-1, SWMODE;		Back up PCCnvXit:	PC_ L, :START;; Convert Imp message to Maxc 36-bit format.; It is assumed that the first 8 bits of the source block have; already been consumed.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Source block format:;	** ** 00 01	<- AC1;	02 03 04 05;	06 07 08 09;	10 11 12 13;	14 15 16 17;	18 19 20 21;	22 23 24 25;	26 27 28 29;	30 31 32 33;	34 35 ** **; Destination block format:;	00 01 02 03	<- AC0;	04 05 06 07;	08 ** ** **;	09 10 11 12;	13 14 15 16;	17 ** ** **;	18 19 20 21;	22 23 24 25;	26 ** ** **;	27 28 29 30;	31 32 33 34;	35 ** ** **ConvTo36:	MAR_ AC1;			Fetch (** ** 00 01) from source block	L_ AC0-1;			Back up destination to first word -1	AC0_ L;	T_ 377;				Mask just right byte	L_ MD AND T, TASK;	SAD_ L;				Save as leftover; Main loop.; Each iteration converts 9 Alto words to 4 Maxc words (the latter are; stored in 12 Alto words).  Hence each iteration increments AC1 by 9,; increments AC0 by 12, and decrements AC3 by 4.; AC1 points to last word read, AC0 to last word written.; Store first 16 bits of first Maxc word (00 01 02 03).; SAD has (-- -- 00 01)CT36Lp:	MAR_ T_ AC1+1;			Fetch next source word (02 03 04 05)	L_ NWW, BUS=0;			Test for interrupt	L_ T, T_ 377, SH<0, :T36May;	[T36May, T36No]T36No:	AC1_ L;				Update source addressT36Dis:	L_ MD AND T, T_ MD;		L_ (-- -- 04 05), T_ (02 03 04 05)	T_ 177400 . T;			T_ (02 03 -- --)	T_ SAD OR T;			T_ (02 03 00 01)	SAD_ L, L_ T;			SAD_ new leftover (-- -- 04 05)	MAR_ T_ AC0+1;			Store into destination block	MTEMP_ L LCY 8, L_ T;		MTEMP_ (00 01 02 03)	AC0_ L, TASK;	MD_ MTEMP;; Store second 16 bits of first Maxc word (04 05 06 07).; SAD has (-- -- 04 05).	MAR_ L_ AC1+1;			Fetch next source word (06 07 08 09)	AC1_ L;	T_ 377;	L_ MD AND T, T_ MD;		L_ (-- -- 08 09), T_ (06 07 08 09)	T_ 177400 . T;			T_ (06 07 -- --)	T_ SAD OR T;			T_ (06 07 04 05)	SAD_ L LCY 8, L_ T;		SAD_ new leftover (08 09 -- --)	MAR_ T_ AC0+1;			Store into destination block	MTEMP_ L LCY 8, L_ T;		MTEMP_ (04 05 06 07)	AC0_ L, TASK;	MD_ MTEMP;; Store last 4 bits of first Maxc word (08 ** ** **).; SAD has (08 09 -- --).	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L, SH=0, TASK;	MD_ SAD, :CT36L1;		[CT36L1, CT36D1] Store (08 ** ** **); Store first 16 bits of second Maxc word (09 10 11 12).; SAD has (08 09 -- --)CT36L1:	T_ SAD;				T_ (08 09 -- --)	T_ 7400 . T;			T_ (-- 09 -- --)	MAR_ L_ AC1+1;			Fetch next source word (10 11 12 13)	AC1_ L, L_ T;	XREG_ L LCY 8;			XREG_ (-- -- -- 09)	T_ 17;	L_ MD AND T, T_ MD;		L_ (-- -- -- 13), T_ (10 11 12 13)	SAD_ L;				SAD_ (-- -- -- 13)	T_ 177760 . T;			T_ (10 11 12 --)	L_ T_ XREG OR T;		L_ T_ (10 11 12 09)	XREG_ L MRSH 1;			Right-cycle (10 11 12 09) 4 bits	L_ T_ XREG;	XREG_ L MRSH 1;	L_ T_ XREG, TASK;	XREG_ L MRSH 1;	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ T_ XREG;	XREG_ L MRSH 1;			XREG_ (09 10 11 12)	MD_ XREG;; Store second 16 bits of second Maxc word (13 14 15 16).; SAD has (-- -- -- 13)	MAR_ L_ AC1+1;			Fetch next source word (14 15 16 17)	AC1_ L;	T_ 17;	L_ MD AND T, T_ MD;		L_ (-- -- -- 17), T_ (14 15 16 17)	XH_ L LSH 1;			XH_ (-- -- -- 17) LSH 1	T_ 177760 . T;			T_ (14 15 16 --)	L_ T_ SAD OR T, TASK;		L_ T_ (14 15 16 13)	XREG_ L MRSH 1;			Right-cycle it 4 bits	L_ T_ XREG;	XREG_ L MRSH 1;	L_ T_ XREG, TASK;	XREG_ L MRSH 1;	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ T_ XREG;	XREG_ L MRSH 1;			XREG_ (13 14 15 16)	MD_ XREG;; Store last 4 bits of second Maxc word (17 ** ** **).; XH has (-- -- -- 17) LSH 1.	L_ T_ XH;			= (-- -- -- 17) LSH 1.	L_ T_ M+T+1;			= 4*X +1, where X = (-- -- -- 17)	L_ T_ M+T+1;			= 8*X +3	L_ M+T+1;			= 16*X +7 = (-- -- 17 **)	SAD_ L LCY 8;			SAD_ (17 ** -- --)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L, SH=0, TASK;		Update count, done?	MD_ SAD, :CT36L2;		[CT36L2, CT36D2] Store (17 ** ** **); Store first 16 bits of third Maxc word (18 19 20 21).; There are no leftover bits.CT36L2:	MAR_ L_ AC1+1;			Fetch next source word (18 19 20 21)	AC1_ L;	T_ MD;				T_ (18 19 20 21)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L, L_ T, TASK;	MD_ M;				Store (18 19 20 21); Store second 16 bits of third Maxc word (22 23 24 25).; There are no leftover bits.	MAR_ L_ AC1+1;			Fetch next source word (22 23 24 25)	AC1_ L;	T_ MD;				T_ (22 23 24 25)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L, L_ T, TASK;	MD_ M;				Store (22 23 24 25); Store last 4 bits of third Maxc word (26 ** ** **).; There are no leftover bits.	MAR_ L_ AC1+1;			Fetch next source word (26 27 28 29)	AC1_ L;	T_ 7777;	L_ MD AND T, T_ MD;		L_ (-- 27 28 29), T_ (26 27 28 29)	SAD_ L;				SAD_ new leftover (-- 27 28 29)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L, L_ T, SH=0, TASK;	Update it, done?	MD_ M, :CT36L3;			[CT36L3, CT36D3] Store (26 ** ** **); Store first 16 bits of fourth Maxc word (27 28 29 30).; SAD has (-- 27 28 29).CT36L3:	MAR_ L_ AC1+1;			Fetch next source word (30 31 32 33)	AC1_ L;	T_ 7777;	L_ MD AND T, T_ MD;		L_ (-- 31 32 33), T_ (30 31 32 33)	T_ 170000 . T;			T_ (30 -- -- --)	T_ SAD OR T;			T_ (30 27 28 29)	SAD_ L, L_ T;			SAD_ new leftover (-- 31 32 33)	XREG_ L MLSH 1;			Left cycle (30 27 28 29) 4 bits	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG, TASK;	XREG_ L MLSH 1;	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ T_ XREG;	XREG_ L MLSH 1;			XREG_ (27 28 29 30)	MD_ XREG;; Store second 16 bits of fourth Maxc word (31 32 33 34).; SAD has (-- 31 32 33).	MAR_ L_ AC1+1;			Fetch next source word (34 35 00 01)	AC1_ L;	T_ 7777;	L_ MD AND T, T_ MD;		L_ (-- 35 00 01), T_ (34 35 00 01)	T_ 170000 . T;			T_ (34 -- -- --)	T_ SAD OR T;			T_ (34 31 32 33)	SAD_ L, L_ T, TASK;		SAD_ new leftover (-- 35 00 01)	XREG_ L MLSH 1;			Left cycle (34 31 32 33) 4 bits	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG, TASK;	XREG_ L MLSH 1;	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ T_ XREG;	XREG_ L MLSH 1;			XREG_ (31 32 33 34)	MD_ XREG;; Store last 4 bits of fourth Maxc word (35 ** ** **).; SAD has (-- 35 00 01).	T_ 377;	L_ SAD AND T, T_ SAD;		L_ (-- -- 00 01), T_ (-- 35 00 01)	SAD_ L, L_ T;			SAD_ (-- -- 00 01) for next iteration	L_ T_ M+T+1;			= 2*X +1, where X = (-- 35 00 01)	L_ T_ M+T+1;			= 4*X +3	L_ T_ M+T+1;			= 8*X +7	T_ M+T+1;			= 16*X +15 = (35 ** ** **)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ AC3-1;			Decrement and test word count	AC3_ L, L_ T, SH=0, TASK;	MD_ M, :CT36Lp;			[CT36Lp, CT36Dn] Store (35 ** ** **); Here when doneCT36Dn:	L_ PC, SWMODE, :CnvXit;CT36D1:	L_ PC, SWMODE, :CnvXit;CT36D2:	L_ PC, SWMODE, :CnvXit;CT36D3:	L_ PC, SWMODE, :CnvXit;; Here when possible interrupt (SH<0 branch pending)T36May:	AC1_ L, :T36Int;		[T36Int, T36Dis]; Here to interruptT36Int:	L_ AC0+1;			Un-back-up destination pointer	AC0_ L, :T32Int;		Go back up source pointer and quit; Convert Imp message from Maxc 32-bit format.; It is assumed that the first 8 bits of the destination block have; already been filled.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Note:  The last 8 bits of the block are not transferred.  The caller; must specify a Maxc word count one larger than the number of Maxc; words actually present, and provide 2 words of extra space in the; destination block.; Source block format:;	00 01 02 03	<- AC1;	04 05 06 07;	** ** ** **; Destination block format:;	XX XX 00 01	<- AC0;	02 03 04 05;	06 07 ** **ConvFrom32:	MAR_ T_ AC0;			Fetch first word of destination block	L_ 177777+T;			Back up destination pointer	AC0_ L;	T_ 177400;	L_ MD AND T, TASK;		L_ (XX XX -- --)	SAD_ L LCY 8;			SAD_ (-- -- XX XX); Main loop.; AC1 points to next word to read, AC0 at last destination word written.; Each time through the loop, AC0 is incremented by 2, AC1 incremented by 3,; and AC3 decremented by 1.; Transfer first 16 bits of source (00 01 02 03).  SAD has (-- -- XX XX)CF32Lp:	MAR_ AC1;			Fetch next source word (00 01 02 03)	L_ NWW, BUS=0;			Test for interrupts	T_ 377, SH<0, :F32May;		[F32May, F32No]F32No:	L_ MD AND T, T_ MD;		L_ (-- -- 02 03), T_ (00 01 02 03)F32Dis:	T_ 177400 . T;			T_ (00 01 -- --)	T_ SAD OR T;			T_ (00 01 XX XX)	SAD_ L, L_ T;			SAD_ new leftover (-- -- 02 03)	MAR_ T_ AC0+1;			Store into destination block	MTEMP_ L LCY 8, L_ T;		MTEMP_ (XX XX 00 01)	AC0_ L, TASK;	MD_ MTEMP;; Transfer second 16 bits of source (04 05 06 07).  SAD has (-- -- 02 03)	MAR_ T_ AC1+1;			Fetch next source word (04 05 06 07)	L_ 2+T;				Skip over unused word	AC1_ L;	T_ 377;	L_ MD AND T, T_ MD;		L_ (-- -- 06 07), T_ (04 05 06 07)	T_ 177400 . T;			T_ (04 05 -- --)	T_ SAD OR T;			T_ (04 05 02 03)	SAD_ L, L_ T;			SAD_ new leftover (-- -- 06 07)	MTEMP_ L LCY 8;			MTEMP_ (02 03 04 05)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L, SH=0, TASK;	MD_ MTEMP, :CF32Lp;		[CF32Lp, CF32Dn] Store (02 03 04 05); Here when done.CF32Dn:	L_ PC, SWMODE, :CnvXit;; Here when possible interrupt (SH<0 branch pending)F32May:	L_ MD AND T, T_ MD, :F32Int;	[F32Int, F32Dis]F32Int:	MAR_ T_ AC0+1;			Store leftover word	L_ SAD;				L_ (-- -- XX XX)	SAD_ L LCY 8, L_ T;		SAD_ (XX XX -- --)	AC0_ L, TASK;	MD_ SAD, :CnvInt;		Go back up PC and quit; Convert Imp message from Maxc 36-bit format.; It is assumed that the first 8 bits of the destination block have; already been filled.; AC0/ first destination address; AC1/ first source address; AC3/ Maxc word count; Note:  The last few bits of the block are not transferred.  The caller; must specify a Maxc word count one larger than the number of Maxc; words actually present, and provide 3 words of extra space in the; destination block.; Source block format:;	00 01 02 03	<- AC1;	04 05 06 07;	08 ** ** **;	09 10 11 12;	13 14 15 16;	17 ** ** **;	18 19 20 21;	22 23 24 25;	26 ** ** **;	27 28 29 30;	31 32 33 34;	35 ** ** **; Destination block format:;	XX XX 00 01	<- AC0;	02 03 04 05;	06 07 08 09;	10 11 12 13;	14 15 16 17;	18 19 20 21;	22 23 24 25;	26 27 28 29;	30 31 32 33;	34 35 ** **ConvFrom36:	MAR_ T_ AC0;			Fetch first word of destination block	L_ 177777+T;			Back up destination pointer	AC0_ L;	T_ 177400;	L_ MD AND T;			L_ (XX XX -- --)	SAD_ L LCY 8;			SAD_ (-- -- XX XX)	L_ AC1-1, TASK;			Back up source pointer	AC1_ L;; Main loop.; Each iteration converts 4 Maxc words to 9 Alto words.  Hence each; iteration increments AC1 by 12, increments AC0 by 9, and decrements; AC3 by 4.  AC1 points to last word read, AC0 to last word written.; Fetch first 16 bits of first Maxc word (00 01 02 03).; SAD has (-- -- XX XX)CF36Lp:	MAR_ T_ AC1+1;			Fetch next source word (00 01 02 03)	L_ NWW, BUS=0;			Test for interrupts	L_ T, T_ 377, SH<0, :F36May;	[F36May, F36No]F36No:	AC1_ L;				Update source addressF36Dis:	L_ MD AND T, T_ MD;		L_ (-- -- 02 03), T_ (00 01 02 03)	T_ 177400 . T;			T_ (00 01 -- --)	T_ SAD OR T;			T_ (00 01 XX XX)	SAD_ L, L_ T;			SAD_ new leftover (-- -- 02 03)	MAR_ T_ AC0+1;			Store into destination block	MTEMP_ L LCY 8, L_ T;		MTEMP_ (XX XX 00 01)	AC0_ L, TASK;	MD_ MTEMP;; Fetch second 16 bits of first Maxc word (04 05 06 07).; SAD has (-- -- 02 03)	MAR_ L_ AC1+1;			Fetch next source word (04 05 06 07)	AC1_ L;	T_ 377;	L_ MD AND T, T_ MD;		L_ (-- -- 06 07), T_ (04 05 06 07)	T_ 177400 . T;			T_ (04 05 -- --)	T_ SAD OR T;			T_ (04 05 02 03)	SAD_ L, L_ T;			SAD_ new leftover (-- -- 06 07)	MAR_ T_ AC0+1;			Store into destination block	MTEMP_ L LCY 8, L_ T;		MTEMP_ (02 03 04 05)	AC0_ L, TASK;	MD_ MTEMP;; Fetch last 4 bits of first Maxc word (08 ** ** **).; SAD has (-- -- 06 07).	MAR_ L_ AC1+1;			Fetch next source word (08 ** ** **)	AC1_ L;	T_ 170000;	T_ MD . T;			T_ (08 -- -- --)	T_ SAD OR T;			T_ (08 -- 06 07)	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L, L_ T, SH=0, TASK;	SAD_ L LCY 8, :CF36L1;		[CF36L1, CF36D1] SAD_ (06 07 08 --); Fetch first 16 bits of second Maxc word (09 10 11 12).; SAD has (06 07 08 --).CF36L1:	MAR_ L_ AC1+1;			Fetch next source word (09 10 11 12)	AC1_ L;	T_ 7777;	L_ MD AND T, T_ MD;		L_ (-- 10 11 12), T_ (09 10 11 12)	XH_ L;				XH_ new leftover (-- 10 11 12)	L_ T_ 170000 . T;		L_ T_ (09 -- -- --)	XREG_ L MLSH 1;			Left cycle it 4 bits	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG, TASK;	XREG_ L MLSH 1;			XREG_ (-- -- -- 09)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	T_ SAD;				T_ (06 07 08 --)	L_ XREG OR T, TASK;		L_ (06 07 08 09)	MD_ M;; Fetch second 16 bits of second Maxc word (13 14 15 16).; XH has (-- 10 11 12).	MAR_ L_ AC1+1;			Fetch next source word (13 14 15 16)	AC1_ L;	T_ 7777;	L_ MD AND T, T_ MD;		L_ (-- 14 15 16), T_ (13 14 15 16)	SAD_ L;				SAD_ new leftover (-- 14 15 16)	T_ 170000 . T;			T_ (13 -- -- --)	L_ T_ XH OR T;			L_ T_ (13 10 11 12)	XREG_ L MLSH 1;			Left cycle 4 bits	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG, TASK;	XREG_ L MLSH 1;	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ T_ XREG;	XREG_ L MLSH 1;			XREG_ (10 11 12 13)	MD_ XREG;; Fetch last 4 bits of second Maxc word (17 ** ** **).; SAD has (-- 14 15 16).	MAR_ L_ AC1+1;			Fetch next source word (17 ** ** **)	AC1_ L;	T_ 170000;	T_ MD . T;			T_ (17 -- -- --)	L_ SAD OR T, TASK;		L_ (17 14 15 16)	XREG_ L MLSH 1;			Left cycle 4 bits	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG, TASK;	XREG_ L MLSH 1;			XREG_ (14 15 16 17)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L, SH=0, TASK;	MD_ XREG, :CF36L2;		[CF36L2, CF36D2] Store (14 15 16 17); Fetch first 16 bits of third Maxc word (18 19 20 21).; There are no leftover bits.CF36L2:	MAR_ L_ AC1+1;			Fetch next source word (18 19 20 21)	AC1_ L;	T_ MD;				T_ (18 19 20 21)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L, L_ T, TASK;	MD_ M;				Store (18 19 20 21); Fetch second 16 bits of third Maxc word (22 23 24 25).; There are no leftover bits.	MAR_ L_ AC1+1;			Fetch next source word (22 23 24 25)	AC1_ L;	T_ MD;				T_ (22 23 24 25)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L, L_ T, TASK;	MD_ M;				Store (22 23 24 25); Fetch last 4 bits of third Maxc word (26 ** ** **).; There are no leftover bits.	T_ 170000;	MAR_ L_ AC1+1;			Fetch next source word (26 ** ** **)	AC1_ L;	L_ AC3-1;			Decrement and test Maxc word count	AC3_ L;	L_ MD AND T, SH=0, TASK;	L_ (26 -- -- --)	SAD_ L, :CF36L3;		[CF36L3, CF36D3]; Fetch first 16 bits of fourth Maxc word (27 28 29 30).; SAD has (26 -- -- --).CF36L3:	MAR_ L_ AC1+1;			Fetch next source word (27 28 29 30)	AC1_ L;	T_ 17;	L_ MD AND T, T_ MD;		L_ (-- -- -- 30), T_ (27 28 29 30)	XH_ L;				XH_ new leftover (-- -- -- 30)	L_ T_ 177760 . T;		L_ T_ (27 28 29 --)	XREG_ L MRSH 1;			Right cycle it 4 bits	L_ T_ XREG;	XREG_ L MRSH 1;	L_ T_ XREG;	XREG_ L MRSH 1;	L_ T_ XREG, TASK;	XREG_ L MRSH 1;			XREG_ (-- 27 28 29)	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	T_ SAD;				T_ (26 -- -- --)	L_ XREG OR T, TASK;		L_ (26 27 28 29)	MD_ M;; Fetch second 16 bits of fourth Maxc word (31 32 33 34).; XH has (-- -- -- 30).	MAR_ L_ AC1+1;			Fetch next source word (31 32 33 34)	AC1_ L;	T_ 17;	L_ MD AND T, T_ MD;		L_ (-- 14 15 16), T_ (31 32 33 34)	SAD_ L;				SAD_ new leftover (-- -- -- 34)	T_ 177760 . T;			T_ (31 32 33 --)	L_ T_ XH OR T;			L_ T_ (31 32 33 30)	XREG_ L MRSH 1;			Right cycle 4 bits	L_ T_ XREG;	XREG_ L MRSH 1;	L_ T_ XREG, TASK;	XREG_ L MRSH 1;	MAR_ L_ AC0+1;			Store into destination block	AC0_ L;	L_ T_ XREG;	XREG_ L MRSH 1;			XREG_ (30 31 32 33)	MD_ XREG;; Fetch last 4 bits of fourth Maxc word (35 ** ** **).; SAD has (-- -- -- 34).	MAR_ L_ AC1+1;			Fetch next source word (35 ** ** **)	AC1_ L;	T_ 170000;	T_ MD . T;			T_ (35 -- -- --)	L_ SAD OR T, TASK;		L_ (35 -- -- 34)	XREG_ L MLSH 1;			Left cycle 4 bits	L_ T_ XREG;	XREG_ L MLSH 1;	L_ T_ XREG;	XREG_ L MLSH 1;	L_ AC3-1;	AC3_ L;	L_ T_ XREG, SH=0, TASK;	SAD_ L MLSH 1, :CF36Lp;		[CF36Lp, CF36Dn] SAD_ (-- -- 34 35); Here when doneCF36Dn:	L_ PC, SWMODE, :CnvXit;CF36D1:	L_ PC, SWMODE, :CnvXit;CF36D2:	L_ PC, SWMODE, :CnvXit;CF36D3:	L_ PC, SWMODE, :CnvXit;; Here when possible interrupt (SH<0 branch pending)F36May:	AC1_ L, :F36Int;		[F36Int, F36Dis]; Here to interruptF36Int:	:F32Int;			Store leftover word and quit