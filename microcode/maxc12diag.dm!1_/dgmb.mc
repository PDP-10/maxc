ER[DGMB];	*SECOND HALF OF MEMORY DIAGNOSTIC*NOW TEST OUT THE REF'S USING BOTH FORCED USER AND NOT FORCED SETTINGS*OF XCT0, XCT1, XCT2, AND XCT3 AND WITH THE MAP LOADED WITH THE COMPLEMENT*OF THE ADDRESS PASSED TO TMVAT AND WITH BOTH LEGAL AND ILLEGAL SETTINGS*OF THE ACCESS PERMISSION BITS.TREFS:	CALL[AINI], CLEARF[-1S]; *INITIALIZE ADDRESS TO MLOW*CALL SUBROUTINE TO LOOP OVER 80 VALUES OF DATA AT THE CURRENT ADDRESS.TREF0:	CALL[REFCON];	CALL[AGEN], P_LADR; *LOOP THRU AC ADDRESSES	P-Q;	GOTO[TREF0,ALU>=0];TREF1:	CALL[REFCON];	CALL[AGEN1], Q_LADR;	GOTO[TREF1,ALU>=0];	GOTO[TSTOP];REFCON:	CALL[DINIS1];		*INITIALIZE DATA TO 1	CALL[SREF], CLEARF[-1S]; *TEST ALL THE REFS AT THIS ADDRESS AND DATA	CALL[BDADV];		*CYCLE THE DATA	GOTO[.-2,Q EVEN];	*LOOP TO TRY 40 VALUES OF DATA	CALL[DINIS0];		*INITIALIZE DATA TO -2	CALL[SREF];	CALL[BDADV];	GOTO[.-2,ALU<0];	RETURN;SREF:	P_MHIGH, Q_LADR;	Q_P AND NOT Q, MAPVA_Q, CALL[Q33];	MAP_Q, SETF[CUM], PQ RCY [33]; *MON. MAP ENTRY_ COMPLEMENT OF PG. NO.	Q_P, P_LADR, BAMASK[11];	RTEMP_P OR Q, Q_RP&WP&XP; *RTEMP_ WHAT MAR SHOULD BE AFTER REF	MAP_Q, LTEMP_P, CLEARF[-1S]; *700000 (NO ACCESS AND PG 0) TO USER MAP	P_LADR;	MAPVA_P;	GOTO[TREFAC,G=1], Q_(MAP) U (RP&WP&XP);*FIRST CHECK EACH OF THE REFS IN MONITOR MODE WITH THE APPROPRIATE MAP ACCESS*BIT SET TO 1 (PREVENTING ACCESS TO THE PAGE).	NONE OF THESE REFS SHOULD*ACTIVATE THE MEMORY INTERFACE.	MDR_NULL, P_RTEMP;	WRITE_P;		*PUT A KNOWN VALUE IN MEMORY SO THAT WE CAN				*CHECK LATER TO FIND OUT IF THE WRITE IMPROPERLY				*TOOK PLACE	Q_MAP;	Q_(NOT Q) U (RP&WP&XP);	Q_(NOT Q) U (WP);	MAP_Q, P_LADR;	MAPVA_P;IWREF:	WREF, MDR_SDATA, CALL[CBRK,G=1], INHINT; *MAPVA_ INCONSISTENTLY				*YIELDED G=0 EARLIER BUT NOW G=1	P_MDRL_SDATAL, CALL[CBRK,G=0];	*WREF ILLEGAL SO G SHOULD BE 1	RTEMP1_P, CALL[CBRK,H=1], SETSF[CUM&H]; *NOT XCTI#0 SO H SHOULD BE 0	CALL[CBRK,H=1];	 *CUM SHOULD BE 0 SINCE UM=0 AND XCTI=0	P_MAR, Q_RTEMP, CALL[PQCOMP]; *MEMORY ADDRESS INCORRECT	P_LADR, SETF[XCTN];	MAPVA_P;IWDXK:	WREFDXK, CALL[CBRK,G=1];	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=1];	P_MAR, Q_RTEMP, CALL[PQCOMP];	MDRL_SDATAL, P_LADR, CALL[CBRK,G=0];*CHECK RMWREF ILLEGAL DUE TO WP=0	MAPVA_P;IRMWREFA: RMWREFDXK, INHINT, MDR_MHIGH, CALL[CBRK,G=1];	CALL[IRFCHK];	P_LADR;	MAPVA_P;	RMWREF, INHINT, MDR_MHIGH, CALL[CBRK,G=1];	CALL[IRFCHK];	Q_MAP, CLEARF[-1S];	Q_(NOT Q) U (RP&WP&XP);	Q_(NOT Q) U (RP);	P_LADR, MAP_Q;	MAPVA_P;IIREF:	IREF, MDR_MHIGH, CALL[CBRK,G=1]; *MAPVA_ SCREWED UP	CALL[IRFCHK];		*MHIGH IS USED TO TEST WHETHER READ WRONGLY				*TAKES PLACEIRREF:	RREF, MDR_MHIGH, CALL[CBRK,G=1];	CALL[IRFCHK];*CHECK RMWREF ILLEGAL DUE TO RP=0IRMWREF: MDR_MHIGH, RMWREF, INHINT, CALL[CBRK,G=1];	CALL[IRFCHK];	SETF[XCTN], P_LADR;	MAPVA_P;	RMWREFDXK, MDR_MHIGH, CALL[CBRK,G=1];	CALL[IRFCHK];	Q_MAP;	Q_(NOT Q) U (RP&WP&XP);	Q_(NOT Q) U (XP);	MAP_Q;IXREF:	XREF, MDR_MHIGH, CALL[CBRK,G=1];	CALL[IRFCHK];*NOW TEST LEGAL MONITOR MODE REFERENCES	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (WP);	Q_NOT Q;		*PERMIT ONLY WRITES	MAP_Q, SETF[CUM&NXCT3], P_LADR; *NOW PERMITTING ONLY MONITOR WRITES	MAPVA_P;*TEST WREF WITH UM=G=H=WP=0, CUM=XCT0=XCT1=XCT2=RP=XP=1WREFM:	WREF, MDR_SDATA, INHINT, CALL[CBRK,G=1];	CALL[CBRK,G=1], MDRL_SDATAL; *WREF SHOULD SUCCEED SINCE G=0 BEFORE				*AND WP=0 IN MAP	CALL[CBRK,H=1], SETSF[CUM&H]; *XCT3=0 SO H SHOULD BE 0	CALL[CBRK,H=1];	 *CUM SHOULD BE 0 SINCE UM=0 AND XCT3=0	P_MAR, Q_RTEMP, CALL[PQCOMP];	*MAR SHOULD BE [Q]*NOW TEST READS BACK WITH EACH OF THE FOUR REFS THAT READ	CLEARF[-1S], MDR_NULL, CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP);	Q_NOT Q;		*ONLY READ ACCESS PERMITTED	MAP_Q, SETF[CUM&NXCT0], P_LADR, CALL[RETN];	MAPVA_P;IREFM:	IREF, CALL[CBRK,G=1];	*[P]#AC REF	CALL[MRCHK];	SETF[CUM&NXCT1];	MAPVA_P;RREFM:	RREF, CALL[CBRK,G=1];	*[P]#AC REF	CALL[MRCHK];	SETF[CUM&XCTN];	MAPVA_P;RDXKM:	RREFDXK, CALL[CBRK,G=1];	CALL[MRCHK];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP&WP);	Q_NOT Q;	MAP_Q, P_LADR, SETF[CUM&NXCT1];	MAPVA_P;RMWREFM: RMWREF, CALL[CBRK,G=1], INHINT;	CALL[MRCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	SETF[CUM&XCTN], P_LADR;	MAPVA_P;RMWDXKM: RMWREFDXK, INHINT, CALL[CBRK,G=1];	CALL[MRCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (XP);	Q_NOT Q;	MAP_Q, P_LADR;	SETF[CUM&XCTN];	MAPVA_P;XREFM:	XREF, CALL[CBRK,G=1];	CALL[MRCHK];*NOW CHECK LEGAL WRITE AND READS WITH XCTI=1 AND CFM=1 (SHOULD GET SAME RESULT*AS MONITOR MODE REFERENCES ABOVE)	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (WP);	Q_NOT Q;	MAP_Q, SETF[CFM&CUM&XCT3], P_LADR;	MAPVA_P;WREFCFM: WREF, MDR_SDATA, INHINT, CALL[CBRK,G=1];	CALL[CBRK,G=1], MDRL_SDATAL;	CALL[CBRK,H=0], SETSF[CUM&H];	CALL[CBRK,H=1];	P_MAR, Q_RTEMP, CALL[PQCOMP];	CLEARF[-1S], MDR_NULL, CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP);	Q_NOT Q;	MAP_Q, SETF[CFM&CUM&XCT0], P_LADR;	MAPVA_P;IREFCFM: IREF, CALL[CBRK,G=1];	CALL[CFMCHK];	SETF[CFM&CUM&XCT1];	MAPVA_P;RREFCFM: RREF, CALL[CBRK,G=1];	CALL[CFMCHK];	SETF[CFM&CUM&XCTN];	MAPVA_P;RDXKCFM: RREFDXK, CALL[CBRK,G=1];	CALL[MRCHK];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP&WP);	Q_NOT Q;	MAP_Q, P_LADR, SETF[CFM&CUM&XCT1];	MAPVA_P;RMWREFCFM: RMWREF, INHINT, CALL[CBRK,G=1];	CALL[CFMCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	SETF[CFM&CUM&XCTN], P_LADR, CALL[RETN];	MAPVA_P;RMWDXKCFM: RMWREFDXK, INHINT, CALL[CBRK,G=1];	CALL[MRCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (XP);	Q_NOT Q;	MAP_Q, P_LADR, SETF[CFM&CUM&XCTN];	MAPVA_P;XREFCFM: XREF, CALL[CBRK,G=1];	CALL[MRCHK];*NOW CHECK A LEGAL WRITE AND LEGAL READS IN EACH OF THREE FORCED USER MODES	CLEARF[-1S], P_LADR, CALL[RETN];	Q_(MAP) U (RP&WP&XP); *TURN-OFF ALL ACCESS TO MONITOR MAP ENTRY	SETF[CUM&H], MAP_Q, CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (WP);	Q_NOT Q;	MAP_Q, CLEARF[-1S], P_LADR; *PERMIT WRITE ACCESS TO USER MAP ENTRY	SETF[XCT3];	MAPVA_P;	WREF, MDR_SDATA, CALL[CBRK,G=1], INHINT; *NOT ACWREFFU:	CALL[CBRK,G=1], MDRL_SDATAL;	CALL[CBRK,H=0], SETSF[CUM&H]; *SHOULD BE TO USER MODE	CALL[CBRK,H=0];	P_MAR, Q_LTEMP, CALL[PQCOMP]; *MAR SHOULD BE [Q]*NOW TEST THE READS BACK	CLEARF[-1S], MDR_NULL;	SETF[CUM&H], CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP);	Q_NOT Q, SETF[XCT0];	MAP_Q, CLEARF[CUM], P_LADR;	MAPVA_P;IREFFU:	IREF, CALL[CBRK,G=1];	CALL[FURCHK];	SETF[CUM&H], CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP&WP);	Q_NOT Q;	MAP_Q, P_LADR, SETF[XCT1];	MAPVA_P;RMWREFFU: RMWREF, CALL[CBRK,G=1], INHINT;	CALL[FURCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	CLEARF[-1S], P_LADR;	SETF[XCT1];	MAPVA_P;RREFFU:	RREF, CALL[CBRK,G=1];	CALL[FURCHK];*THERE IS NO XREF FU SINCE ALL XCT'S GO TO MONITOR MODE*NOW TEST NORMAL USER REF'S	P_MAP;	Q_RP&WP&XP;	MAP_Q, SETF[CUM], Q_P AND NOT Q;	Q_(Q) U (NWP);	MAP_Q, CLEARF[-1S], P_LADR;	*PERMIT ONLY WRITES	SETF[UM];	MAPVA_P;WREFU:	WREF, CALL[CBRK,G=1], MDR_SDATA, INHINT;	CALL[CBRK,G=1], MDRL_SDATAL;	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=0];	P_MAR, Q_RTEMP, CLEARF[-1S], CALL[PQCOMP];*NOW TEST NORMAL USER READ REFS	SETF[CUM&H], MDR_NULL, CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP);	Q_NOT Q, SETF[UM];	MAP_Q, CLEARF[CUM], P_LADR;	MAPVA_P;IREFU:	IREF, CALL[CBRK,G=1];	*NOT TO AC	CALL[URCHK];	SETF[UM];	MAPVA_P;RREFU:	RREF, CALL[CBRK,G=1];	CALL[URCHK];	SETF[CUM&H], CALL[RETN];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (RP&WP);	Q_NOT Q;	MAP_Q, CLEARF[-1S], P_LADR;	SETF[UM];	MAPVA_P;RMWREFU: RMWREF, INHINT, CALL[CBRK,G=1];	CALL[URCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	SETF[UM];	P_MAR, Q_RTEMP, CALL[PQCOMP];	*WRESTART SMASHED MAR	MAPVA_SADR, ACFS;RMWDXKU: RMWREFDXK, INHINT, CALL[CBRK,G=1];	CALL[URCHK];	Q_NOT Q, P_SDATAL, CALL[NDGEN];	SETF[UM];	P_MAR, Q_RTEMP, SETF[CUM&H], CALL[PQCOMP];	Q_(MAP) U (RP&WP&XP);	Q_(NOT Q) U (XP);	Q_NOT Q;	MAP_Q, CLEARF[-1S], P_LADR;	SETF[UM];	MAPVA_P;XREFU:	XREF, CALL[CBRK,G=1];	CALL[URCHK];	RETURN;		 ******FINISH THIS LATER*CHECK AFTERMATH OF AC REFERENCE IN MONITOR MODEAMRCHK:	CALL[CBRK,H=1], SETSF[CUM&H];AMCHK1:	P_MAR, Q_RTEMP, CALL[PQCOMP];	CALL[CBRK,H=1], P_RP&WP&XP;	Q_MDR, CALL[PQCOMP];	CLEARF[-1S], P_LADR, RETURN;*CHECK AFTERMATH OF AC REF IN MON MODE WITH BOTH XCTI AND CFM SETACFMCHK: CALL[CBRK,H=0], SETSF[CUM&H];	GOTO[AMCHK1];*CHECK AFTERMATH OF AC REF IN MON MODE FORCED TO USER MODE BY AN XCTIAFURCHK: CALL[CBRK,H=0], SETSF[CUM&H];	P_MAR, Q_LTEMP, CALL[PQCOMP];	CALL[CBRK,H=0], P_XCTN;	Q_MDR, CALL[PQCOMP];	CLEARF[-1S], P_LADR, RETURN;*CHECK AFTERMATH OF USER MODE AC REFSAURCHK:	CALL[CBRK,H=1], SETSF[CUM&H]; *NOT A FORCED USER REF	P_MAR, Q_LTEMP, CALL[PQCOMP];	*MEMORY ADDRESS NOT FROM USER MAP	CALL[CBRK,H=0], P_MHIGH;	*CUM SHOULD BE 1 SINCE UM WAS 1	Q_MDR, CALL[PQCOMP];	*MDR SHOULDN'T HAVE CHANGED SINCE AC REF	CLEARF[-1S], P_LADR;	SETF[UM];	MAPVA_P, RETURN;*TEST OUT THE REF'S ON AC REFERENCES.  G=DON'T CARE AFTER TO REF TO AC*SINCE COMPLETE ACCESS ALLOWED TO AC'S SO THAT MAP PROTECTION DOESN'T*APPLY.	HOWEVER, G=ACCESS TO PAGE SAME AS NON-AC REF WOULD BE MORE*GENERAL.  H=FORCED USER MODE.  CUM MUST BE SET PER UM/XCTI.*MAR MUST BE LOADED FROM 12 BITS OF MAP ENTRY SAME AS NON-AC REF.*MEMORY INTERFACE MUST NOT BE STARTED WHICH MEANS THAT MDR MUST NOT*BE CLOBBERED ON READS AND MEMORY NOT CLOBBERED BY WRITESTREFAC:	MDR_NULL, P_RTEMP;	*INITIALIZE THE MEMORY TO A VALUE				*SO THAT WE CAN READ IT BACK LATER AND				*CHECK FOR ITS GETTING CLOBBERED	WRITE_P;	Q_MAP;	Q_(NOT Q) U (RP&WP&XP);	Q_NOT Q;	MAP_Q, SETF[CUM], CALL[RETN];	*ALLOW COMPLETE ACCESS TO MONITOR PAGE 0				*SINCE THIS IS WORST CASE FOR LETTING THE				*MEMORY INTERFACE START INCORRECTLY	Q_MAP;	Q_(NOT Q) U (RP&WP&XP);	Q_NOT Q, MDRL_-1S;	MAP_Q, SETF[CUM&NXCT3], P_LADR, CALL[RETN]; *COMPLETE ACCESS TO USER PAGE 0 ALSO	MAPVA_P;ACWM:	WREF, MDR_A1, CALL[CBRK,G=0]; *SHOULD NEVER BE G=0 HERE	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=1];	P_MAR, Q_RTEMP, CALL[PQCOMP]; *MAR # [Q]	CLEARF[-1S], CALL[QLCY6];	*GIVE MEMORY PLENTY OF TIME TO WRITE				*IF IT WANTS TO	P_LADR, SETF[CUM&XCTN], CALL[RETN];	MAPVA_P;ACWDXKM: WREFDXK, CALL[CBRK,G=0];	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=1];	P_MAR, Q_RTEMP, CALL[PQCOMP];	CLEARF[-1S];	P_LADR, SETF[CUM&NXCT0], CALL[RETN];	MAPVA_P;ACIM:	IREF, CALL[CBRK,G=0], MDR_RP&WP&XP; *AC REF'S LEAVE G=1	CALL[AMRCHK];	SETF[CUM&NXCT1], CALL[RETN];	MAPVA_P;ACRM:	RREF, CALL[CBRK,G=0], MDR_RP&WP&XP;	CALL[AMRCHK];	SETF[CUM&XCTN], CALL[RETN];	MAPVA_P;ACRDXKM: RREFDXK, CALL[CBRK,G=0], MDR_RP&WP&XP;	CALL[AMRCHK];	SETF[CUM&NXCT1], CALL[RETN];	MAPVA_P;ACRMWM:	RMWREF, CALL[CBRK,G=0], MDR_RP&WP&XP, INHINT;	CALL[AMRCHK];	SETF[CUM&XCTN], CALL[RETN];	MAPVA_P;ACRMWDXKM: RMWREFDXK, CALL[CBRK,G=0], MDR_RP&WP&XP, INHINT;	CALL[AMRCHK];	SETF[CUM&XCTN], CALL[RETN];	MAPVA_P;ACXM:	XREF, CALL[CBRK,G=0], MDR_RP&WP&XP;	CALL[AMRCHK];*NOW CHECK A WRITE AND READS WITH BOTH CFM AND XCTI SET	P_LADR, SETF[CFM&CUM&XCT3], CALL[RETN];	MAPVA_P;ACWCFM:	WREF, MDR_A1, CALL[CBRK,G=0];	CALL[CBRK,H=0], SETSF[CUM&H];	CALL[CBRK,H=1];	P_MAR, Q_RTEMP, CALL[PQCOMP];	CLEARF[-1S];	P_LADR, SETF[CFM&CUM&XCTN], CALL[RETN];	MAPVA_P;ACWDXKCFM: WREFDXK, CALL[CBRK,G=0];	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=1];	P_MAR, Q_RTEMP, CALL[PQCOMP];	CLEARF[-1S];	P_LADR, SETF[CFM&CUM&XCT0], CALL[RETN];	MAPVA_P;ACICFM:	IREF, CALL[CBRK,G=0], MDR_RP&WP&XP;	CALL[ACFMCHK];	SETF[CFM&CUM&XCT1], CALL[RETN];	MAPVA_P;ACRCFM:	RREF, CALL[CBRK,G=0], MDR_RP&WP&XP;	CALL[ACFMCHK];	SETF[CFM&CUM&XCTN], CALL[RETN];	MAPVA_P;ACRDXKCFM: RREFDXK, MDR_RP&WP&XP, CALL[CBRK,G=0];	CALL[AMRCHK];	SETF[CFM&CUM&XCT1], CALL[RETN];	MAPVA_P;ACRMWCFM: RMWREF, CALL[CBRK,G=0], INHINT, MDR_RP&WP&XP;	CALL[ACFMCHK];	SETF[CFM&CUM&XCTN], CALL[RETN];	MAPVA_P;ACRMWDXKCFM: RMWREFDXK, CALL[CBRK,G=0], MDR_RP&WP&XP, INHINT;	CALL[AMRCHK];	SETF[CFM&CUM&XCTN], CALL[RETN];	MAPVA_P;ACXCFM:	XREF, CALL[CBRK,G=0], MDR_RP&WP&XP;	CALL[AMRCHK];*NOW CHECK A WRITE AND READS WHICH FORCE USER MODE	SETF[XCT3], CALL[RETN];	MAPVA_P;ACWFU:	WREF, MDR_A1, CALL[CBRK,G=0];	CALL[CBRK,H=0], SETSF[CUM&H];	CALL[CBRK,H=0];	 *XCT3 DIDN'T SET CUM=1	P_MAR, Q_LTEMP, CALL[PQCOMP];	CLEARF[-1S], CALL[QLCY6];	P_LADR, SETF[XCT0], CALL[RETN];	MAPVA_P;ACIFU:	IREF, CALL[CBRK,G=0], MDR_XCTN;	CALL[AFURCHK];	SETF[XCT1], CALL[RETN];	MAPVA_P;ACRFU:	RREF, MDR_XCTN, CALL[CBRK,G=0];	CALL[AFURCHK];	SETF[XCT1], CALL[RETN];	MAPVA_P;ACRMWFU: RMWREF, MDR_XCTN, CALL[CBRK,G=0], INHINT;	CALL[AFURCHK];*NOW CHECK A WRITE AND READS IN USER MODE	SETF[UM];	MAPVA_P;ACWU:	WREF, MDR_A1, CALL[CBRK,G=0];	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=0];	CLEARF[-1S], P_MAR, Q_LTEMP, CALL[PQCOMP];	SETF[UM], P_LADR;	MAPVA_P;ACWDXKU: WREFDXK, MDR_A1, CALL[CBRK,G=0], INHINT;	CALL[CBRK,H=1], SETSF[CUM&H];	CALL[CBRK,H=0];	CLEARF[-1S], P_MAR, Q_LTEMP, CALL[PQCOMP];	SETF[UM], P_LADR;	MAPVA_P;ACIU:	IREF, CALL[CBRK,G=0], MDR_MHIGH;	CALL[AURCHK];ACRU:	RREF, CALL[CBRK,G=0], MDR_MHIGH;	CALL[AURCHK];ACRDXKU: RREFDXK, MDR_MHIGH, CALL[CBRK,G=0];	CALL[AURCHK];ACRMWU:	RMWREF, CALL[CBRK,G=0], MDR_MHIGH, INHINT;	CALL[AURCHK];ACRMWDXKU: RMWREFDXK, CALL[CBRK,G=0], MDR_MHIGH;	CALL[AURCHK];ACXU:	XREF, CALL[CBRK,G=0], MDR_MHIGH;	CALL[AURCHK];*NOW MAKE SURE MEMORY AC IS STILL 0 AFTER ALL THIS MACHINATION WHEN THE*MEMORY INTERFACE WAS PRESUMED INACTIVE	P_RTEMP;	READ_P, CALL[RETN];	Q_MDR, CALL[QZT];	*MEMORY CLOBBERED BY AC REFERENCE	RETURN;TSTOP:	GOTO[MCYCLE];		******TEMPORARY END OF DIAG.	IM[ILC,ADD[IP[ILC],-1]]; *BACK UP PC IN CASE MORE DIAG ARE BEING				*ASSEMBLED