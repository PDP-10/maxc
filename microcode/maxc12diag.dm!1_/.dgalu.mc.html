<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12diag.dm!1>dgalu.mc</title>
  </head>
  <body>
    <pre>
ER[DGALU];	*RANDOM NUMBER TEST OF P, Q, AND ALU%TO ASSEMBLE:	MICRO/L LANG DGALU -OR- MICRO/L LANG2 DGALUTO RUN:		MIDAS RDGALU		START;GCURRENT SOURCES ON TENEX &lt;ERF&gt; DIRECTORY.%SM[SY10,10];SM[SLC,0]; TARGET[SLC];	*CONSTANTS FOR P-REGISTER MASK SIMULATION0V;		1V;		3V;		7V;17V;		37V;		77V;		177V;377V;		777V;		1777V;		3777V;7777V;		17777V;		37777V;		77777V;177777V;	377777V;	777777V;	1 777777V;3 777777V;	7 777777V;	17 777777V;	37 777777V;77 777777V;	177 777777V;	377 777777V;	777 777777V;1777 777777V;	3777 777777V;	7777 777777V;	17777 777777V;37777 777777V;	77777 777777V;	177777 777777V;	377777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;777777 777777V;	777777 777777V;	777777 777777V;	777777 777777V;*ORIGINAL VALUES FOR RANDOM NO. GENERATOR*MUST BE AT BOUNDARY OF 8X0:	7654321V;X1:	76543210V;X2:	765432100V;X3:	7654321000V;X4:	76543210000V;X5:	765432100000V;X6:	654321000007V;X7:	543210000076V;@X0:	E1[X0];@X7:	E1[X7];SVN[YRAN]; SVN[COUNT]; SVN[RANP]; SVN[STEMP]; SVN[SMDATA]; MC[J,J];RVN[RDATA]; RVN[RTEMP]; LVN[LDATA]; LVN[MDATA];IM[ILC,20]; TARGET[ILC];MCYCLE:	BRKP[1], COUNT&larr;Q, GOTO[NXTNUM];START:	ARM&larr;NULL, INHINT, DGOTO[NXTNUM];	IRET, INHINT, COUNT&larr;NULL, CALL[INIRAN];PQCOMP:	P#Q;	RETURN[ALU=0];	BRKP[1], RETURN;RETN:	RETURN;*INITIALIZE RANDOM NO. GENERATORINIRAN:	Y&larr;@X7;	RANP&larr;Y, RETURN;*RETURN RANDOM NO. IN Q (USES Y WHICH MUST NOT BE CLOBBERED), CLOBBERS PRGEN:	Y&larr;P&larr;RANP;	Q&larr;@X0;	P-Q-1, P&larr;SY, DECY;	Q&larr;SY, GOTO[.+2,ALU&gt;=0];	A0, Y&larr;@X7, GOTO[.-1];	Q&larr;P+Q, RANP&larr;Y;	SY&larr;Q, RETURN;*SAVE RANDOM NO. GENERATOR STATE IN SM FOR RESTORATION LATERRMARK:	Y&larr;RANP;	YRAN&larr;Y;			*SAVE POINTER	P&larr;@X0;	Y&larr;@X7;	Q&larr;Y;	P-Q, Q&larr;SY, DGOTO[.-1];	SY10&larr;Q, DECY, RETURN[ALU&gt;=0];*RESTORE RANDOM NO. GENERATOR STATERREST:	Y&larr;YRAN;	RANP&larr;Y;	P&larr;@X0;	Y&larr;@X7;	Q&larr;Y;	P-Q, Q&larr;SY10, DGOTO[.-1];	SY&larr;Q, DECY, RETURN[ALU&gt;=0];*SUBROUTINE USED BY SMASKT AND AMASKTSAMT:	MDR&larr;P;	P&larr;SY, Q&larr;RDATA;	P&larr;MDR, Q&larr;P AND Q, INCY, GOTO[PQCOMP];*SUBROUTINE USED BY BAMASKTBAMT:	INCY, Q&larr;P AND Q, P&larr;MDR, GOTO[PQCOMP];*DIAGNOSTIC STARTS HERENXTNUM:	CALL[RGEN];	LDATA&larr;Q, CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];	SMDATA&larr;MDATA&larr;Q;RBLT:	P&larr;Q&larr;RDATA, CALL[PQCOMP];	GOTO[.+1];LBLT:	P&larr;Q&larr;LDATA, CALL[PQCOMP];	GOTO[.+1];QLSHT:	Q&larr;RDATA;	Q LSH 1, DECY, AQ, B&larr;SY;	*DECY, AQ, B&larr;SY FOR NOISE EFFECT	MDR&larr;Q, P&larr;RDATA, Q&larr;A0;	PQ LCY [1], Q&larr;MDR, CALL[PQCOMP]; *P/ RDATA LSH 1 VIA PQ LCY [1]	GOTO[.+1];			*Q/ RDATA LSH 1 VIA Q LSH 1QRSHT:	Q&larr;RDATA;	Q RSH 1, DECY, NOT Q, B&larr;SY;	MDR&larr;Q, P&larr;RDATA, Q&larr;A0;	PQ RCY [1], Q&larr;MDR, CALL[PQCOMP]; *P/ RDATA RSH 1 VIA PQ RCY [1]	GOTO[.+1];			*Q/ RDATA RSH 1 VIA Q RSH 1QRBR1T:	P&larr;(RDATA) RSH [1], Q&larr;(RDATA) RSH 1, CALL[PQCOMP];	GOTO[.+1];			*P/ RDATA RSH 1 VIA RM RSH 1					*Q/ RDATA RSH 1 VIA RM RSH 1SADDT:	P&larr;LDATA, Q&larr;RDATA;	MDR&larr;P&larr;P+Q;	P&larr;P-Q, Q&larr;LDATA, CALL[PQCOMP];	*P/ LDATA+RDATA-RDATA	GOTO[.+1];			*Q/ LDATAASUBT:	P&larr;LDATA, Q&larr;RDATA;	MDR&larr;P&larr;P-Q-1;	P&larr;P+Q+1, Q&larr;LDATA, CALL[PQCOMP];	*P/ LDATA-RDATA-1+RDATA+1	GOTO[.+1];			*Q/ LDATA VIA LMP1TST:	P&larr;LDATA;	P&larr;P1, Q&larr;P, CALL[PQCOMP];		*P/ LDATA VIA P1	GOTO[.+1];			*Q/ LDATA VIA ALU	Q&larr;LDATA, P&larr;P1, CALL[PQCOMP];		*P/ LDATA VIA P1	GOTO[.+1];			*Q/ LDATA VIA LMALUR1T:	P&larr;RDATA, A0, Q&larr;(RDATA) RSH 1;	P&larr;(P) ARSHC 1, CALL[PQCOMP];		*P/ RDATA RSH 1 VIA ALU RSH 1	GOTO[.+1];			*Q/ RDATA RSH 1 DIRECTRBRCT:	Q&larr;RDATA;	QQ RCY [1], Q&larr;(RDATA) RCY 1, CALL[PQCOMP];	GOTO[.+1];			*P/ RDATA RCY 1 VIA QQ RCY					*Q/ RDATA RCY 1 DIRECTYXMASKT:	Q&larr;RDATA, P&larr;77S;	X&larr;P AND Q;	P&larr;LDATA, XMASK, Y&larr;X;	RTEMP&larr;P, P&larr;SY, Q&larr;LDATA;	P&larr;P AND Q, Q&larr;RTEMP, CALL[PQCOMP]; *PROBABLY FAILURE OF P&larr;LDATA, XMASK	GOTO[.+1];			*P/ GOOD VALUE					*Q/ P&larr;LDATA, XMASK*ON TESTS BELOW, FAILURE IS PROBABLY ON P&larr;RDATA, SAMASK.  ON FAILURE:*P/ RESULT OF P&larr;RDATA, SAMASK VIA MDR*Q/ CORRECT VALUE VIA Q&larr;P AND QSMASKT:	Y&larr;NULL, P&larr;RDATA, Q&larr;LDATA, SAMASK[0], CALL[SAMT];	SET[TT,1];REPEAT[77,ILC[(P+Q, P&larr;RDATA, Q&larr;LDATA, SAMASK[TT], CALL[SAMT])]	SET[TT,ADD[TT,1]]];		*P+Q FOR NOISE AFFECT*ON TESTS BELOW, FAILURE IS PROBABLY ON P&larr;RDATA, AMASK.  ON FAILURE:*P/ RESULT OF P&larr;RDATA, AMASK VIA MDR*Q/ CORRECT VALUE VIA Q&larr;P AND QAMASKT:	Y&larr;NULL, P&larr;RDATA, Q&larr;LDATA, AMASK[0], CALL[SAMT];	SET[TT,1];REPEAT[37,ILC[(P&larr;RDATA, Q&larr;LDATA, AMASK[TT], CALL[SAMT])]	SET[TT,ADD[TT,1]]];*ON TESTS BELOW, FAILURE IS PROBABLY ON P&larr;LDATA, BAMASK.  ON FAILURE:*P/ RESULT OF P&larr;LDATA, BAMASK VIA MDR*Q/ CORRECT RESULT VIA Q&larr;P AND QBAMSKT:	Y&larr;NULL, P&larr;LDATA, Q&larr;RDATA, BAMASK[0]; *Q&larr;RDATA FOR NOISE AFFECT	MDR&larr;P, Q&larr;LDATA;	P&larr;SY, CALL[BAMT];	SET[TT,1];REPEAT[77,ILC[(P&larr;LDATA, Q&larr;SY, BAMASK[TT])]	ILC[(MDR&larr;P, P&larr;Q, Q&larr;LDATA, CALL[BAMT])]	SET[TT,ADD[TT,1]]];PQCYCT:	P&larr;RDATA, Q&larr;44S, AMASK[6];	P-Q;	Y&larr;P, PQ RCY [1], GOTO[.-1,ALU&gt;=0]; *Y&larr;NUMBER .L. 44	P&larr;RDATA, Q&larr;LDATA;	PQ RCY [Y], DECY, STEMP&larr;Y;	MDR&larr;P, P&larr;LDATA, Q&larr;RDATA, DECY, GOTO[.+2,Y&lt;0];	Q RSH 1, PQ RCY [1], ASHOVF, DECY, GOTO[.,Y&gt;=0];	P&larr;MDR, CALL[PQCOMP];		*P/ RESULT OF PQ RCY [STEMP]	GOTO[.+1];			*Q/ SAME RESULT VIA Q RSH 1, ASHOVF0QCYCT:	P&larr;RDATA, Q&larr;44S, AMASK[6];	P-Q;	Y&larr;P, PQ RCY [1], GOTO[.-1,ALU&gt;=0]; *Y&larr;NUMBER .L. 44	P&larr;RDATA, Q&larr;LDATA;	0Q RCY [Y], DECY, STEMP&larr;Y, Q&larr;A0;	MDR&larr;P, P&larr;LDATA, DECY, GOTO[.+2,Y&lt;0];	Q RSH 1, PQ RCY [1], ASHOVF, DECY, GOTO[.,Y&gt;=0];	P&larr;MDR, CALL[PQCOMP];		*P/ RESULT OF 0Q RCY [STEMP]	GOTO[.+1];			*Q/ SAME RESULT VIA Q RSH 1QQCYCT:	P&larr;RDATA, Q&larr;44S, AMASK[6];	P-Q;	Y&larr;P, PQ RCY [1], GOTO[.-1,ALU&gt;=0];	P&larr;RDATA, Q&larr;LDATA;	QQ RCY [Y], DECY, STEMP&larr;Y;	MDR&larr;P, P&larr;Q&larr;LDATA, DECY, GOTO[.+2,Y&lt;0];	Q RSH 1, PQ RCY [1], ASHOVF, DECY, GOTO[.,Y&gt;=0];	P&larr;MDR, CALL[PQCOMP];		*P/ RESULT OF QQ RCY [STEMP]	GOTO[.+1];			*Q/ SAME RESULT VIA Q RSH 1%THE SLOWEST ALU PATHS ARE P MASKING, NOT(ALU)Q RCY [Y] WITH ARITHMETIC THROUGH ALU AND INPUT CARRY COMPLEMENTING THE PREVIOUS INSTRUCTION.WORST CASES ARE XMASK AFTER X&larr;SLOW SOURCE, RCY [Y] AFTER Y&larr;FAST SOURCE.THESE COMBINATIONS ARE TESTED BELOW.**NOTE:  RCY [Y] IS ILLEGAL AFTER LOADING Y FROM SLOW SOURCE AND RCY [44-Y]**AFTER ANY LOAD OF Y.%SLOWT1:	Y&larr;SMDATA;	P&larr;RDATA, Q&larr;LDATA;	NOT(P+Q+1)Q RCY [44-Y];		*F2 = CARRY1	MDR&larr;P, P&larr;RDATA, Q&larr;LDATA;	P&larr;P+Q+1;	P&larr;NOT P;	PQ RCY [44-Y], Q&larr;MDR, CALL[PQCOMP,H=0]; *P/ RESULT VIA QUICK PATHS	GOTO[.+1];			*Q/ RESULT VIA SLOW PATHSSLOWT2:	Q&larr;MDATA;	P&larr;RDATA, Q&larr;LDATA, XSPLIT&larr;Q;	*X&larr;Y&larr;FAST SOURCE	NOT(P-Q)Q RCY [Y];		*F2 = CARRY1	MDR&larr;P, P&larr;LDATA, Q&larr;RDATA;	P&larr;P-Q-1, Q&larr;LDATA;		*NOT(RDATA-LDATA) = LDATA-RDATA-1	PQ RCY [Y], Q&larr;MDR, CALL[PQCOMP,H=0]; *P/ RESULT VIA QUICK PATHS	GOTO[.+1];			*Q/ RESULT VIA SLOW PATHSSLOWT3:	Q&larr;MDATA;	P+Q+1, P&larr;LDATA, Q&larr;RDATA, SETSF[J], XSPLIT&larr;Q;	NOT(P+Q)Q RCY [Y];	MDR&larr;P, P&larr;LDATA, Q&larr;RDATA;	P&larr;P+Q;	P&larr;NOT P;	PQ RCY [Y], Q&larr;MDR, CALL[PQCOMP,H=0]; *P/ QUICK RESULT	GOTO[.+1];			*Q/ SLOW RESULTSLOWT4:	Q&larr;MDATA;	P&larr;LDATA, Q&larr;RDATA, Y&larr;Q;	NOT(P-Q)Q RCY [Y];		*F2 = CARRY1	MDR&larr;P, P&larr;LDATA, Q&larr;RDATA;	P&larr;P-Q;	P&larr;NOT P, Q&larr;RDATA;	PQ RCY [Y], Q&larr;MDR, CALL[PQCOMP,H=0]; *P/ QUICK RESULT	GOTO[.+1];			*Q/ SLOW RESULTSLOWT5:	Q&larr;MDATA;	P&larr;LDATA, Q&larr;RDATA, BSPLIT&larr;Q;	NOT(P+Q+1)Q RCY [Y];		*F2 = CARRY1	MDR&larr;P, P&larr;LDATA, Q&larr;RDATA;	P&larr;P+Q+1;	P&larr;NOT P, Q&larr;RDATA;	PQ RCY [Y], Q&larr;MDR, CALL[PQCOMP,H=0]; *P/ QUICK RESULT	GOTO[.+1];			*Q/ SLOW RESULTSLOWT6:	Q&larr;MDATA;	P&larr;LDATA, Q&larr;RDATA, FSPLIT&larr;Q;	NOT(P-Q-1)Q RCY [Y];	MDR&larr;P, P&larr;RDATA, Q&larr;LDATA;	P&larr;P-Q, Q&larr;RDATA;	PQ RCY [Y], Q&larr;MDR, CALL[PQCOMP,H=0]; *P/ QUICK RESULT	GOTO[.+1];			*Q/ SLOW RESULTSLOWT7:	P&larr;RDATA, Q&larr;LDATA, XSPLIT&larr;SMDATA; *X&larr;Y&larr;SLOW BIPOLAR MEM.	Q&larr;B, B&larr;P+Q+1, NEGY;		*F2 = CARRY1, Q&larr;SLOW ALU	PQ RCY [Y], XMASK;	MDR&larr;P, P&larr;RDATA, Q&larr;LDATA;	Q&larr;P+Q+1;	PQ RCY [Y], XMASK, Q&larr;MDR, CALL[PQCOMP,H=0];	GOTO[.+1];			*P/ RESULT VIA QUICK PATHS					*Q/ RESULT VIA SLOW PATHSSLOWT8:	XSPLIT&larr;A1, P&larr;Q&larr;LDATA;	P&larr;RDATA, XSPLIT&larr;Q&larr;B, B&larr;P+Q+1;	*X&larr;Y&larr;SLOW ALU	QQ RCY [Y], XMASK;			*F2 = CARRY1, F1 = RCYQQ	MDR&larr;P, P&larr;Q&larr;LDATA;	P&larr;Q&larr;P+Q+1;	PQ RCY [Y], XMASK, Q&larr;MDR, CALL[PQCOMP,H=0];	GOTO[.+1];			*P/ RESULT VIA QUICK PATHS					*Q/ RESULT VIA SLOW PATHS	P&larr;COUNT;	Q&larr;P+1, GOTO[MCYCLE];</pre>
  </body>
</html>
