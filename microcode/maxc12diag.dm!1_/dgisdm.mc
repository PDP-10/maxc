ER[DGISDM];%DIAGNOSTIC FOR INSTRUCTION, SCRATCH, DISPATCH, AND MAP MEMORIESTHIS FILE IS INCLUDED BY "DGIML" AND "DGIMH" WHICH TEST, RESPECTIVELY, HIGHAND LOW REGIONS OF IM.  FOR SCOPING, VARIABLES "RLOOK" (READING IM)AND "WLOOK" (WRITING IM) CAN BE LOADED WITH AN ADDRESS AND SIGNOVAWILL OCCUR JUST BEFORE THE READ/WRITE OF THE DESIGNATED ADDRESS.DATA COMPARE CAN BE MASKED BY "LMASK" AND "RMASK".RANGE OF IM ADDRESSES TESTED IS FROM "LADDR" TO "HADDR" INCLUSIVE.  THE DATAPATTERNS USED BEGIN AT "LADDR" WITH EACH OF THE 72 PATTERNS CONSISTING OF ASINGLE 0 IN A FIELD OF 1'S AND EACH OF THE 72 PATTERNS CONSISTING OF A SINGLE 1IN A FIELD OF 0'S.  SUBSEQUENT WORDS RECEIVE THE PREVIOUS WORD'S DATA LCY 1.RANDOM NO. PATTERNS ARE USED TO TEST DM, SM, MAP, AND IM AFTER THE 144FIXED PATTERNS FOR IM ARE EXHAUSTED.TO TEST ONLY IM, START AT "TIM".TO TEST ONLY MP, START AT "TMP".TO TEST ONLY SM, START AT "TSM".ON MAXC2, P_ PROVOKES SLOW CHIP FAILURESS BECAUSE P HAS A VERY EARLY WRITEENABLE.  Q_ IS NOT AS GOOD ON EITHER MAXC1 OR MAXC2 BECAUSE IT HAS A LATEWRITE ENABLE.ON MAXC2 PARITY CHECKING CAN BE TURNED ON BY SETTING "PARITY" TO THE PROPERVALUE--SEE THE COMMENT AT THE BOTTOM OF THIS PAGE.%SM[SLC,20]; RM[RLC,0]; LM[LLC,10];RV[X0,7654321];RV[X1,76543210];RV[X2,765432100];RV[X3,7654321000];RV[X4,76543210000];RV[X5,765432100000];RV[X6,654321000007];RV[X7,543210000076];LVN[RAN]; LVN[RRAN]; LVN[XRAN]; LVN[COUNT];LVN[LTEMP]; RVN[RTEMP]; RVN[ICOUNT];LVN[LDATA]; LVN[LDATA1]; RV[LMASK,777777 777777]; LVN[LBASE];RVN[RDATA]; RVN[RDATA1]; LV[RMASK,777777 777777]; RVN[RBASE];RV[WLOOK,0]; RV[RLOOK,0];SVN[ADDR]; RV[AINC,1];RV[SMMASK,777777 777777];RV[MPMASK,777777]; SVN[FSET];LV[PARITY,0];	*400 000000	ENABLES IM PE HALT		*200 000000	ENABLES SM/DM/DM1/DM2 PE HALT		*100 000000	ENABLES MP PE HALTMCYCLE:	BRKP[1], COUNT_P+1, GOTO[LOOP];START:	ARM_Y_NULL, INHINT;	IRET, INHINT, COUNT_A0, GOTO[INITL];PQCOMP:	P#Q;AZT:	RETURN[ALU=0];	BRKP[1];			*IN CASE SINGLE STEPPING	BRKP[1], RETURN;RETN:	RETURN;*INITIALIZE SM, MAP, DM, DM1, AND DM2 LOCATIONS BEFORE ARMING PARITY*(ONLY SM INIT NECESSARY NOW--MP INIT NECESSARY IF SWITCH TO NEW BIPOLAR*BOARD ON MP.)INITL:*~ MAXC2 ONLY	SY_MAP_NULL;	D_NULL;	D1_NULL;	D2_NULL, INCY, GOTO[.-3,Y>=0];	SY_MAP_NULL;	D_NULL;	D1_NULL;	D2_NULL, INCY, Q_PARITY, GOTO[.-3,Y<0];	ARM_Q, DGOTO[7], Q_X7;		*INITIALIZE RANDOM NO. GEN.*~*! MAXC1 ONLY	DGOTO[7], Q_X7;*!	X_NPC, RAN_Q, GOTO[.+1];	CALL[IMCYCT];		*CYCLED 1 AND CYCLED 0 TEST ONCE ONLYLOOP:	CALL[TSTIM];	CALL[TSTMP];	CALL[TSTSM];	P_COUNT, GOTO[MCYCLE];TSTIM:	CALL[IMRANT];	RETURN;TSTMP:	CALL[MPRT1];		*RANDOM DATA, SEQUENTIAL ADDRESSES	CALL[MPRT2];		*RANDOM DATA, SEQUENTIAL ADDRESSES	P_A1, SAMASK[12];	ICOUNT_P-1, CALL[MPRT3];	*RANDOM DATA, RANDOM ADDRESS IN MPTSTMPL:	P_ICOUNT;	ICOUNT_P-1;	RETURN[ALU<0];	CALL[MPRT3L];		*Q/ CORRECT VALUE, P/ MP[Y]	GOTO[TSTMPL];		*MPRT3S;G TO LOOP ON FAILURETSTSM:	CALL[SMDMT1];		*RANDOM DATA, SEQUENTIAL ADDRESSES	P_A1, SAMASK[12], GOTO[SDR1];SDRLP:	CALL[SMT2];		*RANDOM DATA, RANDOM ADDRESS IN SM	CALL[DMT2];		*Q/ CORRECT VALUE, P,MDR/ DM[Y]*~ MAXC2 ONLY	CALL[DM1T2];		*Q/ CORRECT VALUE, P, MDR/ DM1[Y]	CALL[DM2T2];		*Q/ CORRECT VALUE, P, MDR/ DM2[Y]	CALL[SDM1B];*~	P_ICOUNT;SDR1:	ICOUNT_P-1, DGOTO[SDRLP];	RETURN[ALU<0];*START HERE TO TEST ONLY IMTIM:	COUNT_A0;TIMLP:	CALL[TSTIM];	P_COUNT;	COUNT_P+1, GOTO[TIMLP];*START HERE TO TEST ONLY THE MAPTMAP:	COUNT_A0;TMAPLP:	CALL[TSTMP];	P_COUNT;	COUNT_P+1, GOTO[TMAPLP];*START HERE TO TEST ONLY SM, DM, DM1, AND DM2TSM:	COUNT_A0;TSMLP:	CALL[TSTSM];	P_COUNT;	COUNT_P+1, GOTO[TSMLP];%"NIRGEN" IS THE SAME AS "RGEN" BELOW EXCEPT THAT IT LOOPSTO GENERATE THE NEXT RANDOM NUMBER WHENEVER THE BUS SOURCE OR BUSDESTINATION FIELDS SELECTS IM.  THIS BYPASSES A HARDWARE BUG.%NIRG1:	Q_RAN, RETURN[ALU#0];NIRGEN:*! MAXC1 ONLY BUG	P_RAN, Q_RX, GOTO[NIRG2,X>=0];	Q_X7, DGOTO[6];	X_NPC, RAN_X7_Q_P+Q, GOTO[.+1];NIRG3:	P_1634 000000L;	Q_P#Q, P_7600 000000L;	P AND Q, P_174 000000L, DGOTO[NIRG1]; *BS=IM=7?	P AND Q, GOTO[NIRGEN,ALU=0]; *BD=IM=7?NIRG2:	RX_RAN_Q_P+Q, DECX, GOTO[NIRG3];*!*RETURN RANDOM NO. IN Q (USES X WHICH MUST NOT BE CLOBBERED), CLOBBERS PRGEN:	P_RAN, Q_RX, GOTO[RGEN1,X>=0];	DGOTO[6], Q_X7;	X_NPC, RAN_X7_Q_P+Q, RETURN;RGEN1:	RX_RAN_Q_P+Q, DECX, RETURN;*SAVE RANDOM NO. GEN. STATE IN LM FOR RESTORATION LATER.  RETURN RANDOM NO. IN Q.RMARK:	P_X, DGOTO[7], Q_RAN;	X_NPC, GOTO[.+1], RRAN_Q;	Q_RX, GOTO[.+2,X<0], XRAN_P;	LX_Q, DECX, GOTO[.-1];PXRET:	X_P, Q_RAN, GOTO[NIRGEN];*RESTORE RANDOM NO. GEN FROM LMRREST:	P_RRAN, DGOTO[7];	X_NPC, RAN_P, GOTO[.+1];	Q_LX, GOTO[PXRET,X<0];	RX_Q, P_XRAN, DECX, GOTO[.-1];MPCOMP:	LTEMP_Q_P, P_Q, SAMASK[22];		*P_CORRECT VALUE, Q_VALUE READ	RTEMP_P;	P_P#Q, Q_MPMASK;	P AND Q, P_LTEMP, Q_RTEMP, GOTO[AZT];MPSMON:	FSET_Q;	CLEARF[FSET], GOTO[RGEN];	*CLEAR CUM TO MAKE MONITOR MODE%TEST MP USING RANDOM NUMBERS, SEQUENTIAL ADDRESSES.  IN THIS FIRST TEST, THEADDRESSES HAVE MORE THAN ONE CYCLE SETUP AND CHANGE AT THE END OF THE CYCLE,SO HARD STORAGE FAILURES, WRITE FAILURES PROVOKED BY ADDRESS GOING AWAY TOOSOON, AND ADDRESS LATCHING PROBLEMS ARE PROVOKED.%MPRT1:	Q_A1, CALL[MPSMON];		*START WITH MONITOR MAP	Y_NULL, CALL[RMARK];		*SAVE STATE OF RANDOM NO. GEN.	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y>=0];	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y<0];	Y_NULL, SETF[FSET], CALL[RETN];	*NOW USER MAP (DELAY AFTER SETF[CUM])	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y>=0];	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y<0];*NOW READ AND COMPAREMPRT1C:	Y_NULL, CLEARF[FSET], CALL[RREST];	P_MDR_MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y>=0];	P_MDR_MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y<0];	Y_NULL, SETF[FSET], CALL[RETN];	P_MDR_MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y>=0];	P_MDR_MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y<0];	RETURN;%TEST MP USING RANDOM NUMBERS, SEQUENTIAL ADDRESSES.  ADDRESSES CHANGE IN THECYCLE BEFORE READS OR THE CYCLE AFTER WRITES, SO HARD STORAGE FAILURES,ADDRESS LATCHING PROBLEMS, AND SLOW CHIP FAILURES ARE PROVOKED.%MPRT2:	Q_A1, CALL[MPSMON];		*START WITH MONITOR MAP	Y_NULL, CALL[RMARK];		*SAVE STATE OF RANDOM NO. GEN.	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y>=0];	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y<0];	SETF[FSET], CALL[RETN];		*NOW USER MAP (DELAY AFTER SETF[CUM])	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y>=0];	MAP_Q, INCY, CALL[RGEN];	GOTO[.-1,Y<0];*NOW READ AND COMPAREMPRT2C:	Y_NULL, CLEARF[FSET], CALL[RREST];	P_MDR_MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y>=0];	P_MDR_MAP, CALL[MPCOMP,Y<0];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y<0];	Y_NULL, SETF[FSET], GOTO[.+3];	P_MDR_MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y>=0];	P_MDR_MAP, CALL[MPCOMP,Y<0];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y<0];	RETURN;%TEST MP USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%MPRT3:	Q_A1, CALL[MPSMON];	FSET_Q;				*RANDOM CUMMPRT3L:	SETF[FSET], CALL[RGEN];	RDATA_Q, CALL[RGEN];		*RDATA/ RANDOM DATA	ADDR_FSPLIT_Q;			*ADDR[0,8]/ PREVIOUS ADDRESS	Y_ADDR, Q_RDATA;		*ADDR[27,35]/ ADDRESS WRITTEN-READ	MAP_Q;	FSPLIT_ADDR;	Y_ADDR;	Q_RDATA, P_MDR_MAP, GOTO[MPCOMP]; *COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF MPRT3LMPRT3S:	FSPLIT_ADDR, Q_RDATA;	Y_ADDR, Q_RDATA;	MAP_Q;	FSPLIT_ADDR;	Y_ADDR, DGOTO[MPRT3S];	Q_RDATA, P_MDR_MAP, CALL[MPCOMP];SMCOMP:	RTEMP_P;	LTEMP_Q;	P_P#Q, Q_SMMASK;	P AND Q, P_RTEMP, Q_LTEMP, GOTO[AZT];%TEST SM/DM USING RANDOM DATA, SEQUENTIAL ADDRESSES.  THE ADDRESS CHANGES INTHE CYCLE BEFORE EACH READ OR AFTER EACH WRITE TO CATCH SLOW TIMING PATHS.**A SLOWER DEVELOPMENT OF THE ADDRESS WOULD BE TO LOAD Y FROM A SLOW SOURCE**IN THE CYCLE BEFORE THE READ.%SMDMT1:	CALL[RGEN];	Y_NULL, CALL[RMARK];SMDML1:	D_Q, INCY, Q_NOT Q;*~ MAXC2 ONLY	D1_Q, INCY, Q_NOT Q;	D2_Q, DECY, Q_NOT Q;*~	SY_Q, DECY, CALL[RGEN];	INCY;	GOTO[SMDML1,Y>=0];SMDML2:	D_Q, Q_NOT Q, INCY;*~ MAXC2 ONLY	D1_Q, Q_NOT Q, INCY;	D2_Q, Q_NOT Q, DECY;*~	SY_Q, DECY, CALL[RGEN];	INCY;	GOTO[SMDML2,Y<0];	Y_A1, CALL[RREST];	*RESTORE ORIG. RANDOM NO. STATESMDMC1:	INCY;	P_MDR_D, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM[Y]	Q_NOT Q, INCY;*~ MAXC2 ONLY	P_MDR_D1, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM1[Y]	Q_NOT Q, INCY;	P_MDR_D2, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM2[Y]	Q_NOT Q, DECY;*~	P_MDR_SY, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ SM[Y]	CALL[RGEN];	DECY, GOTO[SMDMC1,Y>=0];SMDMC2:	INCY;	P_MDR_D, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM[Y]	Q_NOT Q, INCY;*~ MAXC2 ONLY	P_MDR_D1, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM1[Y]	Q_NOT Q, INCY;	P_MDR_D2, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM2[Y]	Q_NOT Q, DECY;*~	P_MDR_SY, CALL[SMCOMP];	CALL[RGEN];	DECY, GOTO[SMDMC2,Y<0];	RETURN;%TEST SM USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%SMT2:	CALL[RGEN];	RDATA_Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA_FSPLIT_P_Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y_P, Q_RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	SY_Q, P_LDATA, INCY;	FSPLIT_P;	Y_P;	Q_RDATA, P_MDR_SY, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF SMT2SMTS:	P_LDATA;	FSPLIT_P;	Y_P, Q_RDATA;	SY_Q;	P_LDATA;	FSPLIT_P;	Y_P, DGOTO[SMTS];	Q_RDATA, P_MDR_SY, CALL[SMCOMP];*~ MAXC2 ONLY%TEST SM, DM, DM1, DM2 TRYING TO PROVOKE FAILURES CAUSED BY FREQUENT SWITCHINGOF THE CHIP SELECTS.%SDM1B:	CALL[RGEN];	RDATA_Q, CALL[RGEN];	LDATA_Q, CALL[RGEN];	RDATA1_Q, CALL[RGEN];	LDATA1_Y_Q;	FSPLIT_Q;		*Y CHANGING BEFORE WRITE	SY_Y_Q, Q_RDATA1;	*AND AFTER WRITE OF SM	D1_Q, Q_LDATA, NEGY;	*CHIP SELECT CHANGES HERE	D_Q, Q_RDATA, NEGY;	*AND HERE	D2_Q, Q_LDATA1, NEGY;	*AND HERE	FSPLIT_Q;	P_Y_SY, CALL[SMCOMP];			*P/ SM[LDATA1[0,8]], Q/ SHOULD BE	Q_RDATA1, P_D1, NEGY, CALL[SMCOMP];	*P/ DM1[-Y], Q/ SHOULD BE	Q_LDATA, P_D, NEGY, CALL[SMCOMP];	*P/ DM[-Y], Q/ SHOULD BE	Q_RDATA, P_D2, NEGY, CALL[SMCOMP];	*P/ DM2[-Y], Q/ SHOULD BE	RETURN;*~%TEST DM USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%DMT2:	CALL[RGEN];	RDATA_Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA_FSPLIT_P_Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y_P, Q_RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	D_Q, P_LDATA, INCY;	FSPLIT_P;	Y_P;	Q_RDATA, P_MDR_D, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF DMT2DMTS:	P_LDATA;	FSPLIT_P;	Y_P, Q_RDATA;	D_Q;	P_LDATA;	FSPLIT_P;	Y_P, DGOTO[DMTS];	Q_RDATA, P_MDR_D, CALL[SMCOMP];%TEST DM1 USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%*~ MAXC2 ONLYDM1T2:	CALL[RGEN];	RDATA_Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA_FSPLIT_P_Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y_P, Q_RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	D1_Q, P_LDATA, INCY;	FSPLIT_P;	Y_P;	Q_RDATA, P_MDR_D1, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF DM1T2DM1TS:	P_LDATA;	FSPLIT_P;	Y_P, Q_RDATA;	D1_Q;	P_LDATA;	FSPLIT_P;	Y_P, DGOTO[DM1TS];	Q_RDATA, P_MDR_D1, CALL[SMCOMP];%TEST DM2 USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%DM2T2:	CALL[RGEN];	RDATA_Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA_FSPLIT_P_Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y_P, Q_RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	D2_Q, P_LDATA, INCY;	FSPLIT_P;	Y_P;	Q_RDATA, P_MDR_D2, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF DM2T2DM2TS:	P_LDATA;	FSPLIT_P;	Y_P, Q_RDATA;	D2_Q;	P_LDATA;	FSPLIT_P;	Y_P, DGOTO[DM2TS];	Q_RDATA, P_MDR_D2, CALL[SMCOMP];*~*WRITE IM[ADDR] WITH RDATA AND LDATA.  ADDR#WLOOK THRU ALU AT CALL.*! MAXC1 ONLYWIM:	GOTO[.+2,ALU#0];	SIGNOVA;	P_NPC_ADDR, Q_RDATA;	I_Q,DGOTO[.+1];  *2 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];	P_NPC_ADDR, GOTO[.+1], Q_LDATA;	I_Q, DGOTO[.+1], Q_AINC, INHINT;  *5 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];	P_HADDR, Q_P+Q, RETURN;*!*~ MAXC2 ONLYWIM:	Q_RDATA, GOTO[.+2,ALU=0];	B_Q, GOTO[.+2];	B_Q, SIGNOVA;	NPC_ADDR, FRZBALUBC;	*FREEZE EREG	P_I_EREG, DGOTO[.+1]; *2 CYCLES AFTER SIGNOVA IM[36,71]	P#Q, Q_LDATA;	B_Q, GOTO[.+2,ALU=0];	BRKP[1];		*EREG WRONG AFTER IM WRITE	NPC_ADDR, FRZBALUBC;	P_I_EREG, INHINT, DGOTO[.+1];	P#Q, P_ADDR, Q_AINC;	*6 CYCLES AFTER SIGNOVA IM[0,35]	P_HADDR, Q_P+Q, RETURN[ALU=0];	BRKP[1];		*EREG WRONG AFTER IM WRITE*~*READ IM[ADDR], MASK IT WITH LMASK AND RMASK, AND COMPARE TO LDATA AND RDATA.*ADDR#RLOOK THRU ALU AT CALL.RIM:	GOTO[.+2,ALU#0];	SIGNOVA;	NPC_ADDR;*! MAXC1 ONLY	P_I, DGOTO[.+1], Q_RMASK;  *2 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];*!*~ MAXC2 ONLY	I, Q_RMASK, DGOTO[.+1];	MDR_P_EREG, GOTO[.+1];*~	LTEMP_P AND Q, GOTO[.+1], P_RDATA;	P_P AND Q, Q_LTEMP, CALL[PQCOMP];*RIGHT HALF OF IM ENTRY [ADDR] MASKED BY [RMASK] SHOULD HAVE BEEN P *BUT WAS Q	NPC_ADDR;*! MAXC1 ONLY	P_I, INHINT, DGOTO[.+1], Q_LMASK;  *9 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];*!*~ MAXC2 ONLY	I, INHINT, Q_LMASK, DGOTO[.+1];	MDR_P_EREG, GOTO[.+1];*~	RTEMP_P AND Q, GOTO[.+1], P_LDATA;	P_P AND Q, Q_RTEMP, CALL[PQCOMP];*LEFT HALF OF IM ENTRY [ADDR] MASKED BY [LMASK] SHOULD HAVE BEEN P*BUT WAS Q	P_ADDR, Q_AINC;	Q_P+Q, P_HADDR, RETURN;*LOOP TO REPEAT "WIM" AFTER PARITY ERRORS*~ MAXC2 ONLYWIMREP:	Q_RDATA;	B_Q, SIGNOVA;	NPC_ADDR, FRZBALUBC;	*FREEZE EREG	P_I_EREG, DGOTO[.+1];	P#Q, Q_LDATA;	B_Q, GOTO[.+2,ALU=0];	BRKP[1];		*EREG WRONG	NPC_ADDR, FRZBALUBC;	P_I_EREG, INHINT, DGOTO[.+1];	P#Q, P_ARM, Q_17700 000000L;	P AND Q, GOTO[.+2,ALU=0];	BRKP[1];		*EREG WRONG	Q_PARITY, GOTO[WIMREP,ALU=0];	BRKP[1], ARM_Q, GOTO[WIMREP];*~DCYCLE:	PQ LCY [1],FRZBALUBC, Q_LDATA;	LDATA_P, P_RDATA, FRZBALUBC;	PQ LCY [1], FRZBALUBC, RETURN, Q_ADDR;*STARTING WITH THE 72 BIT NUMBER <LBASE,RBASE>, WRITE FROM ADDRESS*LADDR TO HADDR SEQUENTIALLY LEFT CYCLED PATTERNSRWT1:	P_LBASE,Q_RBASE;	RDATA_Q, Q_LADDR;	LDATA_P, P_WLOOK;RWT2:	P#Q, ADDR_Q, CALL[WIM];	P-Q, ADDR_Q, P_LDATA, Q_RDATA, CALL[DCYCLE];	RDATA_P, FRZBALUBC;	P_WLOOK, GOTO[RWT2,ALU>=0];*NOW READ AND COMPARE	P_LBASE, Q_RBASE;	RDATA_Q, Q_LADDR;	LDATA_P, P_RLOOK;RWT3:	P#Q, ADDR_Q, CALL[RIM];	P-Q, ADDR_Q, P_LDATA, Q_RDATA, CALL[DCYCLE];	RDATA_P, FRZBALUBC, DGOTO[RWT3];	RETURN[ALU<0], P_RLOOK;*TEST IM USING 72 PATTERNS OF SINGLE 0 IN FIELD OF 1'S AND 72 PATTERNS*OF SINGLE 1 IN FIELD OF 0'SIMCYCT:	LBASE_P_A0;	RBASE_P+1,CALL[RWT1];IMRWT1:	P_LBASE, Q_RBASE;	PQ LCY [1],Q_LBASE;	LBASE_P,P_RBASE;	PQ LCY [1];	RBASE_P;	DGOTO[IMRWT1,ALU>=0];	CALL[RWT1];*RETURN HERE WHEN 72 PATTERNS OF A SINGLE 1 IN A FIELD OF 0'S ARE EXHAUSTED	LBASE_P_A1;	RBASE_2P,CALL[RWT1];IMRWT2:	P_LBASE,Q_RBASE;	PQ LCY [1],Q_LBASE;	LBASE_P,P_RBASE;	PQ LCY [1];	RBASE_P;	DGOTO[IMRWT2,ALU<0];	CALL[RWT1];	RETURN;*NOW TEST IM USING RANDOM NO.'SIMRANT:	Q_LADDR, DGOTO[WRANIM];	ADDR_Q, CALL[RMARK];WRANE:	ADDR_Q, CALL[NIRGEN];WRANIM:	RDATA_Q, CALL[RGEN];	LDATA_Q, Q_ADDR, P_HADDR, DGOTO[WRANE];	P-Q, P_WLOOK, CALL[.+1];	P#Q, GOTO[WIM,ALU>=0];*NOW READ AND COMPARE	Q_LADDR, POP, DGOTO[RRANIM];	ADDR_Q, CALL[RREST];RRANE:	ADDR_Q, CALL[NIRGEN];RRANIM:	RDATA_Q, CALL[RGEN];	LDATA_Q, Q_ADDR, P_HADDR, DGOTO[RRANE];	P-Q, P_RLOOK, CALL[.+1];	P#Q, GOTO[RIM,ALU>=0];	POP;	RETURN;