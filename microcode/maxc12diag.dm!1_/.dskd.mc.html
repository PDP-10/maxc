<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12diag.dm!1>dskd.mc</title>
  </head>
  <body>
    <pre>
ER[DSKD];%	A DISK DIAGNOSTIC ROUTINE	last modified January 10, 1977  1:39 PMTO ASSEMBLE:	@MI@ DSKDLOAD:		DSKD%INSERT[DBEG];***	OUTGOING COMMAND BITS FROM MAXC TO DISK AND CONTROLLER*	TARGET[ILC];	MP[UDSEL,13];	* DESELECT THE UNIT	MP[RSC,7];	* RESET SECTOR CONDITION	MP[RPDL,10];	* RESET PROCESSOR DATA LATE	MP[RCDL,11];	* RESET CONTROLLER DATA LATE	MP[RSO,12];	* RESET SECTOR OVERFLOW	MP[I1EN,0];	* ENABLE SECTOR INTERRUPTS	MP[I2EN,4];	* ENABLE TYPE 1 WORD INTERRUPTS	MP[I3EN,5];	* ENABLE TYPE 2 WORD INTERRUPTS	MP[I4EN,6];	* ENABLE TYPE 3 WORD INTERRUPTS	MP[LCR,1];	* LOAD CYLINDER ADDRESS REGISTER	MP[LHR,2];	* LOAD HEAD ADDRESS REGISTER	MP[COM,3];	* INTERPRET THIS AS A COMMAND	MP[WRGAT,20];	* TURN ON WRITING	MP[RDGAT,21];	* TURN ON READING	MP[ERGAT,24];	* TURN ON ERASING	MP[SEEK,22];	* INITIATE SEEK TO C.A.R.	MP[RHR,23];	* RESET HEAD ADDRESS REGISTER TO 0	MP[HDS,25];	* ACTIVATE R/W HEAD IN H.A.R.	MP[RESTOR,26];	* SEEK TO CYLINDER 0	SP[RESET,RSC,RPDL,RCDL,RSO];  * RESETS CONTROLLER ERRORS	PM[ALL1CYL,777 0000];	F[HDADR,23,27];	* HEAD ADDRESS FIELD	F[CYLADR,17,27];* CYLINDER ADDRESS FIELD**	INCOMING STATUS FROM DISK AND CONTROLLER*	MP[IC,0];	* INDEX CONDITION	MP[UUNS,1];	* UNIT UNSAFE	MP[UOFF,2];	* UNIT OFF LINE	MP[UNR,3];	* UNIT NOT READY (NORMALLY = SEEKING)	MP[SKFAIL,4];	* SEEK HAS FAILED	MP[URDONLY,5];	* UNIT CANNOT BE WRITTEN ON	MP[CNR,6];	* CONTROLLER IS NOT READY	MP[SC,7];	* SECTOR CONDITION	MP[PDL,10];	* PROCESSOR DATA LATE CONDITION	MP[CDL,11];	* CONTROLLER DATA LATE CONDITION	MP[SO,12];	* SECTOR OVERFLOW CONDITION*	REPEATEDLY SELECT A NON-EXISTENT DISK UNIT AND CONTROLLER*	PM[UFOUR,4];	MC[UNIT4,UFOUR];	* MAKE A CONSTANT FOR UNIT 4RSELU4:	KUNIT&larr;UNIT4, GOTO[.];*	REPEATEDLY READ OUT THE KUNIT REGISTER*RKUNIT:	P&larr;KUNIT, GOTO[.];*	REPEATEDLY SELECT A NON-EXISTENT DISK UNIT AND CONTROLLER AND*	THEN READ THE KUNIT REGISTERSELLOOP:	KUNIT&larr;UNIT4;	P&larr;NULL;	P&larr;KUNIT, GOTO[SELLOOP];*	REPEATEDLY READ OUT THE KSTAT REGISTER*RKSTAT:	P&larr;KSTAT, GOTO[.];**	SELECT A NON-EXISTENT DISK UNIT AND CONTROLLER*SELU4:	KUNIT&larr;UNIT4;	P&larr;NULL;	P&larr;KUNIT;	P&larr;KSTAT;**	SELECT A REAL DISK UNIT AND CONTROLLER*	PM[UZERO,0];	MC[UNIT,UZERO];	* MAKE A CONSTANT FOR UNIT 0	PM[IDLP,0];	MC[IDLE,IDLP];	MC[DISCONN,UDSEL,RESET];	MC[TIMES];	SV[RANGEN,0];SELUNIT: Q&larr;7S;	* Reset and turn off interrupts on all controllersSU1:	KUNIT&larr;Q;	P&larr;AQ;	KSET&larr;DISCONN,KNEWCOMM;	P&larr;P-1;	Q&larr;P,GOTO[SU1,ALU&gt;=0];	KUNIT&larr;UNIT;	P&larr;TIMES;	Q&larr;P+1;	TIMES&larr;Q;	KSET&larr;IDLE,KNEWCOMM;	P&larr;KUNIT;	P&larr;KSTAT;	P&larr;RANGEN;	2P;	CALL[STORLM,ALU=0];	RETURN;**	ROUTINE TO SEND A SET CYLINDER REGISTER COMMAND FOLLOWED BY*	A SEEK COMMAND REPEATEDLY TO A TURNED-OFF DISK UNIT.*	MC[CYLVAL,LCR,RESET,ALL1CYL];	MC[PAUSMSK,CNR];	MC[SKVAL,COM,RESET,SEEK];CRLP:	KUNIT&larr;UNIT;	P&larr;NULL;	KSET&larr;CYLVAL,KNEWCOMM;	Q&larr;PAUSMSK;	P&larr;KSTAT;	P AND Q;	GOTO[.-2,ALU#0];	KSET&larr;SKVAL,KNEWCOMM;	Q&larr;PAUSMSK;	P&larr;KSTAT;	P AND Q;	GOTO[.-2,ALU#0];	GOTO[CRLP];**	ROUTINES TO REPEATEDLY STORE AND READ THE KATA REGISTERS*	PM[TDP,0];	MC[DATWD,TDP];	MC[DATEXT,TDP];KWDATL:	CALL[SELUNIT];	KMDR&larr;DATWD;	KMDRL&larr;DATEXT;	P&larr;KMDR;	Q&larr;KMDRL;	KWDATA,GOTO[.];KRDATL:	CALL[SELUNIT];	P&larr;KRDATA;	Q&larr;KMDRL,GOTO[.-1];**	WAIT UNTIL DISK UNIT AND CONTROLLER BOTH READY*	MC[ALLRDY,UOFF,SKFAIL,UNR,CNR];WAITRDY:Q&larr;ALLRDY;	P&larr;KSTAT;	P&larr;P AND Q;		*LOOP UNTIL READY	GOTO[.-2, ALU#0];	RETURN;**	INTERRUPT HANDLERS FOR SECTOR AND WORD INTERRUPTS*	IM[SILOC,5];	SILOC[(CALL[SIHAND])];	IM[WILOC,11];	WILOC[(CALL[WIHAND])];	MC[SECRDY];	MC[WDRDY];	MC[RSCC,RSC,I1EN];	MC[KDO];	MC[KDOL];	MC[KDI];	MC[KDIL];	MC[IUNIT];	MC[STAAFT];SIHAND:	P&larr;AQ, Q&larr;1S;	SECRDY&larr;Q, P&larr;P;	KCSET&larr;RSCC, P&larr;P;	P&larr;P;	P&larr;P;	Q&larr;KUNIT, P&larr;P;	IUNIT&larr;Q, P&larr;P;	Q&larr;KSTAT, P&larr;P;	STAAFT&larr;Q, P&larr;P;	Q&larr;P, P&larr;P;	RETURN,P&larr;P1,IRET;WIHAND:	P&larr;AQ, Q&larr;1S;	WDRDY&larr;Q, P&larr;P;	KMDR&larr;KDO, P&larr;P;	KMDRL&larr;KDOL, P&larr;P;	KWDATA, P&larr;P;	Q&larr;KRDATA, P&larr;P;	KDI&larr;Q, P&larr;P;	KDIL&larr;KMDRL, Q&larr;P, P&larr;P;	RETURN,P&larr;P1,IRET;**	WAIT UNTIL THE BEGINNING OF NEXT INDEX SECTOR*	NMC[NISC,IC,SC];WAITIDX:SECRDY&larr;NULL;WIX1:	P&larr;SECRDY;	P;	GOTO[WIX1,ALU=0];	P&larr;KSTAT;	P&larr;(P) U (NISC);	P&larr;P+1; GOTO[WAITIDX,ALU#0];	RETURN;**	WAIT UNTIL READY FOR NEXT WORD. INTERRUPT 4 REQUEST MUST NOT*	BE BACK-PANEL JUMPERED.*	SP[BADUNIT,UUNS,UOFF,UNR,SKFAIL,URDONLY];	MC[OOPSMSK,BADUNIT,PDL,CDL,SO];WAITWD:	Q&larr;OOPSMSK;	P&larr;NULL;	P&larr;KSTAT;	P AND Q; GOTO[ANALYZE,ALU#0];	P&larr;WDRDY;	P;	P&larr;NULL, GOTO[WAITWD,ALU=0];	WDRDY&larr;NULL,P, RETURN; * RETURN WITH ALU=0 MEANS ALL WENT OK**	ANALYZE WHY WAITWD FAILED*	SV[CONDMSK,7777 7777 7777];ANALYZE:Q&larr;P AND Q, P&larr;CONDMSK;	P AND Q;	GOTO[.+2,ALU=0];STOP1:	BRKP[1], GOTO[.];	AQ, RETURN;  * SET THE ALU OUTPUT NONZERO, REQUESTING RECOVERY**	SEEK TO CYLINDER SPECIFIED IN CURCYL[17-27].*	MC[CURCYL,UZERO];	MC[CYLCOM,UZERO];	MC[SCRCOM,LCR,RESET];	MC[SEECOM,COM,RESET,SEEK];SEEKSUB:CALL[WAITRDY];	Q&larr;CURCYL;	P&larr;SCRCOM;	Q&larr; P OR Q;	CYLCOM&larr;Q;	KSET&larr;CYLCOM,KNEWCOMM;	CALL[WAITRDY];	KSET&larr;SEECOM,KNEWCOMM;	CALL[WAITRDY];	RETURN;**	GET A DATA WORD AND PUT IT IN DWD. IF SWITCH=0, GENERATE A RANDOM*	DATA WORD. IF SWITCH#0, USE PWORD AS THE DATA WORD. THE ROUTINE*	ASSUMES THAT X, L0-L7, AND DWD HAVE BEEN PRESERVED FROM THE*	LAST CALL.*	MC[SWITCH,UZERO];	MC[PWORD,UZERO];	MC[WDSLFT];	MC[DWD];	LV[LDWDL];	SV[X0,7654321];	SV[X1,76543210];	SV[X2,765432100];	SV[X3,7654321000];	SV[X4,76543210000];	SV[X5,765432100000];	SV[X6,654321000007];	SV[X7,543210000076];	SV[ZAP,0];	SV[@X7,IP[X7]];	SV[NXTIX,0];GETDWD:	P&larr;SWITCH;	2P;	Q&larr;PWORD,GOTO[STDWD,ALU#0];	Q&larr;DWD,GOTO[.+2,X&gt;=0];	X&larr;7S;	P&larr;LX;	LX&larr;Q&larr;P+Q,DECX;STDWD:	DWD&larr;Q,RETURN;**	PICK UP RANDOM NUMBER PARAMETERS FROM SCRATCHPAD.*LOADLM:	X&larr;7S;	Y&larr;@X7;	Q&larr;ZAP;	DWD&larr;Q;LOADLMP:P&larr;SY,DECY,GOTO[GETX,X&lt;0];	LX&larr;P,DECX,GOTO[LOADLMP];GETX:	X&larr;NXTIX,RETURN;**	STORE UPDATED RANDOM NUMBER PARAMETERS IN SCRATCHPAD.*STORLM:	NXTIX&larr;X;	X&larr;7S;	Y&larr;@X7;	Q&larr;DWD;	ZAP&larr;Q;STORLMP:Q&larr;LX,DECX,RETURN[X&lt;0];	SY&larr;Q,DECY,GOTO[STORLMP];**	SEEK FORWARD ONE CYLINDER*	SLC[LOCYL: CYLADR[0]];	SLC[HICYL: CYLADR[626]];	SLC[ONECYL: CYLADR[1]];SEEKFWD:P&larr;CURCYL;	Q&larr;ONECYL;	P&larr;P+Q;	Q&larr;LOCYL;	P-Q; GOTO[.+2,ALU&gt;0];	P&larr;Q;	Q&larr;HICYL;	P-Q; GOTO[.+2,ALU&lt;0];	P&larr;LOCYL;	Q&larr;P;	CURCYL&larr;Q;	CALL[SEEKSUB];	RETURN;**	WRITE A MULTIPLE WORD RECORD ON THE INDEX SECTOR OF HEAD 0*	OF CYLINDER CURCYL.*	PM[DZEROP,0];	MC[DZERO,DZEROP];	PM[DSYNCP,17];	MC[DSYNC,DSYNCP];	PM[WDMAXP,1100];	MC[WDMAXW,WDMAXP];	MC[RESETHD,RESET,COM,RHR,I1EN];	MC[SETHD,LHR,I1EN];	MC[SHCOM];	MC[HDSEL,RESET,COM,HDS,I4EN,I1EN];	MC[WRITEC,COM,WRGAT,ERGAT,HDS,I4EN,I1EN];	MC[ERASE,COM,ERGAT,HDS,I4EN,I1EN];	MC[STATUSW];SETCHD:	CALL[SEEKSUB];	KSET&larr;RESETHD,KNEWCOMM,CALL[WAITRDY];	P&larr;CURCYL;	Q&larr;37 0000S;  * MASK CYLINDER TO GET HEAD NUMBER	P&larr;P AND Q;	Q&larr;23 0000S;  * MAKE SURE HEAD IS IN [0-23]	Q&larr;P-Q;	GOTO[.+2,ALU&lt;0];	P&larr;AQ;	Q&larr;SETHD;	Q&larr;P OR Q;	SHCOM&larr;Q;	KSET&larr;SHCOM,KNEWCOMM,CALL[WAITRDY];	KMDR&larr;DZERO; KMDRL&larr;DZERO; KWDATA;	Q&larr;DZERO;	KDO&larr;Q;	KDOL&larr;Q;	WDRDY&larr;NULL;	RETURN;WRITE:	CALL[SETCHD];WRITER:	CALL[WAITIDX];	CALL[LOADLM];	Q&larr;0S;	WDSLFT&larr;Q;	Q&larr;KSTAT;	STATUSW&larr;Q;	KSET&larr;HDSEL,KNEWCOMM,CALL[WAITWD];	KSET&larr;WRITEC,CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	Q&larr;DSYNC;	KDO&larr;Q;	KDOL&larr;Q;	CALL[WAITWD];WDLP:	P&larr;WDSLFT;	Q&larr;P+1;	WDSLFT&larr;Q;	P&larr;WDMAXW;	P-Q;	GOTO[WEXIT,ALU&lt;0];	CALL[GETDWD];	Q&larr;DWD;	KDO&larr;Q, Q&larr;LDWDL;	KDOL&larr;Q;	CALL[WAITWD];	GOTO[WDLP];WEXIT:	Q&larr;DZERO;	KDO&larr;Q;	KDOL&larr;Q;	CALL[WAITWD];	CALL[WAITWD];	KSET&larr;ERASE;	CALL[WAITWD];	KSET&larr;IDLE;	KMDR&larr;DZERO; KMDRL&larr;DZERO; KWDATA;	RETURN;**	READ A MULTIPLE WORD RECORD FROM THE INDEX SECTOR OF HEAD 0*	ON CYLINDER CURCYL AND CHECK IT WORD FOR WORD. IF LOOKAT&gt;0, DISPLAY*	WORD[LOOKAT] IN P AND Q REGISTERS.*	MC[WDMAXR,WDMAXP];	MC[READC,COM,RDGAT,HDS,I4EN,I1EN];	MC[STATUSR];	MC[LOOKAT,DZEROP];	PM[IERMSK,777777777777];	MC[ERRMSK,IERMSK];	PM[IERMSKL,17];	MC[ERRMSKL,IERMSKL];READ:	CALL[SETCHD];READR:	CALL[WAITIDX];	CALL[LOADLM];	Q&larr;0S;	WDSLFT&larr;Q;	Q&larr;KSTAT;	STATUSR&larr;Q;	KSET&larr;HDSEL,KNEWCOMM,CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	KSET&larr;READC,CALL[WAITWD];	CALL[WAITWD];	* SKIP FIRST GARBAGE WORDRDLP:	P&larr;WDSLFT;	Q&larr;P+1;	WDSLFT&larr;Q;	P&larr;WDMAXR;	P-Q;	GOTO[REXIT,ALU&lt;0];	CALL[GETDWD];	P&larr;LOOKAT;	2P;	GOTO[CHECK,ALU&lt;=0];	Q&larr;WDSLFT;	P-Q,P&larr;KDI;	GOTO[OKAY,ALU#0];	Q&larr;KDIL; GOTO[OKAY];CHECK:	Q&larr;DWD;	P&larr;KRDATA;	Q&larr;P#Q, P&larr;ERRMSK;	P AND Q;	GOTO[HANG,ALU#0];	Q&larr;DWD;	P&larr;KMDRL;	Q&larr;P#Q, P&larr;ERRMSKL;	P AND Q; GOTO[OKAY,ALU=0];HANG:	P&larr;KMDRL;BRKP[1];OKAY:	CALL[WAITWD];	GOTO[RDLP,ALU=0]; * CHECK THAT WAITWD WENT OKREXIT:	KSET&larr;IDLE,KNEWCOMM;	P&larr;KRDATA;	RETURN;**	CALLS ON THE VARIOUS ROUTINES*	MC[IENABLE,IENABLE];CLRTIMES:ARM&larr;2100S,INHINT, Q&larr;A0;	SETF[IENABLE],INHINT;	IRET, INHINT, TIMES&larr;Q, GOTO[LOADLM];*ST:	CALL[CLRTIMES],INHINT;SEEKTST:CALL[SELUNIT];	CALL[SEEKFWD];	GOTO[SEEKTST];*WT:	CALL[CLRTIMES],INHINT;WCONT:	CALL[SELUNIT];	CALL[WRITE];	GOTO[WCONT];*RT:	CALL[CLRTIMES],INHINT;RCONT:	CALL[SELUNIT];	CALL[READ];	GOTO[RCONT];*WRT:	CALL[CLRTIMES],INHINT;WRCONT:	CALL[SELUNIT];	CALL[WRITE];	CALL[READ];	GOTO[WRCONT];*SWRT:	CALL[CLRTIMES],INHINT;SWRCONT:CALL[SELUNIT];	CALL[SEEKFWD];	CALL[WRITE];	CALL[READ];	GOTO[SWRCONT];</pre>
  </body>
</html>
