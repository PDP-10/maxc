ER[DGM];		*TEST OF PROCESSOR AND DISK MEMORY INTERFACESTARGET[ILC];%TO ASSEMBLE:	MICRO/L LANG DGM -OR- MICRO/L LANG2 DGMTO RUN:		MIDAS RDGM		START;G		FOR ORDINARY MEMORY TESTING		START1;G	FOR INTERRUPT SYSTEM TESTING		XSTART;G	FOR INTERRUPT SYSTEM TESTINGCOMPARISON ERRORS ARE MASKED BY "DMASK" AND "DMASKL" (PROCESSOR INTERFACE MASKS)AND "KDMASK" AND "KDMASKL" (DISK INTERFACE).TEST THE MAIN MEMORY INTERFACE FOR THE PROCESSOR AND FOR THE DISK CONTROL.BEGIN BY CHECKING OUT THE LOADING AND READING OF MAR, MDR, MDRL, KMAR,KMDR, AND KMDRL FROM/TO THE BUS.  ORIGINALLY LOAD MAR VIA THE MAPVA_DESTINATION WHICH IS ALSO CHECKED OUT.	THEN CHECK THAT ALL OF THE MEMORYREFERENCE FUNCTIONS AND DESTINATIONS LOAD MAR CORRECTLY BUT POSTPONECHECKING OUT MEMORY DATA UNTIL LATER.***NOTE:  NOT ALL BITS OF KMAR CAN BE CHECKED OUT BECAUSE THERE IS NO WAY***TO LOAD THAT REGISTER WITHOUT MAKING A MEMORY REFERENCE.***MEMORY ERRORS HANG THE PROCESSOR UNDER CONTROL OF A HARDWARE SWITCH***DO NOT ASSEMBLE THIS PROGRAM WITH DG1 (SM, RM, AND LM TESTS).***DG0, DG1, AND DGP SHOULD WORK BEFORE THIS IS TRIED.	FIRST VERIFY THAT DGM***WORKS WITH THE DATA COMPARE MASKS SET T0 0.	THEN TRY IT WITH FULL***DATA COMPARE.TO CHECKOUT ONLY DISK MEMORY INTERFACE, PUT BREAKPOINT AT "MCTEST", STARTAT "TKWRT".TO CHECKOUT ONLY PROCESSOR MEMORY INTERFACE, PUT BREAKPOINT AT "TKWRT",START AT "START" (TESTS READ_, WRITE_, AND RMW_)TO TEST XREF, RREF, RMWREF, WREF, ETC., START AT "TREFS" (BREAKS AT ENDOF DIAGNOSTIC).	THIS DOESN'T CHECK OUT VERY MANY ADDRESSES; TO CHECKMORE ADDRESSES, PATCH "TREF1+1" TO BE "CALL[AGEN], P_LADR""START1" COMBINES A CONSTANT INTERRUPT REQUEST AND TRIVIAL INTERRUPTROUTINE WITH PARTS OF THE MEMORY DIAGNOSTIC TO CHECK FOR INTERACTIONSAND FAILURES HAVING TO DO WITH THE ONSET/TERMINATION OF INTERRUPTS AND/ORWITH THE STOP LOGIC.  SINCE THE INTERRUPT ROUTINE RETURNS WITHOUT PREIRET,AT LEAST ONE NON-INTERRUPT INSTRUCTION IS EXECUTED BETWEEN EACH INTERRUPT.THE CHANNEL 17 INTERRUPT IS USED.  ALTERNATE ENTRY POINT "XSTART" ISFOR OCCASIONAL DISK SECTOR INTERRUPTS FROM UNIT A INSTEAD OF CONSTANTINTERRUPTS.  "DGI" SHOULD RUN BEFORE TRYING "START1" OR "XSTART".%*AGGRAVATE PROBLEMS CAUSED BY DENSITY OF 1'S IN IMDEFAULT[IM,(GOTO[3777,NEVER], Q_Q, PQ RCY [0], LA[37], RA[37], A0,	SA[377], B_NULL, NOF2, NOZ, T[0])];INSERT[DGIB.MC];IM[XILC,5];XILC[(CALL[SECIROU], X_YKPTR_KUNIT)];*FALL THRU HERE FROM "MCYCLE"	SETSF[IENABLE&G], DGOTO[TMDR];	GOTO[TMINIT,G=1];START1:	KUNIT_P_NULL, CLEARF[-1S];	ARM_P+1;	SETF[IENABLE&G], GOTO[TMINIT];XSTART:	X_7S;	KUNIT_X, CALL[RETN]; *ALLOW TWO CYCLES SETTLING TIME AFTER KSET_	DECX;	KSET_100 000000S, GOTO[.-2,X>=0]; *DESELECT ALL DISK UNITS	COUNT_ARM_NULL, INHINT;	KUNIT_NULL, INHINT;	IRET, P_MDR, INHINT;	P_NULL, CLEARF[-1S];	KSET_441600 200000S; *ENABLE SECTOR INTS. ON UNIT 0	ARM_2000S;	SETF[10S];	SETF[IENABLE&G], GOTO[TMINIT];SV[MLOW,0];		*LOWEST ADDRESS USED IN DATA OPERATIONSSV[MHIGH,777777];	*HIGHEST ADDRESS USED IN DATA OPERATIONSSV[MAMASK,777777 777777];	*MASK OF BITS FOR MEM. ADDR.****NOT IMPLEMENTEDSV[DMASK,777777 777777]; SV[DMASKL,17];	*MASK FOR MEMORY DATA COMPARESSV[KDMASK,777777 777777]; SV[KDMASKL,17]; *MASK FOR DISK MEMORY COMPARESSVN[SDATA]; SVN[SDATAL];		*HOLD DATA INVOLVED IN CURRENT REFERENCESVN[SBASE]; SVN[SBASEL];		*STARTING NUMBER FOR PASS THRU MAIN MEMORYSVN[SADR];			*CURRENT ADDRESSMC[XCTN,XCTN]; *MASK OF THE FOUR XCT BITS THAT FORCE USER MODE ON REF'SMC[XCT0,XCT0]; *XCT0 CONTROLS IREFMC[NXCT0,XCT1,XCT2,XCT3];MC[XCT1,XCT1]; *XCT1 CONTROLS RREFMC[NXCT1,XCT0,XCT2,XCT3];MC[XCT2,XCT2]; *CONTROLS BIREFMC[NXCT2,XCT0,XCT1,XCT3];MC[XCT3,XCT3]; *CONTROLS WREFMC[NXCT3,XCT0,XCT1,XCT2];MC[CFM&CUM&XCTN,CFM,CUM,XCTN];MC[CFM&CUM&XCT0,CFM,CUM,XCT0];MC[CFM&CUM&XCT1,CFM,CUM,XCT1];MC[CFM&CUM&XCT2,CFM,CUM,XCT2];MC[CFM&CUM&XCT3,CFM,CUM,XCT3];MC[UM&CUM&K&G,UM,CUM,K,G];NMC[NOTG,G];NMC[NOTUM,UM];NMC[NOTCUM,CUM];NMC[NOTGUMCUM,G,UM,CUM];MC[CUM&UM,CUM,UM];MC[CUM&H,CUM,H];MC[UM,UM];MC[UM&K,UM,K];MC[CUM&XCTN,CUM,XCTN];MC[NWP,RP,XP];MC[CUM&NXCT0,CUM,XCT1,XCT2,XCT3];MC[CUM&NXCT1,CUM,XCT0,XCT2,XCT3];MC[CUM&NXCT2,CUM,XCT0,XCT1,XCT3];MC[CUM&NXCT3,CUM,XCT0,XCT1,XCT2];*PARAMETERS FOR THE MAP MEMORY ENTRIESMP[RP,22]; *READ PERMIT BIT (0 ENABLES IREF, BIREF, RREF, AND PARTLY RMWREF)MP[WP,23]; *WRITE PERMIT (0 ENABLES WREF AND PARTLY RMWREF)MP[XP,24]; *EXECUTE PERMIT (0 ENABLES XREF)MC[RP,RP];MC[WP,WP];MC[XP,XP];MC[RP&WP,RP,WP];MC[RP&WP&XP,RP,WP,XP];RVN[RSAVE]; RVN[RNADR]; RVN[RTEMP]; RVN[RTEMP1]; RVN[RTEMP2]; RVN[RTEMP3];LVN[LTEMP]; LVN[LTEMP1]; LVN[LTEMP2]; LVN[LSAVE]; LVN[LADR]; LVN[LINT];SECIROU: LINT_Q, P_Y, Q_400R, CALL[PQCOMP]; *Y NOT LOADED CORRECTLY BY INTERRUPT INSTRUCTION	KREAD_SADR;*443600 200000S WOULD BE USED BELOW TO RESET THE SECTOR INTERRUPT REQUEST*BUT HAVING THE INTERRUPT REPEAT OVER AND OVER IS MORE USEFUL	KSET_441600 200000S; *DON'T INVOKE STOP LOGIC ON NEXT INSTRUCTION	P_P1, IRET, RETURN, Q_LINT;INTROU:	P_Y, LINT_Q;	Q_400S, CALL[PQCOMP]; *Y NOT LOADED CORRECTLY BY INTERRUPT INSTRUCTION	IRET, P_P1, RETURN, Q_LINT;*RTEMP HOLDS P ARGUMENT AND RTEMP1 HOLDS Q ARGUMENT FOR RCY [44-Y]TMINIT:	RTEMP_A0;	RTEMP1_A1, CALL[PQRCY44-YT];	RTEMP_A0;	RTEMP1_A0, CALL[PQRCY44-YT];	RTEMP_A1;	RTEMP1_A0, CALL[PQRCY44-YT];	RTEMP_A1;	RTEMP1_A1, CALL[PQRCY44-YT];	GOTO[YLOADT];PQRCY44-YT: P_777S, A0;PQ44-YL0: Y_P, Q_RTEMP1, CLEARF[H], GOTO[PQ44-YL,ALU<0];	LTEMP_P-1, P_RTEMP;	PQ RCY [44-Y];	P_LTEMP, Q_77R, CALL[CBRK,H=0];	P-Q-1, GOTO[PQ44-YL0];PQ44-YL: Y_P, Q_RTEMP1, CLEARF[H], GOTO[PQ44-YT1,ALU<0];	LTEMP_P-1, P_RTEMP;	PQ RCY [44-Y], CALL[H=1T];	P_LTEMP, Q_44R;	P-Q-1, P_LTEMP, GOTO[PQ44-YL];PQ44-YT1: P_44R;	RTEMP3_P; *VALUE FOR Y	Y_P, P_RTEMP, CLEARF[H];	LTEMP2_P, Q_RTEMP1;	PQ RCY [44-Y], RTEMP2_Q;	Q_RTEMP, CALL[PQCOMP]; *PQ RCY [44-Y] FAILED ON [Y] = 44	CALL[CBRK,H=1];PQ44-YL1: Q_LTEMP2, P_RTEMP2;	PQ RCY [1], Q_RTEMP2;	RTEMP2_P, P_LTEMP2;	PQ RCY [1];	LTEMP2_P, P_RTEMP3;	RTEMP3_P_P-1, Q_44L;	Y_P, P_RTEMP, FRZBALUBC;	Q_RTEMP1, SETF[H], RETURN[ALU<0];	PQ RCY [44-Y], Q_LTEMP2, CALL[PQCOMP]; *PQ RCY [44-Y] FAILED ON Y	CALL[CBRK,H=1]; *H NOT LEFT 0 BY PQ RCY [44-Y]	GOTO[PQ44-YL1];H=1T:	RETURN[H=1];	BREAK;		*H WASN'T = 1 AFTER PQ RCY [44-Y] WITH [Y]>=44YLOADT:	P_A1, BAMASK[22];YTLOOP:	RTEMP1_MAPVA_P, PQ RCY [11], BAMASK[11];	Q_Y, CALL[PQCOMP]; *INTERRUPT ROUTINE CLOBBERED Y	P_RTEMP1, Q_400000S;	Q_P AND Q, PQ RCY [11], BAMASK[11];	YSHIFT_P OR Q, PQ RCY [0], BAMASK[11];	Q_Y, CALL[PQCOMP]; *INTERRUPT ROUTINE CLOBBERED Y	P_RTEMP1;	Y_P, PQ RCY [0], BAMASK[11];	Q_Y, CALL[PQCOMP]; *INTERRUPT ROUTINE CLOBBERED Y	P_RTEMP1, Q_1000S;	RTEMP1_P_P-Q, Q_400000S;	P AND Q, DGOTO[TMDR];	GOTO[YTLOOP,ALU#0];TMDR:	P_MDR_NULL;	Q_MDR, CALL[QZT];	*MDR OR MDR_ FAILED ON 0	MDR_P+1, P_B;	Q_MDR, CALL[PQCOMP];	*MDR OR MDR_ FAILED ON [P]	MDR_2P, P_B;	GOTO[.-2,ALU#0];	P_B, B_A1;	Q_B, MDR_2P;	P_MDR, CALL[PQCOMP];	*MDR OR MDR_ FAILED ON [Q]	Q LCY 1;	GOTO[.-2,Q ODD], MDR_Q;*ON "XSTART" ENTRY TO "DGM" CODE BELOW CHECKS OUT "INHINT"TKMDR:	P_KMDR_NULL, INHINT;	Q_KMDR, CALL[QZT];	*KMDR OR KMDR_ FAILED ON 0	KMDR_P+1, P_B, INHINT;	Q_KMDR, CALL[PQCOMP];	*KMDR OR KMDR_ FAILED ON [P]	KMDR_2P, P_B, INHINT;	GOTO[.-2,ALU#0], INHINT;	P_B, B_A1;	Q_B, KMDR_2P, INHINT;	P_KMDR, CALL[PQCOMP];	*KMDR OR KMDR_ FAILED ON [Q]	Q LCY 1;	GOTO[.-2, Q ODD], KMDR_Q, INHINT;TMDRL:	P_MDRL_NULL;	Q_MDRL, CALL[PQCOMP];	*MDRL OR MDRL_ FAILED ON [P]	P_B, MDRL_P+1, Q_17R;	*Q_17	P-Q;	GOTO[.-3,ALU<=0];TKMDRL:	P_KMDRL_NULL, INHINT;	Q_KMDRL, CALL[PQCOMP];	*KMDRL OR KMDRL_ FAILED ON [P]	P_P+1;	KMDRL_P, Q_17R, INHINT;	P-Q, INHINT;	GOTO[.-3,ALU<=0], INHINT;*~ MAXC2 ONLYTMDST:	CLEARF[-1S], MDR_-1S;	MDRL_NULL;	Q_MDR&SETTAG, P_A1, CALL[PQCOMP]; *B_MDR FAILED ON MDR&SETTAG	P_A0, Q_FLAGS, CLEARF[-1S], CALL[PQCOMP]; *TAG FLAGS LOADED WRONG ON MDR&SETTAG	MDRL_LTEMP_P+1;TMDSTL:	Q_MDR&SETTAG, P_A1, CALL[PQCOMP]; *B_MDR FAILED ON MDR&SETTAG	P_A0, Q_LTEMP;	PQ RCY [30], Q_FLAGS, CALL[PQCOMP]; *TAG FLAGS LOADED WRONG ON MDR&SETTAG	Q_LTEMP;	Q LSH 1, P_A1, BAMASK[4];	P-Q, CLEARF[-1S];	LTEMP_MDRL_Q, GOTO[TMDSTL,ALU>0];*~*JUMP OVER A BUNCH OF SUBROUTINES USED BY THE TESTS WHICH FOLLOW LATER	GOTO[TMVAT];%THE ROUTINES BELOW ARE SUBROUTINES WHICH ARE CALLED TO GENERATE ADDRESSESAND DATA FOR THE VARIOUS OTHER SECTIONS OF THE DIAGNOSTIC AND TO CHECKTHE RESULTS OF MEMORY READS.%*INITIALIZE THE MEMORY ADDRESS VARIABLES "SADR" AND "LADR"AINI:	Q_MLOW, P_LSAVE;	SADR_LADR_Q, Q_RSAVE, RETURN;*GENERATE NEXT ADDRESS, RETURN IT IN Q AND THRU ALU, 17 IN P.	CALLED WITH*PREVIOUS ADDRESS IN P.	TIMING = 3AGEN:	Q_P+1, P_MHIGH;AGEN0:	P-Q;	LADR_SADR_Q, P_17R, FRZBALUBC, RETURN;*GENERATE PREVIOUS ADDRESS LSH 1, RETURN IT IN Q AND THRU ALU BUT RETURN*MLOW ON FIRST ADDRESS > MHIGH.  CALLED WITH PREVIOUS ADDRESS IN Q.AGEN1:	0Q RCY [43], Q_MHIGH;AGEN3:	P_Q, Q_P, GOTO[AGEN0];AGEN2:	NOT(A0)Q RCY [43], Q_MHIGH, GOTO[AGEN3];*INITIALIZE THE DATA CELLS "SDATA", "SDATAL" AND "SBASE", "SBASEL" TO A*SINGLE 1.  TIMING = 4DINIS1:	P_SDATA_NULL;	Q_P+1, SBASE_NULL;	SDATAL_Q;	SBASEL_Q, RETURN;*INITIALIZE THE DATA CELLS "SDATA" "SDATAL" AND "SBASE", "SBASEL" TO A*SINGLE 0.  TIMING = 5DINIS0:	P_Q_377777 777777S;	SDATA_Q;	SBASE_Q, Q_17R;	SDATAL_Q;	SBASEL_Q, RETURN;*PUT SBASE, SBASEL IN SDATA, SDATAL*TIMING = 4DSET:	Q_SBASE;	SDATA_Q;	Q_SBASEL;	SDATAL_Q, GOTO[AINI];*RCY 1 THE 40-BIT QUANTITY IN SBASE, SBASEL AND LEAVE IT IN SDATA,SDATAL ALSO*RETURNS WITH SDATA THRU ALU AND SDATAL IN Q*TIMING = 8BDADV:	Q_SBASEL;	PQ RCY [4], Q_SBASE;	LTEMP1_Q, PQ RCY [41], BAMASK[4], Q_SBASEL;	RTEMP2_MDR_P, P_LTEMP1;	SBASEL_MDR, PQ RCY [1];	SDATAL_MDR, Q_P;	SDATA_Q;	SBASE_Q, AQ, RETURN, Q_RTEMP2;*RCY BY 1 THE 40-BIT QUANTITY IN SDATA, SDATAL.*TIMING = 7DGEN:	Q_SDATAL, RSAVE_Q;	LSAVE_P, PQ RCY [4], Q_SDATA;	LTEMP1_Q, PQ RCY [41], BAMASK[4], Q_SDATAL;	MDR_P, P_LTEMP1;	SDATAL_MDR, PQ RCY [1];	Q_P;	SDATA_Q, Q_RSAVE, P_LSAVE, RETURN;*COMPLEMENT THE DATA IN SBASE AND SBASEL AND LEAVE IT IN SDATA, SDATAL AND*IN MDR, MDRL ALSO.*TIMING = 5NMDATA:	Q_SBASE, RSAVE_Q;	LSAVE_P, P_SBASEL;	Q_NOT Q;	SBASE_MDR_Q, P_NOT P, BAMASK[4];	SDATA_Q, Q_P;	SBASEL_MDRL_Q;	SDATAL_Q, GOTO[AINI];*COMPLEMENT SDATA, SDATAL AND LEAVE IN MDR, MDRL*HAVE NOT(SDATA) IN Q, SDATAL IN P AT CALLNDGEN:	SDATA_MDR_Q, P_NOT P, BAMASK[4];	WRESTART, MDRL_Q_P;	SDATAL_Q, RETURN;*COMPARE THE DATA IN MDR, MDRL TO THE DATA IN SDATA, SDATAL*TIMING = 10DCOMP:	LSAVE_P, P_SDATA;	RSAVE_Q, Q_MDR;	Q_P#Q, P_DMASK;	Q_P AND Q, CALL[AZT], P_MDRL; *WRONG BITS FOR MDR COMPARE IN Q	Q_SDATAL;	Q_P#Q, P_DMASKL;	Q_P AND Q, CALL[AZT];	*WRONG BITS FOR MDRL COMPARE IN Q	P_LSAVE, Q_RSAVE, RETURN;*COMPARE THE DATA IN KMDR, KMDRL TO THAT IN SDATA, SDATAL*TIMING = 10KDCOMP:	LSAVE_P, P_SDATA;	RSAVE_Q, Q_KMDR;	Q_P#Q, P_KDMASK;	Q_P AND Q, CALL[AZT], P_KMDRL; *WRONG BITS FOR KMDR COMPARE IN Q	Q_SDATAL;	Q_P#Q, P_KDMASKL;	Q_P AND Q, CALL[AZT];	*WRONG BITS FOR KMDRL COMPARE IN Q	P_LSAVE, Q_RSAVE, RETURN;*SUBROUTINE TO CHECK AFTERMATH OF ILLEGAL MEMORY REFERENCES IN MONITOR*MODE.IRFCHK:	CALL[CBRK,G=0];	*READ ILLEGAL SO SHOULD LEAVE G=1	CALL[CBRK,H=1], SETSF[CUM&H]; *NO XCTI FLAGS SET SO H=0	P_MAR, Q_RTEMP, CALL[PQCOMP]; *THE ADDRESS PUT INTO RTEMP AND INTO				*MONITOR MAP ENTRY FOR THE PAGE CONTAINING				*THE CURRENT ADDRESS CONSISTS OF THE LOW 9				*BITS OF THE CURRENT ADDRESS AND THE COMPLEMENT				*OF THE REST OF THE ADDRESS MASKED BY MHIGH.				*THIS SHOULD WIND UP IN MAR REGARDLESS OF THE				*LEGALITY OF THE REF OR WHETHER IT IS AND AC				*REFERENCE	CALL[CBRK,H=1], P_MHIGH; *MHIGH IS JUST A RANDOM VALUE FOR ITS				*USE HERE TO FIND OUT WHETHER THE MEMORY INTER-				*FACE WAS ACTIVE DESPITE THE ILLEGALITY OF THE				*READ.	CLEARF[-1S], Q_MDR, CALL[PQCOMP]; *CHECK FOR MDR UNCHANGED	Q_MDRL, P_RTEMP1, CALL[PQCOMP]; *CHECK FOR MDRL UNCHANGED	P_LADR, MDRL_P;	MAPVA_P, RETURN;*SUBROUTINE TO CHECK OUT THE AFTERMATH OF MONITOR MODE READ REF'SMRCHK:	CALL[CBRK,H=1], SETSF[CUM&H]; *H=0 BECAUSE NOT A FORCED USER REF	CALL[CBRK,H=1];	 *CUM=0 BECAUSE MONITOR MODE AND XCTI=0RCHK:	P_MAR, Q_RTEMP, CALL[PQCOMP]; *MAR SHOULD BE [Q]RCHK1:	P_SDATA, CALL[CBRK,G=1];	*RP OR XP WAS 0 IN MAP SO REF SUCCEEDS	CLEARF[-1S], Q_MDR;	*COMPARE THE DATA FROM THE READ	Q_P#Q, P_DMASK;	P AND Q, P_MDRL;	Q_SDATAL, CALL[CBRK,ALU#0];	*(MDR XOR SDATA) AND DMASK # 0	Q_P#Q, P_DMASKL;	P AND Q, P_LADR, MDR_NULL;	Q_SDATA, RETURN[ALU=0];	*RETURN SDATA IN Q IN CASE "NDGEN" NEXT	BRKP[1];			*(MDRL XOR SDATAL) AND DMASKL # 0*SUBROUTINE TO CHECK AFTERMATH OF FORCED USER READS WITH CFM=1CFMCHK:	CALL[CBRK,H=0], SETSF[CUM&H];	CALL[CBRK,H=1]; *CUM=0 BECAUSE CFM=1	GOTO[RCHK];*SUBROUTINE TO TEST THE AFTERMATH OF READ REF'S IN MONITOR MODE WHICH ARE*FORCED TO USER MODE BY THE SETTING OF AN XCTI FLAG IN FFURCHK:	CALL[CBRK,H=0], SETSF[CUM&H]; *FORCED UM REF SO H=1	CALL[CBRK,H=0];	 *CUM SHOULD BE 1 SINCE XCTI=1 FOR REF	P_MAR, Q_LTEMP, CALL[PQCOMP];	GOTO[RCHK1];*SUBROUTINE TO TEST THE AFTERMATH OF A LEGAL USER MODE READURCHK:	CALL[CBRK,H=1], SETSF[CUM&H]; *NOT A FORCED UM REF	CALL[CBRK,H=0];	 *CUM SHOULD BE 1 SINCE UM=1 FOR REF	GOTO[RCHK];*SUBROUTINE TO TEST THE AFTERMATH OF MAPVA_.  CALLED WITH 17 IN Q,*ADDRESS IN P, CORRECT [F] IN RTEMP (BUT G=0).	RETURNS WITH F=0.*TIMING = 13+1 IF AC*! MAXC1 ONLYTMVAX:	P-Q, Q_RTEMP, P_NOT F;	DGOTO[TMVAAC,ALU<=0], P=Q;*!*~ MAXC2 ONLYTMVAX:	P-Q, Q_RTEMP, P_FLAGS;	P#Q, DGOTO[TMVAAC,ALU<=0];*~	Q_(Q) U (1S), FRZBALUBC;TMVA0:	CALL[CBRK,ALU#0], P_LADR, Q_377S; *MAPVA_ LOADED F INCORRECTLY				*(CORRECT VALUE= RTEMP OR RTEMP+1 IF AC)	Q_P AND Q, P_X, CALL[PQCOMP]; *MAPVA_ DIDN'T LOAD X FROM B[28-35]	P_LADR, Q_MAR, CALL[PQCOMP]; *MAPVA_ DIDN'T LOAD MAR FROM [P]	PQ RCY [11], SAMASK[11], CALL[PQCOMP], Q_Y; *MAPVA_ DIDN'T LOAD Y				*FROM B[18-26]=[P]	RETURN, CLEARF[-1S];*! MAXC1 ONLYTMVAAC:	P=Q, GOTO[TMVA0];*!*~ MAXC2 ONLYTMVAAC:	P#Q, GOTO[TMVA0];*~*TEST OUT MAPVA_ ON ALL LEGAL ADDRESSES WITH THE AFFECTED REGISTERS*BOTH ORIGINALLY 0 AND ORIGINALLY -1 AND WITH MAPVA_ TESTED USING BOTH*THE ALU TEST AND THE ACFS TEST.*TIMING = ((MHIGH-MLOW)*16*8)+1 = ABOUT 128*(MHIGH-MLOW) CYCLESTMVAT:	SETSF[IENABLE&G];	SADR_MAPVA_NULL, LADR_A0, GOTO[TWRT,G=1];	RTEMP_A0, P_LADR, CLEARF[-1S];	MAPVA_P, Q_17R, CALL[TMVAX];	MAPVA_A1;	P_CUM&UM;	RTEMP_P, P_LADR, SETF[UM];	MAPVA_P, Q_17R, CALL[TMVAX];	MAPVA_NULL;	P_NOTGUMCUM;	RTEMP_P, P_LADR, SETF[NOTUM];	MAPVA_P, Q_17R, CALL[TMVAX];	MAPVA_A1;	P_NOT G;	RTEMP_P, P_LADR, SETF[NOTCUM];	MAPVA_P, Q_17R, CALL[TMVAX];	MAPVA_NULL;	RTEMP_A0, CLEARF[-1S];	MAPVA_P_SADR, Q_17R, ACFS, CALL[TMVAX];	MAPVA_A1;	P_CUM&UM;	RTEMP_P, SETF[UM];	MAPVA_P_SADR, Q_17R, CALL[TMVAX];	MAPVA_NULL;	P_NOTGUMCUM;	RTEMP_P, SETF[NOTUM];	MAPVA_P_SADR, Q_17R, CALL[TMVAX];	MAPVA_A1;	P_NOT G;	RTEMP_P, SETF[NOTCUM], CALL[RETN];	MAPVA_P_SADR, ACFS, Q_17R, CALL[TMVAX];*NOW TRY WRITE_, READ_, AND RMW_ ALLOWING TIME FOR REFERENCES TO FINISH.*MAR AND [F] UNCHANGED ARE CHECKED FOR AND THE DATA IS COMPARED AFTER*ANDING WITH DMASK, DMASKL*TIMING = 160*((MHIGH-MLOW)*81+25+3)+19 OR ABOUT 12,960*(MHIGH-MLOW) CYCLES*! MAXC1 ONLYTWRT:	P_NOT F;		*CHECK FOR F GETTING CLOBBERED*!*~ MAXC2 ONLYTWRT:	P_FLAGS;*~	LTEMP_P, CALL[AINI];TWR0:	CALL[DINIS1];		*INITIALIZE SDATA, SDATAL, SBASE, SBASEL	CALL[SWRT];		*CHECK WRITE_, RMW_, AND READ_ ON EVERY ADDRESS				*USING DATA GENERATED FROM SBASE, SBASEL	CALL[BDADV];		*LOOP THROUGH THE 40 VALUES OF SBASE, SBASEL				*BDADV RETURNS WITH SBASEL IN Q (NOT SLOW SOURCE)	GOTO[.-2,Q EVEN];	*WHICH HAVE A SINGLE 1 WITH 39 0'S	CALL[DINIS0];		*REPEAT THE ABOVE FOR THE 40 VALUES OF SBASE,	CALL[SWRT];		*SBASEL WHICH HAVE A SINGLE 0 WITH 39 1'S	CALL[BDADV];		*BDADV RETURNS WITH SBASE THROUGH ALU	GOTO[.-2,ALU<0];*! MAXC1 ONLY	P_NOT F, Q_LTEMP, CALL[PQCOMP]; *F SMASHED DURING THE PRECEDING*!*~ MAXC2 ONLY	P_FLAGS, Q_LTEMP, CALL[PQCOMP];*~	GOTO[TKWRT];*TIMING = (MHIGH-MLOW)*(19+33+29)+25SWRT:	CALL[WLP];	CALL[RMWLP];	CALL[RLP];	CALL[HSRMWLP];	GOTO[RLP];	*RETURN TO CALLER OF SWRT*SEQUENTIALLY WRITE ALL THE ADDRESSES IN THE MACHINE USING DATA WHICH IS*RCY 1 FROM THE PRECEDING WORD'S DATA EACH TIME WITH THE ORIGINAL DATA*BEING THE VALUE IN SBASE, SBASEL.*TIMING = (MHIGH-MLOW)*19+1WLP:	WRITE_Q_SADR, INHINT;	MDR_SDATA, INHINT;	MDRL_SDATAL;	P_MAR, CALL[PQCOMP];	*WRITE DIDN'T LOAD MAR FROM B	CALL[DGEN], Q_SDATAL;	CALL[AGEN], P_LADR, MDR_MDR;	GOTO[WLP,ALU>=0];	GOTO[DSET];*TIMING = (MHIGH-MLOW)*33+1RMWLP:	RMW_Q_SADR, INHINT;	P_MAR, CALL[PQCOMP];	*MAR NOT LOADED BY RMW_.  CORRECT VALUE IN Q	Q_SDATA;	CALL[DCOMP], P_SDATAL;	*ADDRESS OF DATA IN LADR OR SADR	MDR_NOT Q, WRESTART;	MDRL_NOT P, CALL[DGEN], P_LADR;	CALL[PQCOMP], Q_MAR;	*WRESTART SMASHED MAR	CALL[AGEN];	GOTO[RMWLP,ALU>=0];	GOTO[NMDATA];*TIMING = (MHIGH-MLOW)*29+1RLP:	READ_Q_SADR;	P_MAR, CALL[PQCOMP];	*MAR NOT LOADED BY READ_.  CORRECT VALUE IN Q	CALL[DCOMP];		*ADDRESS IN BOTH SADR AND LADR	CALL[DGEN];	CALL[AGEN], P_LADR;	GOTO[RLP,ALU>=0];	GOTO[DSET];*THE FOLLOWING ROUTINE EXERCISES RMW_ AT A HIGHER SPEED THAN THE PRECEDING*TEST WITHOUT ERROR CHECKS SUCH THAT THE ERRORS ARE CAUGHT BY THE FOLLOWING*READ_ CHECKHSRMWLP: RMW_SADR, INHINT, CALL[RETN]; ****REMOVE CALL WHEN MEM INT WORKS	Q_MDR;	P_MDRL, WRESTART;	MDR_NOT Q, INHINT;	MDRL_NOT P, CALL[DGEN];	P_LADR, CALL[AGEN];	GOTO[HSRMWLP,ALU>=0];	GOTO[NMDATA];*EXCEPT THAT [F] IS NOT CHECKED FOR BEING UNCHANGED.*TIMING = (MHIGH-MLOW)*(19+31+29)+26SKWRT:	CALL[KWLP];		*WRITE EVERY ADDRESS USING NUMBERS				*GENERATED FROM THE CURRENT SBASE, SBASEL	CALL[KRLP];		*NOW KREAD_ AND CHECK THE RESULTS	CALL[NMDATA];	GOTO[BDADV];		*CYCLE THE DATA BASE AND RETURN*TIMING = 80*((MHIGH-MLOW)*(19+33+29)+29)+19 = ABOUT 6,340*(MHIGH-MLOW) CYCLES*! MAXC1 ONLYTKWRT:	P_NOT F;*!*~ MAXC2 ONLYTKWRT:	P_FLAGS;*~	LTEMP_P, CALL[AINI];	CALL[DINIS1];	CALL[SKWRT];	GOTO[.-1, Q EVEN];	CALL[DINIS0];	CALL[SKWRT];	GOTO[.-1,ALU<0];*! MAXC1 ONLY	P_NOT F, Q_LTEMP, CALL[PQCOMP]; *F SMASHED BY ONE OF DISK MEMORY				*INTERFACE FUNCTIONS*!*~ MAXC2 ONLY	P_FLAGS, Q_LTEMP, CALL[PQCOMP];*~	SETSF[IENABLE&G], DGOTO[TSTOP];	GOTO[MCTEST,G=0];KWLP:	KWRITE_Q_SADR, INHINT;	KMDRL_SDATAL, INHINT;	KMDR_SDATA;	P_KMAR, CALL[PQCOMP];	*KWRITE_ DIDN'T LOAD KMAR FROM B OR KMAR				*BUS SOURCE FAILED	CALL[DGEN];		*GENERATE THE NEXT DATA VALUE (PREVIOUS RCY 1)	CALL[AGEN], P_LADR;	*GENERATE THE NEXT ADDRESS	GOTO[KWLP,ALU>=0];	*FALL THRU WHEN ADDRESS = 0 AGAIN	GOTO[DSET];*TIMING = 29*(MHIGH-MLOW)+1KRLP:	KREAD_Q_SADR;	P_KMAR, CALL[PQCOMP];	*KREAD_ DIDN'T LOAD KMAR CORRECTLY	Q_Q;	CALL[KDCOMP];	CALL[DGEN];	CALL[AGEN], P_LADR;	GOTO[KRLP,ALU>=0];	RETURN;*MEMORY COMPETITION TEST USING BOTH MEMORY INTERFACES*(1) WRITE_ FROM PROC, KREAD_ FROM DISK*(2) RMW_ FROM PROC, KRMW_ FROM DISK*(3) READ_ FROM PROC, KREAD_ FROM DISK*(4) KWRITE_ FROM DISK, READ_ FROM PROC**THIS TEST PERFORMED ONLY IF MASKS ARE ALL 1'SMCTEST:	P_KDMASK;	P_DMASK, NOT P;	P_KDMASKL, Q_17R, NOT P, GOTO[TREFS,ALU#0];	P_DMASKL, P#Q, GOTO[TREFS,ALU#0];	P#Q, GOTO[TREFS,ALU#0];	GOTO[TREFS,ALU#0];	CALL[AINI], CLEARF[-1S], LTEMP_A1;	CALL[DINIS1];	CALL[SPKWRT];	GOTO[.-1,Q EVEN];	CALL[DINIS0];	CALL[SPKWRT];	GOTO[.-1,ALU<0];*! MAXC1 ONLY	P_NOT F, Q_LTEMP, CALL[PQCOMP]; *F SMASHED BY ONE OF DISK OR PROC			*MEMORY FUNCTIONS*!*~ MAXC2 ONLY	P_FLAGS, Q_LTEMP, CALL[PEQZ];*~*MEMORY COMPETITION TEST HITTING THE PROCESSOR INTERFACE WITH A REF*AND THE DISK INTERFACE WITH A REFERENCE IN THE SAME MICROINSTRUCTION.*THE PROCESSOR INTERFACE SHOULD WIN.***NOTE THAT THE REF'S HAVE NOT BEEN TESTED YET, SO THAT THE FOLLOWING***TEST IS OUT OF SEQUENCE.  HOWEVER, WHEN UNTESTED MAXC'S ARE BROUGHT***UP YOU SHOULD FIRST RUN DGM WITH ALL DATA COMPARE MASKS SET TO 0.***THIS SHOULD CATCH PROBLEMS WITH REF'S.  THESE TESTS WERE PUT HERE TO***KEEP THEM WITH THE OTHER MEMORY BASHING TESTS.  REMEMBER THAT***NONE OF THESE TESTS GET RUN WHEN DATA COMPARE MASKS AREN'T ALL 1'S.MCT2:	CLEARF[-1S], CALL[MAPINI];	CALL[DINIS1];	CALL[KREFT];	GOTO[.-1,Q EVEN];	CALL[DINIS0];	CALL[KREFT];	GOTO[.-1,ALU<0];	GOTO[TREFS];PWKRLP:	Q_MDR_SDATA;	WRITE_SADR, INHINT;	KREAD_SADR, INHINT;	P_MDRL_SDATAL;	RTEMP_P, P_KMDR, CALL[PQCOMP];	P_RTEMP, Q_KMDRL, CALL[PQCOMP];	CALL[DGEN];	P_LADR, CALL[AGEN];	GOTO[PWKRLP,ALU>=0];	GOTO[DSET];PRKRLP:	READ_SADR;	KREAD_SADR;	Q_MDR;	P_KMDR, CALL[PQCOMP];	Q_MDRL;	P_KMDRL, CALL[PQCOMP];	CALL[DGEN];	CALL[AGEN], P_LADR;	GOTO[PRKRLP,ALU>=0];	GOTO[DSET];KWPRLP:	P_KMDR_SDATA;	KWRITE_SADR, INHINT;	READ_SADR, INHINT;	Q_KMDRL_SDATAL;	RTEMP_Q, Q_MDR, CALL[PQCOMP];	Q_MDRL, P_RTEMP, CALL[PQCOMP];	CALL[DGEN];	P_LADR, CALL[AGEN];	GOTO[KWPRLP,ALU>=0];	GOTO[DSET];SPKWRT:	CALL[PWKRLP];	CALL[PRKRLP];	CALL[KWPRLP];	GOTO[BDADV];*SUBROUTINE TO NEUTRALIZE MAP BY FILLING IT WITH READ, WRITE, AND ACCESS*PERMISSION AND POINTING EACH VIRTUAL PAGE AT THE ABSOLUTE PAGE OF THE SAME*NUMBER.MAPINI:	MAP_Y, INCY, GOTO[.,Y>=0];	MAP_Y, INCY, GOTO[.,Y<0];	RETURN;*PROCESSOR WREF AND KREAD_PWREFKR: P_Q_17R, CALL[AGEN];PWRFKRLP: MAPVA_SADR, ACFS;	WREF, CALL[CBRK,G=1], KREAD_SADR, INHINT;	Q_MDRL_SDATAL, INHINT, CALL[CBRK,G=1];	RTEMP_Q, Q_MDR_SDATA;	P_KMDR, CALL[PQCOMP];	P_KMDRL, Q_RTEMP, CALL[PQCOMP];	CALL[DGEN];	P_LADR, CALL[AGEN];	GOTO[PWRFKRLP,ALU>=0];	GOTO[DSET];*PROCESSOR RREF AND KWRITE_PRREFKW: P_Q_17R, CALL[AGEN];PRREFKWLP: Q_SDATA;	P_SDATAL;	MAPVA_SADR, ACFS;	RREF, CALL[CBRK,G=1], KWRITE_SADR, INHINT;	KMDR_NOT Q, INHINT, CALL[CBRK,G=1];	KMDRL_NOT P;	RTEMP_P, P_MDR, CALL[PQCOMP];	P_RTEMP, Q_MDRL, CALL[PQCOMP];	CALL[DGEN];	P_LADR, CALL[AGEN];	GOTO[PRREFKWLP,ALU>=0];	GOTO[NMDATA];KREFT:	CALL[PWREFKR];	CALL[PRREFKW];	GOTO[BDADV];*TEST DISK MEMORY INTERFACE STOP LOGICTSTOP1:	CALL[AINI];	*INITIALIZE ADDRESS TO 0TSTOPA:	READ_SADR;	*MAKE MEMORY QUADRANT BUSY	KWRITE_SADR, INHINT;	KMDR_A1, CALL[RETN];	KMDR_NULL;	*SHOULD INVOKE STOP LOGIC	KREAD_SADR, CALL[RETN];	P_KMDR, CALL[NPZT];	*KMDR_ DIDN'T INVOKE STOP LOGIC ON KWRITE_	READ_SADR;		*MAKE MEMORY QUADRANT BUSY	KWRITE_SADR, INHINT;	KMDRL_KMDR_A1, CALL[RETN];	KMDRL_NULL;		*SHOULD INVOKE STOP LOGIC	KREAD_SADR, CALL[RETN];	P_KMDRL, Q_17R, CALL[PQCOMP]; *KMDRL_ DIDN'T INVOKE STOP LOGIC ON KWRITE_	P_LADR, CALL[AGEN];	GOTO[TSTOPA,ALU>=0];*TEST PROCESSOR MEMORY INTERFACE STOP LOGICTSTOP2:	CALL[AINI];TSTOPB:	KREAD_SADR;	*MAKE QUADRANT BUSY	WRITE_SADR, INHINT;	MDR_A1, CALL[RETN];	MDR_NULL;	*SHOULD INVOKE STOP LOGIC	READ_SADR, CALL[RETN];	*CHECK RESULTS	P_MDR, CALL[NPZT];	*MDR_ DIDN'T INVOKE STOP LOGIC ON WRITE_	KREAD_SADR;	*MAKE QUADRANT BUSY	WRITE_SADR, INHINT;	MDRL_MDR_A1, CALL[RETN];	MDRL_NULL;	*SHOULD INVOKE STOP LOGIC	READ_SADR, CALL[RETN];	*CHECK RESULTS	P_MDRL, Q_17R, CALL[PQCOMP];	*MDRL_ DIDN'T INVOKE STOP LOGIC	P_LADR, CALL[AGEN];	GOTO[TSTOPB,ALU>=0];INSERT[DGMB.MC];