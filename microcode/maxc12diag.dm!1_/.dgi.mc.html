<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12diag.dm!1>dgi.mc</title>
  </head>
  <body>
    <pre>
%TO ASSEMBLE:	MICRO/L LANG DGI -OR- @MI@ DGITO RUN:		MIDAS RDGI -OR- MIDAS DGI		START;GCURRENT SOURCES ON MAXC &lt;ERF&gt; DIRECTORY%*TEST OF THE INTERRUPT SYSTEM AND PARTS OF THE PROCESSOR AFFECTED BY INTERRUPTSINSERT[DGIB.MC];LVN[LTEMP];*TEST THAT ARM&larr; AND ARM AGREE FOR INTERRUPT CHANNELS 0 THROUGH 15.**INTERRUPT CHANNEL 17 (INTERRUPTS AT 17, REPRESENTED BY BIT 35 IN ARM)**PERMANENTLY REQUESTS AN INTERRUPT.**INTERRUPT CHANNEL 16 (INTERRUPTS AT 16, REPRESENTED BY BIT 34 IN ARM)**ENABLES LOCAL MEMORY PARITY ERROR TRAP.*THE TEST OF CHANNELS 0 THROUGH 15 DOES NOT TEST THE INTERRUPT SYSTEM*ITSELF BUT ONLY THE ARM REGISTER.  CHANNEL 17 IS THE HIGHEST PRIORITY*INTERRUPT, CHANNEL 0 THE LOWEST PRIORITY.TARM:	ARM&larr;P&larr;NULL;	Q&larr;ARM;	Q&larr;(NOT Q) U (377700 000000S), CALL[NQZT]; *ARM REG. WON'T CLEAR TO 0	Q&larr;P+1, CALL[QLCY17], CLEARF[-1S];TARML:	ARM&larr;Q;	P&larr;ARM;	P&larr;(NOT P) U (377700 000000S), CALL[PEQZ]; *ARM REG WON'T SET TO [Q]	Q RSH 1;	GOTO[TARML,Q EVEN];*NOW TEST OUT THE INTERRUPT CHANNEL WHICH ALWAYS REQUESTS AN INTERRUPTINT0:	ARM&larr;P&larr;NULL;	CLEARF[-1S];	ARM&larr;Q&larr;P+1;		*ARM THE INTERRUPT CHANNEL.	NOTHING SHOULD				*HAPPEN BECAUSE IENABLE=0	X&larr;P&larr;NULL;		*WASTE TIME TO ALLOW INTERRUPT TO OCCUR IF	Y&larr;P&larr;NULL;		*IT WANTS TO	P&larr;MDR&larr;NULL;	SETF[IENABLE&amp;G];*FIRST CHECK THAT THE STACK AND CONTROL IS MAINTAINED CORRECTLY ACCROSS*INTERRUPTS.	DETERMINE THAT THE TOP ENTRY ON THE STACK IS FROM THE*CORRECT PLACE AND THAT THE NEXT ENTRY ON THE STACK WASN'T SMASHED.MC[XCT0&amp;G,XCT0,G]; *XCT0 SIGNALS THE INTERRUPT ROUTINE WHAT TO CHECKSLC[@TC0: E1[TC0]];	SLC[@TC0A: E1[TC0A]];SLC[@TG0: E1[TG0]];	SLC[@2001: E1[2001]];SLC[@TR0: E1[TR0]];	SLC[@TR0A: E1[TR0A]];	SETF[XCT0&amp;G], INHINT;	Q&larr;@TC0, INHINT;	STEMP&larr;Q, INHINT;	Q&larr;@TC0A, INHINT;	STEMP1&larr;Q, INHINT;	CALL[TC0A];	*INTERRUPT OCCURS AFTER THIS INSTRTC0:	BREAK;	*STK 0 SHOULD POINT HERETC0A:	BREAK;	*NO INTERRUPT OCCURRED	Q&larr;@TR0, INHINT; *STK 1 SHOULD POINT HERE	STEMP&larr;Q, INHINT, CALL[.+1];TR0:	Q&larr;@TR0A, INHINT, DGOTO[TR0A];	STEMP1&larr;Q, INHINT, CALL[.+1];	RETURN;	*INTERRUPT OCCURS AFTER THIS	BREAK; *INTERRUPT DIDN'T TAKE AND RETURN DIDN'T COMPLETE	BREAK;TR0A:	BREAK;	*NO INTERRUPT OCCURRED	Q&larr;@TG0, INHINT, DGOTO[2001];	STEMP1&larr;Q, INHINT, CALL[.+1];	Q&larr;@2001, INHINT;	STEMP&larr;Q, INHINT;	GOTO[TG0];	*INTERRUPT OCCURS AFTER THIS	BREAK;	*GOTO DIDN'T TAKE AND INTERRUPT FAILED	BREAK;TG0:	BREAK;	*NO INTERRUPT OCCURRED	CLEARF[-1S], INHINT;	INHINT;	INHINT;*NOW CHECK THE PRESERVATION OF BRANCH CONDITIONS AND REGISTERS ACCROSS*INTERRUPTS AND THE PROPER OPERATION OF THESE REGISTERS DURING INTERRUPTS	X&larr;P&larr;NULL;	Y&larr;P&larr;NULL;	P&larr;NULL, L7&larr;A0;	SETF[IENABLE&amp;G];	CALL[INTX];*INTERRUPT ROUTINE COMES BACK HERE FROM BELOW WHEN K=1 WITH K=0.	REGISTER*COMPARISON VALUE IS IN L7.	Q&larr;L7, FRZBALUBC, GOTO[.+2,ALU=0], INHINT;FBC0:	BREAK;	*ALU=0 WASN'T PRESERVED DURING INTERRUPT	GOTO[.+2,ALU&gt;=0], FRZBALUBC, INHINT;	BREAK;			*ALU&gt;=0 WASN'T PRESERVED	GOTO[.+2,ALU8=0], FRZBALUBC, INHINT;	BREAK;			*ALU8=0 WASN'T PRESERVED	GOTO[.+2,ALU&lt;=0], FRZBALUBC, INHINT;	BREAK;			*ALU&lt;=0 WASN'T PRESERVED	GOTO[.+2,B&gt;=0], FRZBALUBC, INHINT;FBC1:	BREAK;	*B&gt;=0 WASN'T PRESERVED	CALL[CBRK,ALU#0], FRZBALUBC, INHINT; *ALU=0 WASN'T PRESERVED	CALL[CBRK,ALU&lt;0], FRZBALUBC, INHINT; *ALU&gt;=0 WASN'T PRESERVED	CALL[CBRK,ALU8=1], FRZBALUBC, INHINT; *ALU8=0 WASN'T PRESERVED	CALL[CBRK,ALU&gt;0], FRZBALUBC, INHINT; *ALU&lt;=0 WASN'T PRESERVED	CALL[CBRK,B&lt;0], FRZBALUBC, INHINT, Q&larr;MDR; *B&gt;=0 WASN'T PRESERVED	P#Q, INHINT, CLEARF[IENABLE&amp;G];	GOTO[.+2,ALU=0], INHINT;FBC2:	BREAK;	*P NOT PRESERVED ACROSS INT	P&larr;X, CALL[PZT];	 *X NOT PRESERVED	P&larr;Y, CALL[PZT];	 *Y NOT PRESERVED	X&larr;P&larr;B, B&larr;A1, SETF[IENABLE&amp;G];	CALL[INTY], MDR&larr;A1;*RETURN HERE FROM THE INTERRUPT WHICH TAKES ONE INSTRUCTION AFTER THE*INSTRUCTION ABOVE	Q&larr;MDR, FRZBALUBC, INHINT, GOTO[.+2,ALU#0];FBC3:	BREAK;	*ALU#0 WASN'T PRESERVED DURING INTERRUPT	GOTO[.+2,ALU&lt;0], FRZBALUBC, INHINT;	BREAK;			*ALU&lt;0 WASN'T PRESERVED	GOTO[.+2,ALU8=1], FRZBALUBC, INHINT;	BREAK;			*ALU8#0 WASN'T PRESERVED	GOTO[.+2,ALU&lt;=0], FRZBALUBC, INHINT;	BREAK;			*ALU&lt;=0 WASN'T PRESERVED***NOTE THAT THE OTHER STATE OF ALU&lt;=0 HASN'T BEEN TESTED	GOTO[.+2,B&lt;0], FRZBALUBC, INHINT;FBC4:	BREAK;	*B&lt;0 WASN'T PRESERVED	CALL[CBRK,ALU=0], FRZBALUBC, INHINT; *ALU#0 WASN'T PRESERVED	CALL[CBRK,ALU&gt;=0], FRZBALUBC, INHINT; *ALU&lt;0 WASN'T PRESERVED	CALL[CBRK,ALU8=0], FRZBALUBC, INHINT; *ALU8=1 WASN'T PRESERVED	CALL[CBRK,ALU&gt;0], FRZBALUBC, INHINT; *ALU&lt;=0 WASN'T PRESERVED	CALL[CBRK,B&gt;=0], FRZBALUBC, INHINT; *B&lt;0 WASN'T PRESERVED	P#Q, INHINT, CLEARF[IENABLE&amp;G];	GOTO[.+2,ALU=0], INHINT;FBC5:	BREAK;	*P NOT PRESERVED ACROSS INT	INCX;	P&larr;X, INCY, CALL[PZT];	*X NOT PRESERVED ACROSS INT	P&larr;Y, CALL[PZT];	 *Y NOT PRESERVED ACROSS INT	SETF[IENABLE&amp;G], CALL[.+2];FBC6:	BREAK;	*INT. OCCURRED DURING DGOTO, NPC&larr;, F2[2], F2[3], RMW&larr;	DGOTO[.+2], SETF[K], P&larr;NULL;	DGOTO[.+2], P&larr;P+1;	DGOTO[.+2], P&larr;P+1, P&larr;P+1;	DGOTO[.+2], P&larr;P+1;	P&larr;NPC&larr;NPC;	GOTO[.+1], P&larr;P+1, INHINT;	RMW&larr;NULL, P&larr;P+1, INHINT;	REPEAT[13,ILC[(P&larr;P+1, Q&larr;Q)]];	P&larr;P+1, WRESTART;*F2[2] AND F2[3] ARE CURRENTLY NOT IMPLEMENTED BUT ARE SUPOSED TO STOP*INTERRUPTS JUST AS F2[0] AND F2[1] (INHINT AND NPC&larr;) DO	P&larr;P+1, F2[2]; P&larr;P+1, F2[2]; P&larr;P+1, F2[2];	P&larr;P+1, F2[3]; P&larr;P+1, F2[3]; P&larr;P+1, F2[3];%INTERRUPTS CURRENTLY NOT INHIBITED DURING KRMW&larr;	KRMW&larr;NULL, INHINT;	REPEAT[13,ILC[(Q&larr;Q)]];	KWRESTART;%	DGOTO[.+1], P&larr;P+1;	DGOTO[.+2], P&larr;P+1, ARM&larr;NULL;	P&larr;NPC&larr;NPC;	GOTO[.+1], P&larr;P+1, INHINT;	GOTO[DGIEND], ARM&larr;NULL, INHINT;INTX:	SETF[H], Q&larr;NULL;	*INTERRUPT SHOULD OCCUR AFTER THIS INSTR.	BREAK;			*INTERRUPT FAILED TO OCCUR*INTERRUPT COMES BACK HERE WITHOUT PREIRET SO PRECISELY ONE INSTRUCTION*SHOULD OCCUR.	H=0 ON THE RETURN.INT1:	SETF[J];	BREAK;			*INTERRUPT FAILED TO OCCUR*INTERRUPT COMES BACK HERE WITH PREIRET AND K=1 WHEN J=1INT2:	BREAK;			*SHOULD NOT BE EXECUTED SINCE PREIRET				*WAS USED.INTY:	Y&larr;L7&larr;A1, SETF[K];	BREAK;			*INTERRUPT DIDN'T OCCUR%"INTROU" IS THE INTERRUPT ROUTINE FOR CHANNEL 17 (LOCATION 17 IS ITSINTERRUPT LOCATION) AND SHOULD ONLY BE ENTERED DURING THE INTERRUPT TEST."INTROU" BREAKS IF IENABLE=0, IF INT=0, OR IF THE INTERRUPT CHANNEL IS#17 IN ARM.  THEN IT GOES TO EITHER INTA, INTB, INTC, OR INTD DEPENDINGUPON THE BRANCH CONDITIONS H=1, J=1, K=1, OR NONE OF THESE.  THEINTERRUPT ROUTINE ALSO STORES THE COMPLEMENT OF L7 IN X, Y, AND P ANDPUTS THIS VALUE THROUGH THE ALU AND ONTO THE BUS BEFORE RETURNING SO THATTHE PRESERVATION OF REGISTERS AND BRANCH CONDITIONS ACROSS INTERRUPTSCAN BE VERIFIED.%INTROU:	SETSF[IENABLE&amp;G], Q&larr;ARM;	Q&larr;(NOT Q) U (377700 000000S), GOTO[.+2,G=1];	BREAK;			*INTERRUPT OCCURRED WHEN IENABLE=0	Q&larr;NOT Q, CALL[PQCOMP], P&larr;400000 000001S; *ARM REG. SET IMPROPERLY.  WRONG RESULT IN Q.	GOTO[INTA, H=1], CLEARF[H], Q&larr;L7;	GOTO[INTB,J=1], CLEARF[J];	GOTO[INTC,K=1], CLEARF[K];	SETSF[XCT0&amp;G];	GOTO[.+2,G=1];	BREAK;	*INTERRUPT OCCURRED AT UNANTICIPATED PLACE*XCT0 SIGNALS TEST OF STACK*STK 1 SHOULD BE EQUAL TO "STEMP" AND STK 0 TO "STEMP1". CHECK.	P&larr;STACK;	Q&larr;STEMP1, CALL[PQCOMP]; *INTERRUPT FROM WRONG ADDRESS	POP;	P&larr;STACK;	Q&larr;STEMP, CALL[PQCOMP]; *TOP OF STACK CLOBBERED BY ONSET OF INTERRUPT	P&larr;STEMP1;	B&larr;P+1, NPC&larr;B; *RETURN TO PLACE OF INTERRUPT +1 TO AVOID CONFUSION		*OF NO INTERRUPT OCCURRING AT ALL WITH SUCCESSFUL INTERRUPT	IRET, POP; *ABSENCE OF PREIRET SHOULD INSURE ONE NON-INT		*INSTRUCTION BEFORE ANOTHER INTERRUPT OCCURS.INTA:	CALL[XBCT]; *CALL DIAG TO CHECK PROCESSOR OPERATION DURING INTER.	IRET, GOTO[INT1], P&larr;P1, B&larr;NOT Q, POP;INTB:	CALL[XBCT]; *CALL DIAG	SETF[K];	PREIRET, POP;	IRET, P&larr;P1, B&larr;NOT Q, GOTO[INT2];INTC:	CALL[XBCT];	*CALL DIAG	POP;	IRET, P&larr;P1, RETURN; *TO INTX+1 OR INTY+1%INCLUDE THE DIAGNOSTICS OF X, Y, ALU HERE TO VERIFY THAT FUNCTIONS STILLWORK DURING INTERRUPTS.	THE ONLY FUNCTIONS WHICH DO NOT WORK DURINGINTERRUPTS ARE AS FOLLOWS:	FRZBALUBC;	B&gt;=0 AND B&lt;0 BRANCH CONDITIONS;	PQ RCY [44-Y];	P1&larr;P;%*X&gt;=0 AND X&lt;0 BC TESTSXBCT:	X&larr;NULL;	GOTO[.+2,X&gt;=0];	BREAK;			*X&gt;=0 FAILED ON 0 OR X[28] FAILED	CALL[CBRK,X&lt;0];	 *X&lt;0 FAILED ON 0 OR X[28] FAILED	X&larr;A1;	GOTO[.+2,X&lt;0];	BREAK;			*X&lt;0 FAILED ON 377 OR X[28] FAILED	CALL[CBRK,X&gt;=0];	*X&gt;=0 FAILED ON 377 OR X[28] FAILED	P&larr;NULL;	Q&larr;P+1, CALL[QLCY7];	X&larr;Q;	GOTO[.+2,X&lt;0];	BREAK;		*X&lt;0 BC FAILED ON 200	CALL[CBRK,X&gt;=0];	*X&gt;=0 FAILED ON 200*Y&gt;=0 AND Y&lt;0 BC TESTSYBCT:	Y&larr;NULL;	GOTO[.+2,Y&gt;=0];	BREAK;			*Y&gt;=0 FAILED ON 0 OR Y[27] FAILED	CALL[CBRK,Y&lt;0], X&larr;A1; *Y&lt;0 FAILED ON 0 OR Y[27] FAILED	Y&larr;A1;	GOTO[.+2,Y&lt;0];	BREAK;			*Y&lt;0 FAILED ON 777 OR Y[27] FAILED	CALL[CBRK,Y&gt;=0];	*Y&gt;=0 FAILED ON 777 OR Y[27] FAILED	Y&larr;X;	GOTO[.+2,Y&gt;=0];	BREAK;			*Y&gt;=0 FAILED ON 377 OR Y STORAGE FAILED	CALL[CBRK,Y&lt;0], INCY;	*Y&lt;0 FAILED ON 377	GOTO[.+2,Y&lt;0];	BREAK;			*Y&lt;0 FAILED ON 400 OR INCY FAILED OR				*X STORAGE FAILED OR Y STORAGE FAILED ON 377	CALL[CBRK,Y&gt;=0];	*Y&gt;=0 FAILED ON 400*TEST INCX AGAINST INCYIXIYT:	X&larr;NULL;	Y&larr;NULL;IXIYL:	P&larr;X;	Q&larr;Y, CALL[PQCOMP];	*X&larr;B, Y&larr;B, INCX, OR INCY FAILED	INCY, DGOTO[.+3];	INCX, GOTO[IXIYL,Y&gt;=0];	BREAK;			*GOTO[Y&gt;=0] OR DGOTO[ALWAYS] FAILED	P&larr;X, CALL[PZT];	 *INCY FAILED COUNTING 0 TO 400*TEST INCY AGAINST P+1	Y&larr;P&larr;NULL, GOTO[IYP2];IYP1:	P#Q;	GOTO[.+2,ALU=0], P&larr;B, B&larr;P+1, INCY;	BREAK;			*CARRY1=F2 OR ALUF=37 (P) OR P&larr;P1 FAILEDIYP2:	GOTO[IYP1,Y&gt;=0], Q&larr;Y;IYP3:	P#Q;	GOTO[.+2,ALU=0], INCY, P&larr;B, B&larr;P+1;	BREAK;			*CARRY1=F2 OR ALUF = 37 OR P&larr;P1 FAILED	GOTO[IYP3,Y&lt;0], Q&larr;Y;	AQ, CALL[AZT];		*INCY FAILED GOING 777 TO 0*ALU CHECKOUT OF ONE FUNCTIONANDT:	P&larr;Q&larr;NULL;	Q&larr;P AND Q, CALL[AZT];	*AND FAILED ON 0,0	Q&larr;A1;	Q&larr;P AND Q, CALL[AZT];	*AND FAILED ON P=0, Q=-1	P&larr;B, B&larr;A1;	Q&larr;NULL;	Q&larr;P AND Q, CALL[AZT];	*AND FAILED ON P=-1, Q=0	P&larr;Q&larr;B, B&larr;A1;	P&larr;B, B&larr;P AND Q;	Q&larr;P+1, CALL[AZT];	*AND FAILED ON -1,-1*TEST ALU BRANCH CONDITIONSALUBC:	A0;	CALL[CBRK,ALU#0], A0;	*ALU#0 FAILED ON FALSE	GOTO[.+2,ALU=0];	BREAK;			*ALU=0 FAILED ON TRUE	Q&larr;A1;	Q RSH 1;	B&larr;AQ, P&larr;B;	GOTO[.+2,ALU&gt;=0], AQ;	BREAK;			*ALU&gt;=0 BC FAILED ON TRUE	CALL[CBRK,ALU&lt;0];	*ALU&lt;0 BC FAILED ON FALSE	Q&larr;P+1;	GOTO[.+2,ALU&lt;0], AQ;	BREAK;			*ALU&lt;0 BC FAILED ON TRUE	CALL[CBRK,ALU&gt;=0];	*ALU&gt;=0 BC FAILED ON FALSE	P&larr;NULL;	Q&larr;P+1;ALUGLP:	GOTO[.+2,ALU&gt;0], AQ;	BREAK;			*ALU&gt;0 BC FAILED ON TRUE VALUE IN Q	CALL[CBRK,ALU&lt;=0], AQ;	*ALU&lt;=0 BC FAILED ON FALSE VALUE IN Q	GOTO[.+2,ALU#0], AQ;	BREAK;			*ALU#0 BC FAILED ON TRUE VALUE IN Q	CALL[CBRK,ALU=0];	*ALU=0 BC FAILED ON FALSE	Q LSH 1;	AQ;	GOTO[ALUGLP,ALU&gt;=0], AQ;	GOTO[.+2,ALU&lt;=0], AQ;	BREAK;			*ALU&lt;=0 BC FAILED ON 400000 000000	GOTO[.+2,ALU#0];	BREAK;			*ALU#0 BC FAILED ON TRUE VALUE IN Q	CALL[CBRK,ALU&gt;0], A0;	*ALU&gt;0 BC FAILED ON 400000 000000	GOTO[.+2,ALU&lt;=0], A0;	BREAK;			*ALU&lt;=0 BC FAILED ON 0	CALL[CBRK,ALU&gt;0];	*ALU&gt;0 BC FAILED ON 0ALU8T:	P&larr;A0;	GOTO[.+2,ALU8=0], A0;	BREAK;			*ALU8=0 FAILED ON 0	CALL[CBRK,ALU8=1],A1;	*ALU8=1 FAILED ON 0	GOTO[.+2,ALU8=1], A1;	BREAK;			*ALU8=1 FAILED ON -1	CALL[CBRK,ALU8=0];	*ALU8=0 FAILED ON -1	Q&larr;P+1, CALL[QLCY33];	AQ;	GOTO[.+2,ALU8=1], AQ;	BREAK;			*ALU8=1 FAILED ON 1000 000000	CALL[CBRK,ALU8=0], Q&larr;NOT Q; *ALU8=0 FAILED ON 1000 000000	GOTO[.+2,ALU8=0], AQ;	BREAK;			*ALU8=0 FAILED ON 776777 777777	CALL[CBRK,ALU8=1];	*ALU8=1 FAILED ON 776777 777777*NOW TEST LOADING Y FROM BUS.	(Y&larr;NULL WAS TESTED EARLIER)YBUST:	Y&larr;P&larr;NULL;	Q&larr;Y, CALL[PQCOMP];	*Y&larr;0 FAILED	P&larr;Y&larr;B, B&larr;P+1;	Q&larr;Y, CALL[PQCOMP];	*Y&larr;1 FAILED	REPEAT[10,ILC[(P&larr;Y&larr;B, B&larr;2P)] ILC[(Q&larr;Y, CALL[PQCOMP])]];	Q&larr;A1;	Q LSH 1, CALL[YBT1];	*Y&larr;776 FAILED	Q LSH 1;	Q LCY 1, CALL[YBT1];	*Y&larr;775 FAILED	Q LSH 1, CALL[QLCY2];	CALL[YBT1];	*Y&larr;773 FAILED	Q LSH 1, CALL[QLCY2];	Q LCY 1, CALL[YBT1];	*Y&larr;767 FAILED	Q LSH 1, CALL[QLCY3];	Q LCY 1, CALL[YBT1];	*Y&larr;757 FAILED	Q LSH 1, CALL[QLCY4];	Q LCY 1, CALL[YBT1];	*Y&larr;737 FAILED	Q LSH 1, CALL[QLCY5];	Q LCY 1, CALL[YBT1];	*Y&larr;677 FAILED	Q LSH 1, CALL[QLCY6];	Q LCY 1, CALL[YBT1];	*Y&larr;577 FAILED	Q LSH 1, CALL[QLCY7];	Q LCY 1, CALL[YBT1];	*Y&larr;377 FAILED	GOTO[XBUST];YBT1:	B&larr;Q, Y&larr;P&larr;B, Q&larr;A1, CALL[Q11];	Q&larr;P AND Q, P&larr;Y, CALL[PQCOMP];	* Y FAILED AT [STK 1]	Q&larr;A1, RETURN;XBT1:	B&larr;Q, X&larr;P&larr;B, Q&larr;A1, CALL[Q10];	Q&larr;P AND Q, P&larr;X, CALL[PQCOMP];	*X FAILED AT [STK 1]	Q&larr;A1, RETURN;*NOW TEST OUT LOADING X FROM BUS.	(X&larr;NULL TESTED EARLIER)XBUST:	X&larr;P&larr;NULL;	Q&larr;X, CALL[PQCOMP];	*X&larr;0 FAILED	P&larr;X&larr;B, B&larr;P+1;	Q&larr;X, CALL[PQCOMP];	*X&larr;1 FAILED	REPEAT[7,ILC[(P&larr;X&larr;B, B&larr;2P)] ILC[(Q&larr;X, CALL[PQCOMP])]];	Q&larr;A1;	Q LSH 1, CALL[XBT1];	*X&larr;376 FAILED	Q LSH 1;	Q LCY 1, CALL[XBT1];	*X&larr;375 FAILED	Q LSH 1, CALL[QLCY2];	CALL[XBT1];	*X&larr;373 FAILED	Q LSH 1, CALL[QLCY2];	Q LCY 1, CALL[XBT1];	*X&larr;367 FAILED	Q LSH 1, CALL[QLCY3];	Q LCY 1, CALL[XBT1];	*X&larr;357 FAILED	Q LSH 1, CALL[QLCY4];	Q LCY 1, CALL[XBT1];	*X&larr;337 FAILED	Q LSH 1, CALL[QLCY5];	Q LCY 1, CALL[XBT1];	*X&larr;277 FAILED	Q LSH 1, CALL[QLCY6];	Q LCY 1, CALL[XBT1];	*X&larr;177 FAILED*NOW TEST OUT DECYDECYT:	P&larr;Y&larr;NULL, CALL[Q11], Q&larr;A1;	DECY, P&larr;B, B&larr;Q;	Q&larr;Y, CALL[PQCOMP], DECY;	GOTO[.-1,Y&lt;0], P&larr;B, B&larr;P-1;	Q&larr;Y, CALL[PQCOMP], DECY;	GOTO[.-1,Y&gt;=0], P&larr;B, B&larr;P-1;	INCY;	Q&larr;Y, CALL[QZT];	 *DECY FAILED GOING 0 TO 777*TEST OF DECXDECXT:	P&larr;X&larr;NULL, Q&larr;A1, CALL[Q10];	DECX, P&larr;B, B&larr;Q;	Q&larr;X, DECX, CALL[PQCOMP];	*DECX FAILED	GOTO[.-1,X&lt;0], P&larr;B, B&larr;P-1;	Q&larr;X, DECX, CALL[PQCOMP];	GOTO[.-1,X&gt;=0], P&larr;B, B&larr;P-1;	INCX;	Q&larr;X, CALL[QZT];	 *DECX FAILED GOING 0 TO 377*XTOP BUS SOURCE PUTS X[30,35] ONTO B[0,5]XTOPT:	Q&larr;A1, CALL[Q6];	*Q&larr;77	X&larr;Q, CALL[QLCY36];	P&larr;XTOP, CALL[PQCOMP];	*XTOP FAILED ON 77 IN X.	WRONG VALUE IN P	INCX;	Q&larr;XTOP, CALL[QZT];	*XTOP FAILED ON 100 IN X.	WRONG VALUE IN Q*YSHIFT&larr; LOADS Y[27] FROM B[18] AND Y[28,35] FROM B[28,35]YSHIFTT:	P&larr;NULL;	Q&larr;P+1, CALL[QLCY21];	YSHIFT&larr;Q, CALL[Q33];	P&larr;Y, CALL[PQCOMP];	*P SHOULD HAVE 400 IN IT.	YSHIFT&larr; FAILED	P&larr;NULL;	Q&larr;P+1, CALL[QLCY21];	YSHIFT&larr;Q&larr;NOT Q, CALL[Q10];	P&larr;Y, CALL[PQCOMP];	*P SHOULD HAVE 377 IN IT.	YSHIFT&larr; FAILED*YKPTR&larr; IS SUPPOSED TO LOAD Y FROM 400 + B[41,43]*20TYKPTR:	P&larr;NULL;	B&larr;Q&larr;P+1, P&larr;B;	B&larr;2P+1, P&larr;B, Q LCY 1, DGOTO[YKP1];	B&larr;2P+1, P&larr;B, Q LCY 1, CALL[QLCY2];*P&larr;7, Q&larr;20 NOWYKPLP:	CALL[PQCOMP], R7&larr;P-1, P&larr;Y, Q LCY 1;	P&larr;R7, Q&larr;STEMP;YKP1:	YKPTR&larr;P;	DGOTO[YKPLP,ALU&gt;=0], Q&larr;P+Q, STEMP&larr;Q;	Q LCY 1, P&larr;B, B&larr;P, CALL[QLCY2];*TEST ADDRESSING FROM X AND DATA STORAGE OF BOTH LB AND RBLRXT:	Y&larr;Q&larr;17S, P&larr;A0; *Y HOLDS 17 DURING THE LM AND RM TESTS	Q&larr;P+1;*FIRST TEST THE REGISTERS ON THE 44 PATTERNS WHICH CONTAIN A SINGLE 1*WITH 43 ZEROES.	THE PATTERN IS LCY'ED 1 IN PASSING FROM REGISTER TO*REGISTER.	X&larr;Y, CALL[LRBT1];	*RETURN FROM LRBT1 WITH ORIGINAL Q RCY 1	GOTO[.-1,Q EVEN];*NOW TEST 44 PATTERNS OF A SINGLE 0 WITH 43 1'S	Q&larr;NOT Q;	X&larr;Y, CALL[LRBT1];	*RETURN FROM LRBT1 WITH ORIGINAL Q RCY 1	GOTO[.-1,Q ODD];*[X]&gt;17 IS REALLY A DON'T CARE FOR LINDX	GOTO[SMTEST];*FILL THE LOWER 20 REGISTERS OF RM, ADDRESSING FROM XLRBT1:	RX&larr;Q, Q LCY 1, DECX, P&larr;17S;	GOTO[LRBT1,X&gt;=0];*FILL THE LOWER 20 REGISTERS OF LM, ADDRESSING FROM X	X&larr;Y;LRBT2:	LX&larr;Q, Q LCY 1, DECX, P&larr;17S;	GOTO[LRBT2,X&gt;=0];*AT THIS POINT THE ORIGINAL VALUE IN Q HAS BEEN LCY'ED AFTER EACH OF 40*LOADS SO IT CAN BE RESTORED TO THE ORIGINAL VALUE BY LCYING 4 MORE TIMES.*NOW READ AND CHECK RM	Q LCY 1, CALL[QLCY3], X&larr;Y;LRBTA:	P&larr;RX, DECX, CALL[PQCOMP]; *RB[X-1] FAILED ON [Q]	GOTO[LRBTA,X&gt;=0], Q LCY 1;*NOW READ AND CHECK LM	X&larr;Y;LRBTB:	P&larr;LX, DECX, CALL[PQCOMP]; *LB[X-1] FAILED ON [Q]	Q LCY 1, GOTO[LRBTB,X&gt;=0];	Q LCY 1, GOTO[QLCY2]; *RETURN TO CALLER OF LRBT1 WITH ORIGINAL Q RCY 1*TEST OF SM*SUBROUTINE "SMTC" INITIALIZES ALL SM AND DM REGISTERS TO VALUES BEGINNING*WITH [R7] AND [Q] AND THEN CYCLED BY 1 FOR EACH SUCCESSIVE WORD.  AFTER*INITIALIZING ALL 2000-100 REGISTERS IT READS THEM BACK AND CHECKS FOR ERRORS.*DM[I] IS ALWAYS SET TO NOT[SM[I]].SMTC:	SY&larr;Q, Q&larr;NOT Q;	D&larr;Q, Q&larr;NOT Q, INCY;	Q LCY 1, GOTO[.-2,Y&gt;=0];	SY&larr;Q, Q&larr;NOT Q;	D&larr;Q, Q&larr;NOT Q, INCY;	Q LCY 1, GOTO[.-2,Y&lt;0];	Y&larr;220S;SMTC0:	Q&larr;R7, P&larr;SY, CALL[PQCOMP]; *SY&larr;B OR B&larr;SY FAILEDSMTC1:	Q&larr;NOT Q, P&larr;D, CALL[PQCOMP], INCY; *D&larr;B OR B&larr;D FAILED	Q&larr;NOT Q, DGOTO[.-1,Y&gt;=0];SMTC2:	Q LCY 1, P&larr;SY, CALL[PQCOMP]; *SY&larr;B OR B&larr;SY FAILEDSMTC3:	Q&larr;NOT Q, P&larr;D, CALL[PQCOMP], INCY; *D&larr;B OR B&larr;D FAILED	Q&larr;NOT Q, DGOTO[.-1,Y&lt;0];SMTC4:	Q LCY 1, P&larr;SY, CALL[PQCOMP,Y&lt;0]; *SY&larr;B OR B&larr;SY FAILED	Q&larr;R7, RETURN;*TEST OF SM AND DM ADDRESSED FROM YSMTEST:	Y&larr;P&larr;220S, DGOTO[SMT0];	R7&larr;Q&larr;P+1, CALL[SMTC];	GOTO[SMT1,ALU&lt;=0], R7&larr;Q, Y&larr;220S;	CALL[SMTC];SMT0:	GOTO[.-2], Q RCY 1, AQ;SMT1:	P&larr;B, B&larr;A1;	R7&larr;Q&larr;2P, CALL[SMTC];	AQ, Q LCY 1;	DGOTO[.-1,ALU&lt;0];	CALL[SMTC], R7&larr;Q, Y&larr;220S;	GOTO[MPTEST];*SUBROUTINES TO FILL 2000 MAP ENTRIES WITH Q, Q LCY 1, Q LCY 2, ETC.*AND THEN READ BACK AND CHECK THE RESULTS.  ORIGINAL Q IS*RETURNED IN Q. [Y]=0, CUM=0, [P]=777777 AT CALL.MC[UM&amp;CUM,UM,CUM];MPTCX:	Q&larr;P AND Q, P&larr;B, B&larr;Q;	MAP&larr;Q, Q&larr;P, INCY;	Q LCY 1, GOTO[.-2,Y&gt;=0], P&larr;777777S;	Q&larr;P AND Q, P&larr;B, B&larr;Q;	MAP&larr;Q, Q&larr;P, INCY, DGOTO[.-1];	Q LCY 1, P&larr;777777S, RETURN[Y&gt;=0];MPTCY:	R11&larr;L7&larr;P AND Q, Q LCY 1;	P&larr;MAP, INCY, R10&larr;Q, Q&larr;L7, CALL[PQCOMP]; *[MAP] AT Y-1 WRONG	Q&larr;R10, P&larr;777777S, GOTO[.-2,Y&gt;=0];	R11&larr;L7&larr;P AND Q, Q LCY 1, P&larr;MAP, INCY;	R10&larr;Q, Q&larr;L7, CALL[PQCOMP];	*[MAP] AT Y-1 WRONG	Q&larr;R10, P&larr;777777S, GOTO[.-2,Y&lt;0];	RETURN;*HERE WITH [Y]=0, 777777 IN P, AND NUMBER BASE IN R7MPTC:	CLEARF[CUM], CALL[MPTCX];	*MON. MAP WRITES	SETF[CUM], CALL[MPTCX];	*USER MAP WRITES	CLEARF[CUM], Q&larr;R7, CALL[MPTCY]; *MON. MAP READS	SETF[CUM], GOTO[MPTCY];	*USER MAP READSMPTEST:	Y&larr;P&larr;NULL, CLEARF[UM&amp;CUM];	Q&larr;P+1, CALL[QLCY10];	CUM&larr;Q, Q&larr;A1, CALL[Q22];*TEST 18 PATTERNS OF A SINGLE 1 WITH 17 ZEROES AND 18 PATTERNS OF ALL ZEROES	777777S&larr;Q, DGOTO[MPT0];	R7&larr;Q&larr;P+1, CALL[MPTC], P&larr;777777S;MPT2:	GOTO[MPT1,ALU&lt;=0], R7&larr;Q, Y&larr;NULL;	CALL[MPTC], P&larr;777777S;MPT0:	Q LCY 1, AQ, GOTO[MPT2];*TEST 18 PATTERNS OF A SINGLE 0 WITH 17 1'S AND 18 PATTERNS OF 777777MPT1:	P&larr;B, B&larr;A1, DGOTO[MPT3];	R7&larr;Q&larr;2P, CALL[MPTC], P&larr;777777S;MPT4:	GOTO[M4TEST,ALU&gt;=0], R7&larr;Q, Y&larr;NULL;	CALL[MPTC], P&larr;777777S;MPT3:	Q LCY 1, AQ, GOTO[MPT4];*M4CHK CALLED WITH Y, CUM, AND Q LOADED WITH SOME VALUES.  IT PERFORMS*MAP4&larr; AND CHECKS IT.  LH[Q] MUST BE 0M4CHK:	P&larr;Y;	MAP4&larr;Q, R7&larr;Q;	REPEAT[4,ILC[(DECY)]];	Q&larr;Y, CALL[PQCOMP];	*MAP4&larr; FAILED TO INCREMENT Y BY 4				*CORRECT VALUE IN P, WRONG VALUE IN Q	P&larr;MAP, INCY, Q&larr;R7, CALL[PQCOMP]; *MAP4&larr; FAILED ON 0TH WORD	P&larr;MAP, INCY, Q&larr;R7, CALL[PQCOMP]; *MAP4&larr; FAILED ON 1ST WORD	P&larr;MAP, INCY, Q&larr;R7, CALL[PQCOMP]; *MAP4&larr; FAILED ON 2ND WORD	P&larr;MAP, INCY, Q&larr;R7, GOTO[PQCOMP]; *MAP4&larr; FAILED ON 3RD WORD*RETURN WITH Y INCREMENTED BY 4, Q UNCHANGEDM4TX:	Q&larr;Y&larr;NULL, CALL[M4CHK];	Q&larr;NULL, CALL[M4CHK];	GOTO[.-1, Y&gt;=0];	Q&larr;NULL, CALL[M4CHK];	GOTO[.-1,Y&lt;0], Q&larr;777777S;	Y&larr;NULL, CALL[M4CHK];	Q&larr;777777S, CALL[M4CHK];	GOTO[.-1,Y&gt;=0];	Q&larr;777777S, CALL[M4CHK];	GOTO[.-1,Y&lt;0];	RETURN;M4TEST:	CLEARF[CUM], CALL[M4TX];	SETF[CUM], CALL[M4TX];***PQ RCY [Y] NOT TESTED	RETURN; *RETURN FROM DIAG TO MAKE INTERRUPT RETURNDGIEND:	INHINT, P&larr;COUNT;	Q&larr;P+1, INHINT;	COUNT&larr;Q, INHINT, GOTO[MCYCLE];IM[ILC,ADD[IP[ILC],-1]];</pre>
  </body>
</html>
