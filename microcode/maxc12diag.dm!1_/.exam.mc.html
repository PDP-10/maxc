<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12diag.dm!1>exam.mc</title>
  </head>
  <body>
    <pre>
ER[EXAM];%	D I S K   D I A G N O S T I CTO ASSEMBLE:	@MI@ EXAM.MCLOAD:		EXAM%***	OUTGOING COMMAND BITS FROM MAXC TO DISK AND CONTROLLER*	INSERT[DBEG.MC];	LVN[L20];	TARGET[ILC];	MP[UDSEL,13];	* DESELECT THE UNIT	MP[RSC,7];	* RESET SECTOR CONDITION	MP[RPDL,10];	* RESET PROCESSOR DATA LATE	MP[RCDL,11];	* RESET CONTROLLER DATA LATE	MP[RSO,12];	* RESET SECTOR OVERFLOW	MP[I1EN,0];	* ENABLE SECTOR INTERRUPTS	MP[I2EN,4];	* ENABLE TYPE 1 WORD INTERRUPTS	MP[I3EN,5];	* ENABLE TYPE 2 WORD INTERRUPTS	MP[I4EN,6];	* ENABLE TYPE 3 WORD INTERRUPTS	MP[LCR,1];	* LOAD CYLINDER ADDRESS REGISTER	MP[LHR,2];	* LOAD HEAD ADDRESS REGISTER	MP[COM,3];	* INTERPRET THIS AS A COMMAND	MP[WRGAT,20];	* TURN ON WRITING	MP[RDGAT,21];	* TURN ON READING	MP[ERGAT,24];	* TURN ON ERASING	MP[SEEK,22];	* INITIATE SEEK TO C.A.R.	MP[RHR,23];	* RESET HEAD ADDRESS REGISTER TO 0	MP[HDS,25];	* ACTIVATE R/W HEAD IN H.A.R.	MP[RESTOR,26];	* SEEK TO CYLINDER 0	SP[RESET,RSC,RPDL,RCDL,RSO];  * RESETS CONTROLLER ERRORS	PM[ALL1CYL,777 0000];	F[HDADR,23,27];	* HEAD ADDRESS FIELD	F[CYLADR,17,27];* CYLINDER ADDRESS FIELD**	INCOMING STATUS FROM DISK AND CONTROLLER*	MP[IC,0];	* INDEX CONDITION	MP[UUNS,1];	* UNIT UNSAFE	MP[UOFF,2];	* UNIT OFF LINE	MP[UNR,3];	* UNIT NOT READY (NORMALLY = SEEKING)	MP[SKFAIL,4];	* SEEK HAS FAILED	MP[URDONLY,5];	* UNIT CANNOT BE WRITTEN ON	MP[CNR,6];	* CONTROLLER IS NOT READY	MP[SC,7];	* SECTOR CONDITION	MP[PDL,10];	* PROCESSOR DATA LATE CONDITION	MP[CDL,11];	* CONTROLLER DATA LATE CONDITION	MP[SO,12];	* SECTOR OVERFLOW CONDITION**	SELECT THE PROPER DISK UNIT*	MC[UNIT];	MC[DISCONN,UDSEL,RESET];	MC[RESTORC,I1EN,RESET,COM,RESTOR];	MC[IDLE,I1EN,RESET];	MC[CURSEC];	MC[ISTAT];SELUNIT:Q&larr;7S;SU1:	KUNIT&larr;Q;	P&larr;AQ;	KSET&larr;DISCONN,KNEWCOMM;	P&larr;P-1;	Q&larr;P,GOTO[SU1,ALU&gt;=0];	Q&larr;3S;	CURSEC&larr;Q;	KUNIT&larr;UNIT;	P&larr;P;	KSET&larr;IDLE,KNEWCOMM;	CALL[WAITRDY];	KSET&larr;RESTORC,KNEWCOMM;	CALL[WAITRDY];	KSET&larr;IDLE,KNEWCOMM;	ARM&larr;2160S;	RETURN;**	WAIT UNTIL DISK UNIT AND CONTROLLER BOTH READY*	MC[ALLRDY,UOFF,SKFAIL,UNR,CNR];WAITRDY:Q&larr;ALLRDY;	P&larr;KSTAT;	P&larr;P AND Q; GOTO[.-2,ALU#0];	RETURN;**	INTERRUPT HANDLERS FOR SECTOR AND WORD INTERRUPTS*	IM[SILOC,5];	SILOC[(YKPTR&larr;KUNIT,CALL[SIHAND])];	IM[WILOC,11];	REPEAT[3,WILOC[(YKPTR&larr;KUNIT,CALL[WIHAND])]];	MC[SECRDY];	MC[WDRDY];	MC[RSCC,RSC,I1EN];	MC[KDO];	MC[KDOL];	MC[KDI];	MC[KDIL];	MC[SIUNIT];	MC[WIUNIT];	MC[QAFT];	MC[WDWRTN];	MC[WDWRTNL];	MC[I2ENWD,I1EN,I2EN];	MC[OOPSMSK,BADUNIT,PDL,CDL,SO];SIHAND:	QAFT&larr;Q;	P&larr;UNIT;	Q&larr;KUNIT;	P-Q, KCSET&larr;RSCC;	Q&larr;1S, GOTO[SIEX,ALU#0];	SECRDY&larr;Q;	Q&larr;OOPSMSK;	P&larr;KSTAT;	P&larr;P AND Q;	CALL[ANALYZE,ALU#0];	SIUNIT&larr;Y;	P&larr;CURSEC;	Q&larr;P+1, P&larr;3S;	P-Q, P&larr;KSTAT;	CURSEC&larr;Q, PQ RCY [43], GOTO[ZEROSEC,ALU=0];	Q&larr;P;	GOTO[SIEX,QEVEN];	Q&larr;2S;	CURSEC&larr;Q,GOTO[SIEX];ZEROSEC:CURSEC&larr;NULL;SIEX:	Q&larr;QAFT, RETURN, P&larr;P1, IRET;WIHAND:	P&larr;AQ, Q&larr;WDRDY;	Q&larr;1S, P&larr;P, GOTO[.+2,QEVEN];DATLAT:	BRKP[1];	WDRDY&larr;Q;	WIUNIT&larr;Y;	KMDR&larr;KDO;	KMDRL&larr;KDOL;	Q&larr;KWDATA;	Q&larr;KRDATA;	KDI&larr;Q;	KDIL&larr;KMDRL, Q&larr;P;	KCSET&larr;I2ENWD;	RETURN, P&larr;P1, IRET;**	WAIT FOR THE BEGINNING OF THE SELECTED SECTOR*	MC[SECTOR];WAITSEC:SECRDY&larr;NULL;	KUNIT&larr;7S;WIX1:	P&larr;SECRDY;	P;	GOTO[WIX1,ALU=0];	SECRDY&larr;NULL;	Q&larr;CURSEC;	P&larr;SECTOR;	P-Q;	GOTO[WIX1,ALU#0];	KUNIT&larr;UNIT,RETURN;**	WAIT UNTIL READY FOR NEXT WORD. INTERRUPT 4 REQUEST MUST NOT*	BE BACK-PANEL JUMPERED.*	SP[BADUNIT,UUNS,UOFF,UNR,SKFAIL,URDONLY];	MC[WDW];	MC[WDSCOPE];WAITWD:	P&larr;WDRDY;	P;	GOTO[WW0,ALU=0];DATLAT1:BRKP[1],GOTO[WW0];WW0:	Q&larr;OOPSMSK,INHINT;	P&larr;KSTAT,INHINT;	P AND Q;	CALL[ANALYZE,ALU#0];	P&larr;WDRDY;	P;	P&larr;NULL, GOTO[WW0,ALU=0];	WDRDY&larr;NULL,RETURN;**	ANALYZE WHY WAITWD FAILED*	SV[CONDMSK,7777 7777 7777];ANALYZE:Q&larr;P AND Q, P&larr;CONDMSK;	P AND Q;	GOTO[.+2,ALU=0];STOP1:	BRKP[1], GOTO[PURIFY];	AQ, RETURN;  * SET THE ALU OUTPUT NONZERO, REQUESTING RECOVERY*PURIFY:	IRET;	P&larr;P;	KUNIT&larr;UNIT;	P&larr;P;	KSET&larr;IDLE, KNEWCOMM;	Q&larr;3S;	CURSEC&larr;Q, GOTO[XFLP];**	SEEK TO CYLINDER SPECIFIED IN CURCYL[17-27].*	MC[CURCYL,UZERO];	MC[CYLCOM,UZERO];	MC[SCRCOM,LCR,RESET,I1EN];	MC[SEECOM,COM,RESET,SEEK,I1EN];SEEKSUB:CALL[WAITRDY];	Q&larr;CURCYL;	P&larr;SCRCOM;	Q&larr; P OR Q;	CYLCOM&larr;Q;	KSET&larr;CYLCOM,KNEWCOMM;	CALL[WAITRDY];	KSET&larr;SEECOM,KNEWCOMM;	CALL[WAITRDY];	RETURN;**	SET HEAD REGISTER*	MC[RESETHD,RESET,COM,RHR,I1EN];	MC[SETHD,LHR,I1EN];	MC[SHCOM];	MC[HEAD];SETHDSUB:KSET&larr;RESETHD,KNEWCOMM,CALL[WAITRDY];	P&larr;HEAD;	Q&larr;SETHD;	Q&larr;P OR Q;	SHCOM&larr;Q;	KSET&larr;SHCOM,KNEWCOMM,CALL[WAITRDY];	RETURN;**	ROUTINE TO SET UP PARAMETERS FOR BLOCKS OF WORDS TO BE*	TRANSFERRED. DRIVEN BY A TABLE WITH THREE WORDS PER ENTRY.*	FIRST, A CODE FOR THE ROUTINE TO BE USED. SECOND, A STARTING*	ADDRESS IN A MEMORY. THIRD, THE LENGTH OF THE BLOCK.*	MC[ROUTINE];	MC[WDSTOXF];	MC[MEMAD];	MC[WDTPTR];	SV[WCONS,1234567];	MC[RCONS];	MC[CKSUM2];*	MC[DHDWD];	MC[DUNBLK];	MC[DUB1];	MC[DUB2];	MC[DUB3];	MC[PREDAT];	MC[PD1];*	SV[WDTB1,0];	SV[WDTB1A,IP[DHDWD]];	SV[WDTB1B,1];	SV[WDTB2,1];	SV[WDTB2A,0];		SV[WDTB2B,1];	SV[WDTB3,0];	SV[WDTB3A,IP[DUNBLK]];	SV[WDTB3B,4];	SV[WDTB4,1];	SV[WDTB4A,0];		SV[WDTB4B,1];	SV[WDTB5,0];	SV[WDTB5A,IP[PREDAT]];	SV[WDTB5B,2];	SV[WDTB6,2];	SV[MMAD,0];		SV[WDTB6B,1000];	SV[WDTB7,1];	SV[WDTB7A,0];		SV[WDTB7B,1];*	SV[@WDTAB,IP[WDTB1]];TESTAD:	P&larr;WDW;	Q&larr;P+1,P&larr;WDSTOXF;	WDW&larr;Q;TAD0:	Q&larr;P-1;	WDSTOXF&larr;Q,RETURN[ALU&gt;=0];	Y&larr;WDTPTR;	Q&larr;SY,INCY;	ROUTINE&larr;Q;	Q&larr;SY,INCY;	MEMAD&larr;Q;	P&larr;SY,INCY;	WDTPTR&larr;Y,GOTO[TAD0];**	GET A WORD FOR THE DISK.*	MC[CKSUM];FETIT:	CALL[TESTAD];	P&larr;ROUTINE;	P&larr;P;	P&larr;P-1,GOTO[SMF,ALU&lt;=0];	P&larr;P-1,GOTO[CKSUMF,ALU&lt;=0];	P&larr;P-1,GOTO[MMF,ALU&lt;=0];	P&larr;P-1,GOTO[CONSF,ALU&lt;=0];ADF:	P&larr;Q&larr;MEMAD;	Q&larr;P+1,KDO&larr;Q;	MEMAD&larr;Q;	P&larr;KDO;	Q&larr;17S;	Q&larr;P AND Q;	KDOL&larr;Q,GOTO[MMF1];CONSF:	Q&larr;WCONS;	KDO&larr;Q;	KDOL&larr;NULL,GOTO[MMF1];MMF:	P&larr;KREAD&larr;MEMAD,CALL[ONEINST];	KDO&larr;KMDR;	Q&larr;P+1,KDOL&larr;KMDRL;	MEMAD&larr;Q;MMF1:	P&larr;Q&larr;CKSUM;	P&larr;PQ RCY [1],Q&larr;KDO;	P&larr;P+Q,Q&larr;KDOL;	Q&larr;P+Q;	CKSUM&larr;Q,RETURN;SMF:	Y&larr;MEMAD;	Q&larr;SY,INCY;	KDO&larr;Q;	P&larr;DHDWD;	P-Q;	GOTO[.+2,ALU=0];NOTHD:	P&larr;NULL;	KDOL&larr;NULL;	MEMAD&larr;Y,GOTO[MMF1];CKSUMF:	Q&larr;CKSUM;	KDO&larr;Q;	CKSUM2&larr;Q;	Q&larr;1S;	KDOL&larr;Q;CKSMOK:	CKSUM&larr;NULL;TWOINST:P&larr;P;ONEINST:RETURN;**	DISPOSE OF A WORD FROM THE DISK.*STORIT:	CALL[TESTAD];	P&larr;ROUTINE;	P&larr;P;	P&larr;P-1,GOTO[SMS,ALU&lt;=0];	P&larr;P-1,GOTO[CKSUMS,ALU&lt;=0];	P&larr;P-1,GOTO[MMS,ALU&lt;=0];	P&larr;P-1,GOTO[CONSS,ALU&lt;=0];ADS:	P&larr;Q&larr;MEMAD;	P&larr;P+1;	Q&larr;P,P&larr;MEMAD;	MEMAD&larr;Q;	Q&larr;KDI;	P#Q;	GOTO[DATERR,ALU#0];	Q&larr;KDIL;	Q&larr;P#Q,P&larr;17S;	P AND Q;	GOTO[MMS1,ALU=0];	GOTO[DATERR];CONSS:	Q&larr;KDI;	P&larr;WCONS;	P#Q;	RCONS&larr;Q,GOTO[MMS1,ALU=0];DATERR:	BRKP[1],GOTO[MMS1];MMS:	KMDR&larr;KDI;	KMDRL&larr;KDIL;	P&larr;KWRITE&larr;MEMAD;	Q&larr;P+1;	MEMAD&larr;Q;MMS1:	P&larr;Q&larr;CKSUM;	P&larr;PQ RCY [1],Q&larr;KDI;	P&larr;P+Q,Q&larr;KDIL;	Q&larr;P+Q;	CKSUM&larr;Q,RETURN;SMS:	Y&larr;MEMAD;	Q&larr;KDI;	SY&larr;Q,INCY;	MEMAD&larr;Y,GOTO[MMS1];CKSUMS:	P&larr;KDI;	Q&larr;CKSUM;	P-Q;	GOTO[CKSMOK,ALU=0];CKSMERR:P&larr;KSTAT;	BRKP[1],GOTO[CKSMOK];**	AFTER PAUSING FOR PAUS WORDS, READ A RECORD OF LREC WORDS, LEAVING*	ITS LAST WORD IN KDI AND KDIL.*	MC[LREC];	MC[PAUS];	MC[WDSPAUSD];	MC[WDSREAD];	MC[HDSEL,COM,HDS,I1EN];	MC[HDSELWI,COM,HDS,I1EN,I4EN];	MC[READC,COM,RDGAT,HDS,I4EN,I1EN];READREC:WDSPAUSD&larr;NULL;	WDRDY&larr;NULL;	KSET&larr;HDSELWI;	CALL[WW0];RR1:	P&larr;WDSPAUSD;	Q&larr;PAUS;	P-Q;	Q&larr;P+1,GOTO[RR2,ALU&gt;=0];	WDSPAUSD&larr;Q,CALL[WAITWD];	GOTO[RR1];RR2:	WDSREAD&larr;NULL;	KSET&larr;READC;		* GIVE READ COMMAND	P&larr;NULL;		* LET ANY PENDING INTERRUPT HAPPEN	P&larr;NULL;	P&larr;NULL;	P&larr;NULL;	WDRDY&larr;NULL,CALL[WAITWD];	* CLEAR WORD READY FLAG AND WAITRDLP:	P&larr;WDSREAD;	Q&larr;LREC;	P-Q;	Q&larr;P+1,GOTO[TURNOFF,ALU&gt;=0];	WDSREAD&larr;Q,CALL[WAITWD];	CALL[STORIT];	GOTO[RDLP];**	WRITE A RECORD OF PAUS ZERO WORDS, ONE SYNC WORD, LREC DATA WORDS,*	AND BETWEEN ONE AND TWO GARBAGE WORDS.*	MC[WDSWRT];	SV[SYNC,17];	MC[WRITC,COM,WRGAT,ERGAT,HDS,I4EN,I1EN];	MC[ERASC,COM,ERGAT,HDS,I4EN,I1EN];WRTREC:	WDSPAUSD&larr;NULL;	KDO&larr;NULL;	KDOL&larr;NULL;	WDRDY&larr;NULL;	KSET&larr;WRITC;	CALL[WW0];WR1:	P&larr;WDSPAUSD;	Q&larr;PAUS;	P-Q;	Q&larr;P+1,GOTO[WR2,ALU&gt;=0];	WDSPAUSD&larr;Q,CALL[WAITWD];	GOTO[WR1];WR2:	WDSWRT&larr;NULL;	Q&larr;SYNC;	KDO&larr;Q;	KDOL&larr;Q,CALL[WAITWD];WRTLP:	P&larr;WDSWRT;	Q&larr;LREC;	P-Q;	Q&larr;P+1,GOTO[WR3,ALU&gt;=0];	WDSWRT&larr;Q;	CALL[FETIT];	CALL[WAITWD];	GOTO[WRTLP];WR3:	KDO&larr;NULL;	KDOL&larr;NULL,CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];	KSET&larr;ERASC,CALL[WAITWD];	CALL[WAITWD];	CALL[WAITWD];TURNOFF:KSET&larr;HDSEL;	RETURN;**	ISSUE COMMANDS CONTINUOUSLY TO THE DISK*COMCONT:CALL[SETUP],INHINT;CC1:	KSET&larr;HDSEL;	GOTO[CC1];**	SET UP THE PROCESSOR TO TAKE INTERRUPTS ON DISK CHANNELS 1 AND 4,*	PROCESSOR CHANNELS ???. THEN SELECT THE UNIT.*SETUP:	ARM&larr;0S,INHINT;	SETF[100S],INHINT;	IRET,INHINT;	P&larr;NULL,INHINT;	CALL[SELUNIT];	RETURN;**	UNPACK THE HEAD, CYLINDER, AND SECTOR FROM THE DSKADR WORD.*	MC[DSKADR];UNPK:	CALL[CKDSKAD];	Q&larr;DSKADR;	P&larr;77 0000S;	Q&larr;P AND Q;	HEAD&larr;Q;	Q&larr;DSKADR;	P&larr;7770S;	P&larr;Q&larr;P AND Q;	P&larr;PQ RCY [33];	Q&larr;P;	CURCYL&larr;Q;	Q&larr;DSKADR;	P&larr;7S;	Q&larr;P AND Q;	SECTOR&larr;Q;	RETURN;**	READ THROUGH A SECTOR UNTIL REACHING WORD WDNO. THE RECORD FORMAT*	OF THE SECTOR IS DETERMINED BY A TABLE FMTAB WITH TWO WORDS PER RECORD.*	THE FIRST WORD GIVES THE NUMBER OF WORDS TO PAUSE BEFORE TRYING TO*	READ THE RECORD. THE SECOND WORD GIVES THE LENGTH OF THE RECORD.*	SV[WDNO,0];	SV[FULLSEC,1012];	MC[WDSDONE];	SV[FMTAB1,5];	SV[FMTAB1A,2];	SV[FMTAB2,3];	SV[FMTAB2A,5];	SV[FMTAB3,3];	SV[FMTAB3A,1003];	SV[FMTAB4,0];	*FOR FUTURE EXPANSION	SV[FMTAB4A,0];	SV[@FMTAB,IP[FMTAB1]];	MC[HDSEL1,RESET,COM,HDS,I1EN];	MC[FMTPTR];	SV[PAUSDELT,3];	SV[NREADRECS,3];	MC[NRRNOW];	MC[LSTAT];XFSEC:	CALL[UNPK];	CALL[SEEKSUB];	CALL[SETHDSUB];	CALL[WAITSEC];XF0:	KSET&larr;HDSEL1,KNEWCOMM;	WDSDONE&larr;NULL;	Q&larr;@FMTAB;	FMTPTR&larr;Q;	WDSTOXF&larr;NULL;	Q&larr;@WDTAB;	WDTPTR&larr;Q;	CKSUM&larr;NULL;	NRRNOW&larr;NULL;	WDW&larr;NULL;XF1:	Y&larr;FMTPTR;	Q&larr;SY,INCY;	PAUS&larr;Q;	P&larr;WDNO;	Q&larr;WDSDONE;	P&larr;P-Q;	GOTO[QUIT,ALU&lt;=0];	Q&larr;SY,INCY;	P-Q;	GOTO[.+2,ALU&gt;=0];	Q&larr;P;	LREC&larr;Q;	P&larr;WDSDONE;	Q&larr;P+Q;	WDSDONE&larr;Q;	FMTPTR&larr;Y;	P&larr;NRRNOW;	Q&larr;P+1,P&larr;NREADRECS;	P-Q,NRRNOW&larr;Q;	GOTO[RDIT,ALU&gt;=0];	Q&larr;PAUS;	P&larr;PAUSDELT;	Q&larr;P+Q;	PAUS&larr;Q,CALL[WRTREC];	GOTO[XF1];RDIT:	CALL[READREC];	GOTO[XF1];QUIT:	KSET&larr;IDLE,KNEWCOMM;	RETURN;**	INCREMENT DISK ADDRESS AND CHECK FOR VALIDITY.*	SV[DAD1,1];	SV[DAD1A,7];	SV[DAD1B,2];	SV[DAD1C,7777 7777 7770];	SV[DAD2,1 0000];	SV[DAD2A,77 0000];	SV[DAD2B,23 0000];	SV[DAD2C,7777 7700 7777];	SV[DAD3,10];	SV[DAD3A,7770]	SV[DAD3B,6250];	SV[DAD3C,7777 7777 0007];	SV[@DAD,IP[DAD1]];	MC[CARRY];NXTDSKAD:Y&larr;@DAD;	X&larr;2S;	Q&larr;1S;	CARRY&larr;Q;NADLP:	P&larr;SY,INCY;	Q&larr;CARRY;	AQ;	Q&larr;DSKADR,GOTO[.+2,ALU&lt;=0];	Q&larr;P+Q;	DSKADR&larr;Q;	P&larr;SY,INCY;	Q&larr;P AND Q;	P&larr;SY,INCY;	P-Q;	DECX,GOTO[INBNDS,ALU&gt;=0];	Q&larr;CARRY;	AQ;	GOTO[BADADR,ALU&lt;=0];	P&larr;DSKADR;	Q&larr;SY,INCY;	Q&larr;P AND Q;	DSKADR&larr;Q,GOTO[NADLP,X&gt;=0];INBNDS:	CARRY&larr;NULL,INCY,GOTO[NADLP,X&gt;=0];	RETURN;BADADR:	GOTO[.],BRKP[1];*CKDSKAD:Y&larr;@DAD;	X&larr;2S;	CARRY&larr;NULL;	GOTO[NADLP];**	STORE THE RANDOM NUMBER GENERATOR PARAMETERS IN MAIN MEMORY*	LOCATIONS RNM1 AND DOWNWARD.*	SV[RNM0,0];	SV[RNM1,20];	SV[RNM2,777];	MC[CMAD];RNS:	Q&larr;RNM1;	CMAD&larr;Q;	X&larr;20S;RNSLP:	RETURN[X&lt;0];	Q&larr;LX;	MDR&larr;Q;	P&larr;WRITE&larr;CMAD;	Q&larr;P-1;	CMAD&larr;Q,DECX,GOTO[RNSLP];**	LOAD THE RANDOM NUMBER GENERATOR PARAMETERS FROM MAIN*	MEMORY LOCATIONS RNM1 AND DOWNWARD.*RNL:	Q&larr;RNM1;	CMAD&larr;Q;	X&larr;20S;RNLLP:	RETURN[X&lt;0];	P&larr;READ&larr;CMAD;	Q&larr;P-1;	CMAD&larr;Q;	P&larr;MDR;	LX&larr;P,DECX,GOTO[RNLLP];**	GENERATE THE NEXT RANDOM NUMBER; LEAVE IT IN Q. ASSUMES L*	REGISTERS AND X ARE LEFT FROM LAST CALL.*NXTRN:	Q&larr;L20,GOTO[.+2,X&gt;=0];	X&larr;17S;	P&larr;LX;	LX&larr;Q&larr;P+Q,DECX;	L20&larr;AQ,RETURN;**	STORE RANDOM NUMBER GENERATOR PARAMETERS IN MAIN MEMORY AND THEN*	FROM THOSE PARAMETERS GENERATE RANDOM WORDS INTO MAIN MEMORY WORDS*	RNM1+1 THROUGH RNM2.*SRPG:	CALL[RNS];	X&larr;NULL;	P&larr;RNM1;SRPGL:	Q&larr;P+1,P&larr;RNM2;	P-Q,CMAD&larr;Q;	RETURN[ALU&lt;0];	CALL[NXTRN];	MDR&larr;Q,CALL[NXTRN];	MDRL&larr;Q;	P&larr;WRITE&larr;CMAD,GOTO[SRPGL];**	READ RANDOM NUMBER GENERATOR PARAMETERS FROM MAIN MEMORY AND THEN*	CHECK THE MAIN MEMORY WORDS IN RNM1+1 TO RNM2 BY COMPARING THEM*	WITH OUTPUT FROM THE RANDOM NUMBER GENERATOR.*	SV[ERRCNT,0];CRPG:	X&larr;20S;	* SAVE GENERATION PARAMETERS	P&larr;LX;	RX&larr;P,DECX;	GOTO[.-2,X&gt;=0];	CALL[RNL];	X&larr;NULL;	P&larr;RNM1;CRPGL:	Q&larr;P+1,P&larr;RNM2;	P-Q,CMAD&larr;Q;	GOTO[RPRESTOR,ALU&lt;0];	READ&larr;CMAD,CALL[NXTRN];	P&larr;MDR;	P#Q;	CALL[RDATERR,ALU#0];	CALL[NXTRN];	P&larr;MDRL;	Q&larr;P#Q,P&larr;17S;	P AND Q;	CALL[RDATERR,ALU#0];	P&larr;CMAD,GOTO[CRPGL];*RDATERR:P&larr;ERRCNT,BRKP[1];	Q&larr;P+1;	ERRCNT&larr;Q;	POP;	POP;	GOTO[DOSEC];*RPRESTOR:X&larr;20S;	* RESTORE GENERATION PARAMETERS	P&larr;RX;	LX&larr;P,DECX;	GOTO[.-2,X&gt;=0];	RETURN;**	DUMP OR CHECK NSEC SECTORS OF RANDOM INFORMATION STARTING AT*	DISK ADDRESS DSTRTAD.*	SV[NSEC,57450];	SV[DSTRTAD,7775 0000 0000];	MC[SECLFT];	MC[PDSKADR];	SV[DISTAB,2];	SV[DISTAB1,0];	SV[DISTAB2,7777 7777 7776];	SV[@DISTAB,IP[DISTAB]];	MC[RANAD];RSTR:	CALL[SETUP],INHINT;	RANAD&larr;NULL;	Q&larr;3S,GOTO[DMPRCOM];*DMPR:	CALL[SETUP],INHINT;	RANAD&larr;NULL;	Q&larr;1S;	L20&larr;AQ,GOTO[DMPRCOM];*RSTRR:	CALL[SETUP],INHINT;	Q&larr;1S;	RANAD&larr;Q;	Q&larr;3S,GOTO[DMPRCOM];*DMPRCOM:NREADRECS&larr;Q;	Q&larr;DSTRTAD;	DSKADR&larr;Q;	Q&larr;FULLSEC;	WDNO&larr;Q;	P&larr;NSEC;	Q&larr;P-1;	SECLFT&larr;Q;	Q&larr;RNM0;	MMAD&larr;Q;DMPRLP:	Q&larr;DSKADR;	* PERMUTE THE SECTORS ON A TRACK FOR FASTER	PDSKADR&larr;Q;	* ACCESS	P&larr;3S;	Q&larr;P AND Q,P&larr;@DISTAB;	Q&larr;P+Q,P&larr;DSKADR;	Y&larr;Q;	Q&larr;SY;	Q&larr;P+Q;	DSKADR&larr;Q;	CALL[SRPG];DOSEC:	CALL[XFSEC];	CALL[CRPG];	Q&larr;DHDWD;	P&larr;DSKADR;	P-Q;	GOTO[.+2,ALU=0];HDRERR2:BRKP[1],GOTO[.];	Q&larr;PDSKADR;	DSKADR&larr;Q;	P&larr;SECLFT;	Q&larr;P-1;	SECLFT&larr;Q,RETURN[ALU&lt;0];	P&larr;RANAD;	P;	GOTO[.+3,ALU=0];	CALL[GRANAD];	GOTO[DMPRLP];	CALL[NXTDSKAD];	GOTO[DMPRLP];**	GENERATE A RANDOM DISK ADDRESS.*	MC[MASK];	MC[LIM];	MC[LPCT];GRANAD:	Y&larr;@DAD;	Q&larr;2S;	LPCT&larr;Q;GRANADLP:INCY;	Q&larr;SY,INCY;	MASK&larr;Q;	Q&larr;SY,INCY;	LIM&larr;Q;GENIT:	CALL[NXTRN];	P&larr;MASK;	Q&larr;P AND Q,P&larr;LIM;	P-Q;	GOTO[GENIT,ALU&lt;0];	LIM&larr;Q;	P&larr;DSKADR;	Q&larr;SY,INCY;	P&larr;P AND Q,Q&larr;LIM;	Q&larr;P OR Q;	DSKADR&larr;Q;	P&larr;LPCT;	Q&larr;P-1;	LPCT&larr;Q,GOTO[GRANADLP,ALU&gt;=0];	RETURN;**	DUMP MAIN MEMORY ON THE DISK.*	SV[STRTLOC,0];	SV[ENDLOC,37 7777];DMPM:	CALL[SETUP],INHINT;	Q&larr;1S;	NREADRECS&larr;Q;	GOTO[DRMEM];*RSTM:	CALL[SETUP],INHINT;	Q&larr;3S;	NREADRECS&larr;Q;	GOTO[DRMEM];*DRMEM:	Q&larr;DSTRTAD;	DSKADR&larr;Q;	Q&larr;FULLSEC;	WDNO&larr;Q;	Q&larr;STRTLOC;	MMAD&larr;Q;RSTLP:	P&larr;MMAD;	Q&larr;ENDLOC;	P-Q;	GOTO[.+2,ALU&lt;=0];	RETURN;	Q&larr;DSKADR;	DHDWD&larr;Q;	CALL[XFSEC];	P&larr;DHDWD;	Q&larr;DSKADR;	P-Q;	GOTO[.+2,ALU=0];HDRERR:	BRKP[1],GOTO[DRMEM];	CALL[NXTDSKAD];	P&larr;MMAD;	Q&larr;1000S;	Q&larr;P+Q;	MMAD&larr;Q,GOTO[RSTLP];**	WRITE ADDRESSES ON A PACK*	SV[PKNO,7775 0000 0000];	MC[SECSLFT];PKINIT:	CALL[SETUP],INHINT;	NREADRECS&larr;NULL;PKCOM:	Q&larr;2S;	WDNO&larr;Q;	Q&larr;7777 7700 0000S;	P&larr;PKNO;	Q&larr;P AND Q;	DSKADR&larr;Q;	Q&larr;57450S;	* NUMBER OF SECTORS PER PACK	SECSLFT&larr;Q;PKLP:	P&larr;SECSLFT;	Q&larr;P-1;	SECSLFT&larr;Q,GOTO[PKEXIT,ALU&lt;0];	Q&larr;DSKADR;	DHDWD&larr;Q;	CALL[XFSEC];	P&larr;DHDWD;	Q&larr;DSKADR;	P-Q;	GOTO[HDRERR,ALU#0];	Q&larr;DSKADR;	P&larr;PKNO;	P&larr;P#Q,Q&larr;7777 7700 0000S;	P&larr;P AND Q;	GOTO[CKR,ALU=0];PKNOERR:BRKP[1],GOTO[.];CKR:	CALL[NXTDSKAD];	GOTO[PKLP];PKEXIT:	RETURN,BRKP[1];*PKCK:	CALL[SETUP],INHINT;	Q&larr;1S;	NREADRECS&larr;Q,GOTO[PKCOM];*CKRST:	CALL[SETUP],INHINT;	GOTO[CKR];**	TRANSFER A SECTOR REPEATEDLY*XFRPT:	CALL[SETUP],INHINT;XFLP:	CALL[CKDSKAD];	CALL[UNPK];	CALL[SEEKSUB];	CALL[SETHDSUB];	CALL[WAITSEC];	CALL[XF0];	GOTO[XFLP];**	WRITE ADDRESSES IN MAIN MEMORY*	MC[CURLOC];	SV[@CURLOC,IP[CURLOC]];WMMAD:	Y&larr;@CURLOC,CALL[SETUP],INHINT;WMM1:	Q&larr;STRTLOC;	CURLOC&larr;Q;WMMLP:	Q&larr;CURLOC;	P&larr;ENDLOC;	P-Q;	GOTO[.+2,ALU&gt;=0];****THIS CODE PROBABLY NEEDS MODIFICATION****WMDONE:	BRKP[1],GOTO[.];	Q&larr;MDR&larr;SY;	P&larr;MDR, CALL[PQCOMP];	Q&larr;MDRL&larr;SY;	P&larr;AQ,Q&larr;17S;	Q&larr;P AND Q;	P&larr;MDRL,CALL[PQCOMP];	P&larr;WRITE&larr;CURLOC;	P&larr;P;	P&larr;P;	* MAKE THIS LOOP MORE THAN TWO MREFS LONG	P&larr;P;	P&larr;P;	P&larr;P;	P&larr;P;	P&larr;P;	Q&larr;P+1;	CURLOC&larr;Q,GOTO[WMMLP];**	SET THE MAIN MEMORY TO ZEROS*	SV[ZERO,0];	SV[@ZERO,IP[ZERO]];ZMEM:	Y&larr;@ZERO,CALL[SETUP],INHINT;	GOTO[WMM1];**	CHECK FOR CORRECT MEMORY CONTENTS*CKMMAD:	Q&larr;STRTLOC,CALL[SETUP],INHINT;	CURLOC&larr;Q;CKMLP:	Q&larr;CURLOC;	P&larr;ENDLOC;	P-Q;	GOTO[.+2,ALU&gt;=0];CKMDONE:BRKP[1],GOTO[.];	READ&larr;CURLOC;	P&larr;CURLOC;	Q&larr;MDR;	P#Q;	GOTO[.+2,ALU=0];CONBAD:	BRKP[1],GOTO[.];	Q&larr;17S;	P&larr;P AND Q;	Q&larr;MDRL;	P#Q;	GOTO[CONBAD,ALU#0];	P&larr;CURLOC;	Q&larr;P+1;	CURLOC&larr;Q,GOTO[CKMLP];**	CALL THE MEMORY DUMP AND RESTORE ROUTINES*DMPMEM:	CALL[DMPM],INHINT;	BRKP[1],GOTO[.-1];*RSTMEM:	CALL[RSTM],INHINT;	BRKP[1],GOTO[.-1];*DMPRAN:	CALL[DMPR],INHINT;	GOTO[.-1],BRKP[1];*RSTRAN:	CALL[RSTR],INHINT;	GOTO[.-1],BRKP[1];*RSTRRAN:CALL[RSTRR],INHINT;	BRKP[1],GOTO[.-1]; </pre>
  </body>
</html>
