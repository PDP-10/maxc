<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12diag.dm!1>dgm.mc</title>
  </head>
  <body>
    <pre>
ER[DGM];		*TEST OF PROCESSOR AND DISK MEMORY INTERFACESTARGET[ILC];%TO ASSEMBLE:	MICRO/L LANG DGM -OR- MICRO/L LANG2 DGMTO RUN:		MIDAS RDGM		START;G		FOR ORDINARY MEMORY TESTING		START1;G	FOR INTERRUPT SYSTEM TESTING		XSTART;G	FOR INTERRUPT SYSTEM TESTINGCOMPARISON ERRORS ARE MASKED BY "DMASK" AND "DMASKL" (PROCESSOR INTERFACE MASKS)AND "KDMASK" AND "KDMASKL" (DISK INTERFACE).TEST THE MAIN MEMORY INTERFACE FOR THE PROCESSOR AND FOR THE DISK CONTROL.BEGIN BY CHECKING OUT THE LOADING AND READING OF MAR, MDR, MDRL, KMAR,KMDR, AND KMDRL FROM/TO THE BUS.  ORIGINALLY LOAD MAR VIA THE MAPVA&larr;DESTINATION WHICH IS ALSO CHECKED OUT.	THEN CHECK THAT ALL OF THE MEMORYREFERENCE FUNCTIONS AND DESTINATIONS LOAD MAR CORRECTLY BUT POSTPONECHECKING OUT MEMORY DATA UNTIL LATER.***NOTE:  NOT ALL BITS OF KMAR CAN BE CHECKED OUT BECAUSE THERE IS NO WAY***TO LOAD THAT REGISTER WITHOUT MAKING A MEMORY REFERENCE.***MEMORY ERRORS HANG THE PROCESSOR UNDER CONTROL OF A HARDWARE SWITCH***DO NOT ASSEMBLE THIS PROGRAM WITH DG1 (SM, RM, AND LM TESTS).***DG0, DG1, AND DGP SHOULD WORK BEFORE THIS IS TRIED.	FIRST VERIFY THAT DGM***WORKS WITH THE DATA COMPARE MASKS SET T0 0.	THEN TRY IT WITH FULL***DATA COMPARE.TO CHECKOUT ONLY DISK MEMORY INTERFACE, PUT BREAKPOINT AT "MCTEST", STARTAT "TKWRT".TO CHECKOUT ONLY PROCESSOR MEMORY INTERFACE, PUT BREAKPOINT AT "TKWRT",START AT "START" (TESTS READ&larr;, WRITE&larr;, AND RMW&larr;)TO TEST XREF, RREF, RMWREF, WREF, ETC., START AT "TREFS" (BREAKS AT ENDOF DIAGNOSTIC).	THIS DOESN'T CHECK OUT VERY MANY ADDRESSES; TO CHECKMORE ADDRESSES, PATCH "TREF1+1" TO BE "CALL[AGEN], P&larr;LADR""START1" COMBINES A CONSTANT INTERRUPT REQUEST AND TRIVIAL INTERRUPTROUTINE WITH PARTS OF THE MEMORY DIAGNOSTIC TO CHECK FOR INTERACTIONSAND FAILURES HAVING TO DO WITH THE ONSET/TERMINATION OF INTERRUPTS AND/ORWITH THE STOP LOGIC.  SINCE THE INTERRUPT ROUTINE RETURNS WITHOUT PREIRET,AT LEAST ONE NON-INTERRUPT INSTRUCTION IS EXECUTED BETWEEN EACH INTERRUPT.THE CHANNEL 17 INTERRUPT IS USED.  ALTERNATE ENTRY POINT "XSTART" ISFOR OCCASIONAL DISK SECTOR INTERRUPTS FROM UNIT A INSTEAD OF CONSTANTINTERRUPTS.  "DGI" SHOULD RUN BEFORE TRYING "START1" OR "XSTART".%*AGGRAVATE PROBLEMS CAUSED BY DENSITY OF 1'S IN IMDEFAULT[IM,(GOTO[3777,NEVER], Q&larr;Q, PQ RCY [0], LA[37], RA[37], A0,	SA[377], B&larr;NULL, NOF2, NOZ, T[0])];INSERT[DGIB.MC];IM[XILC,5];XILC[(CALL[SECIROU], X&larr;YKPTR&larr;KUNIT)];*FALL THRU HERE FROM "MCYCLE"	SETSF[IENABLE&amp;G], DGOTO[TMDR];	GOTO[TMINIT,G=1];START1:	KUNIT&larr;P&larr;NULL, CLEARF[-1S];	ARM&larr;P+1;	SETF[IENABLE&amp;G], GOTO[TMINIT];XSTART:	X&larr;7S;	KUNIT&larr;X, CALL[RETN]; *ALLOW TWO CYCLES SETTLING TIME AFTER KSET&larr;	DECX;	KSET&larr;100 000000S, GOTO[.-2,X&gt;=0]; *DESELECT ALL DISK UNITS	COUNT&larr;ARM&larr;NULL, INHINT;	KUNIT&larr;NULL, INHINT;	IRET, P&larr;MDR, INHINT;	P&larr;NULL, CLEARF[-1S];	KSET&larr;441600 200000S; *ENABLE SECTOR INTS. ON UNIT 0	ARM&larr;2000S;	SETF[10S];	SETF[IENABLE&amp;G], GOTO[TMINIT];SV[MLOW,0];		*LOWEST ADDRESS USED IN DATA OPERATIONSSV[MHIGH,777777];	*HIGHEST ADDRESS USED IN DATA OPERATIONSSV[MAMASK,777777 777777];	*MASK OF BITS FOR MEM. ADDR.****NOT IMPLEMENTEDSV[DMASK,777777 777777]; SV[DMASKL,17];	*MASK FOR MEMORY DATA COMPARESSV[KDMASK,777777 777777]; SV[KDMASKL,17]; *MASK FOR DISK MEMORY COMPARESSVN[SDATA]; SVN[SDATAL];		*HOLD DATA INVOLVED IN CURRENT REFERENCESVN[SBASE]; SVN[SBASEL];		*STARTING NUMBER FOR PASS THRU MAIN MEMORYSVN[SADR];			*CURRENT ADDRESSMC[XCTN,XCTN]; *MASK OF THE FOUR XCT BITS THAT FORCE USER MODE ON REF'SMC[XCT0,XCT0]; *XCT0 CONTROLS IREFMC[NXCT0,XCT1,XCT2,XCT3];MC[XCT1,XCT1]; *XCT1 CONTROLS RREFMC[NXCT1,XCT0,XCT2,XCT3];MC[XCT2,XCT2]; *CONTROLS BIREFMC[NXCT2,XCT0,XCT1,XCT3];MC[XCT3,XCT3]; *CONTROLS WREFMC[NXCT3,XCT0,XCT1,XCT2];MC[CFM&amp;CUM&amp;XCTN,CFM,CUM,XCTN];MC[CFM&amp;CUM&amp;XCT0,CFM,CUM,XCT0];MC[CFM&amp;CUM&amp;XCT1,CFM,CUM,XCT1];MC[CFM&amp;CUM&amp;XCT2,CFM,CUM,XCT2];MC[CFM&amp;CUM&amp;XCT3,CFM,CUM,XCT3];MC[UM&amp;CUM&amp;K&amp;G,UM,CUM,K,G];NMC[NOTG,G];NMC[NOTUM,UM];NMC[NOTCUM,CUM];NMC[NOTGUMCUM,G,UM,CUM];MC[CUM&amp;UM,CUM,UM];MC[CUM&amp;H,CUM,H];MC[UM,UM];MC[UM&amp;K,UM,K];MC[CUM&amp;XCTN,CUM,XCTN];MC[NWP,RP,XP];MC[CUM&amp;NXCT0,CUM,XCT1,XCT2,XCT3];MC[CUM&amp;NXCT1,CUM,XCT0,XCT2,XCT3];MC[CUM&amp;NXCT2,CUM,XCT0,XCT1,XCT3];MC[CUM&amp;NXCT3,CUM,XCT0,XCT1,XCT2];*PARAMETERS FOR THE MAP MEMORY ENTRIESMP[RP,22]; *READ PERMIT BIT (0 ENABLES IREF, BIREF, RREF, AND PARTLY RMWREF)MP[WP,23]; *WRITE PERMIT (0 ENABLES WREF AND PARTLY RMWREF)MP[XP,24]; *EXECUTE PERMIT (0 ENABLES XREF)MC[RP,RP];MC[WP,WP];MC[XP,XP];MC[RP&amp;WP,RP,WP];MC[RP&amp;WP&amp;XP,RP,WP,XP];RVN[RSAVE]; RVN[RNADR]; RVN[RTEMP]; RVN[RTEMP1]; RVN[RTEMP2]; RVN[RTEMP3];LVN[LTEMP]; LVN[LTEMP1]; LVN[LTEMP2]; LVN[LSAVE]; LVN[LADR]; LVN[LINT];SECIROU: LINT&larr;Q, P&larr;Y, Q&larr;400R, CALL[PQCOMP]; *Y NOT LOADED CORRECTLY BY INTERRUPT INSTRUCTION	KREAD&larr;SADR;*443600 200000S WOULD BE USED BELOW TO RESET THE SECTOR INTERRUPT REQUEST*BUT HAVING THE INTERRUPT REPEAT OVER AND OVER IS MORE USEFUL	KSET&larr;441600 200000S; *DON'T INVOKE STOP LOGIC ON NEXT INSTRUCTION	P&larr;P1, IRET, RETURN, Q&larr;LINT;INTROU:	P&larr;Y, LINT&larr;Q;	Q&larr;400S, CALL[PQCOMP]; *Y NOT LOADED CORRECTLY BY INTERRUPT INSTRUCTION	IRET, P&larr;P1, RETURN, Q&larr;LINT;*RTEMP HOLDS P ARGUMENT AND RTEMP1 HOLDS Q ARGUMENT FOR RCY [44-Y]TMINIT:	RTEMP&larr;A0;	RTEMP1&larr;A1, CALL[PQRCY44-YT];	RTEMP&larr;A0;	RTEMP1&larr;A0, CALL[PQRCY44-YT];	RTEMP&larr;A1;	RTEMP1&larr;A0, CALL[PQRCY44-YT];	RTEMP&larr;A1;	RTEMP1&larr;A1, CALL[PQRCY44-YT];	GOTO[YLOADT];PQRCY44-YT: P&larr;777S, A0;PQ44-YL0: Y&larr;P, Q&larr;RTEMP1, CLEARF[H], GOTO[PQ44-YL,ALU&lt;0];	LTEMP&larr;P-1, P&larr;RTEMP;	PQ RCY [44-Y];	P&larr;LTEMP, Q&larr;77R, CALL[CBRK,H=0];	P-Q-1, GOTO[PQ44-YL0];PQ44-YL: Y&larr;P, Q&larr;RTEMP1, CLEARF[H], GOTO[PQ44-YT1,ALU&lt;0];	LTEMP&larr;P-1, P&larr;RTEMP;	PQ RCY [44-Y], CALL[H=1T];	P&larr;LTEMP, Q&larr;44R;	P-Q-1, P&larr;LTEMP, GOTO[PQ44-YL];PQ44-YT1: P&larr;44R;	RTEMP3&larr;P; *VALUE FOR Y	Y&larr;P, P&larr;RTEMP, CLEARF[H];	LTEMP2&larr;P, Q&larr;RTEMP1;	PQ RCY [44-Y], RTEMP2&larr;Q;	Q&larr;RTEMP, CALL[PQCOMP]; *PQ RCY [44-Y] FAILED ON [Y] = 44	CALL[CBRK,H=1];PQ44-YL1: Q&larr;LTEMP2, P&larr;RTEMP2;	PQ RCY [1], Q&larr;RTEMP2;	RTEMP2&larr;P, P&larr;LTEMP2;	PQ RCY [1];	LTEMP2&larr;P, P&larr;RTEMP3;	RTEMP3&larr;P&larr;P-1, Q&larr;44L;	Y&larr;P, P&larr;RTEMP, FRZBALUBC;	Q&larr;RTEMP1, SETF[H], RETURN[ALU&lt;0];	PQ RCY [44-Y], Q&larr;LTEMP2, CALL[PQCOMP]; *PQ RCY [44-Y] FAILED ON Y	CALL[CBRK,H=1]; *H NOT LEFT 0 BY PQ RCY [44-Y]	GOTO[PQ44-YL1];H=1T:	RETURN[H=1];	BREAK;		*H WASN'T = 1 AFTER PQ RCY [44-Y] WITH [Y]&gt;=44YLOADT:	P&larr;A1, BAMASK[22];YTLOOP:	RTEMP1&larr;MAPVA&larr;P, PQ RCY [11], BAMASK[11];	Q&larr;Y, CALL[PQCOMP]; *INTERRUPT ROUTINE CLOBBERED Y	P&larr;RTEMP1, Q&larr;400000S;	Q&larr;P AND Q, PQ RCY [11], BAMASK[11];	YSHIFT&larr;P OR Q, PQ RCY [0], BAMASK[11];	Q&larr;Y, CALL[PQCOMP]; *INTERRUPT ROUTINE CLOBBERED Y	P&larr;RTEMP1;	Y&larr;P, PQ RCY [0], BAMASK[11];	Q&larr;Y, CALL[PQCOMP]; *INTERRUPT ROUTINE CLOBBERED Y	P&larr;RTEMP1, Q&larr;1000S;	RTEMP1&larr;P&larr;P-Q, Q&larr;400000S;	P AND Q, DGOTO[TMDR];	GOTO[YTLOOP,ALU#0];TMDR:	P&larr;MDR&larr;NULL;	Q&larr;MDR, CALL[QZT];	*MDR OR MDR&larr; FAILED ON 0	MDR&larr;P+1, P&larr;B;	Q&larr;MDR, CALL[PQCOMP];	*MDR OR MDR&larr; FAILED ON [P]	MDR&larr;2P, P&larr;B;	GOTO[.-2,ALU#0];	P&larr;B, B&larr;A1;	Q&larr;B, MDR&larr;2P;	P&larr;MDR, CALL[PQCOMP];	*MDR OR MDR&larr; FAILED ON [Q]	Q LCY 1;	GOTO[.-2,Q ODD], MDR&larr;Q;*ON "XSTART" ENTRY TO "DGM" CODE BELOW CHECKS OUT "INHINT"TKMDR:	P&larr;KMDR&larr;NULL, INHINT;	Q&larr;KMDR, CALL[QZT];	*KMDR OR KMDR&larr; FAILED ON 0	KMDR&larr;P+1, P&larr;B, INHINT;	Q&larr;KMDR, CALL[PQCOMP];	*KMDR OR KMDR&larr; FAILED ON [P]	KMDR&larr;2P, P&larr;B, INHINT;	GOTO[.-2,ALU#0], INHINT;	P&larr;B, B&larr;A1;	Q&larr;B, KMDR&larr;2P, INHINT;	P&larr;KMDR, CALL[PQCOMP];	*KMDR OR KMDR&larr; FAILED ON [Q]	Q LCY 1;	GOTO[.-2, Q ODD], KMDR&larr;Q, INHINT;TMDRL:	P&larr;MDRL&larr;NULL;	Q&larr;MDRL, CALL[PQCOMP];	*MDRL OR MDRL&larr; FAILED ON [P]	P&larr;B, MDRL&larr;P+1, Q&larr;17R;	*Q&larr;17	P-Q;	GOTO[.-3,ALU&lt;=0];TKMDRL:	P&larr;KMDRL&larr;NULL, INHINT;	Q&larr;KMDRL, CALL[PQCOMP];	*KMDRL OR KMDRL&larr; FAILED ON [P]	P&larr;P+1;	KMDRL&larr;P, Q&larr;17R, INHINT;	P-Q, INHINT;	GOTO[.-3,ALU&lt;=0], INHINT;*~ MAXC2 ONLYTMDST:	CLEARF[-1S], MDR&larr;-1S;	MDRL&larr;NULL;	Q&larr;MDR&amp;SETTAG, P&larr;A1, CALL[PQCOMP]; *B&larr;MDR FAILED ON MDR&amp;SETTAG	P&larr;A0, Q&larr;FLAGS, CLEARF[-1S], CALL[PQCOMP]; *TAG FLAGS LOADED WRONG ON MDR&amp;SETTAG	MDRL&larr;LTEMP&larr;P+1;TMDSTL:	Q&larr;MDR&amp;SETTAG, P&larr;A1, CALL[PQCOMP]; *B&larr;MDR FAILED ON MDR&amp;SETTAG	P&larr;A0, Q&larr;LTEMP;	PQ RCY [30], Q&larr;FLAGS, CALL[PQCOMP]; *TAG FLAGS LOADED WRONG ON MDR&amp;SETTAG	Q&larr;LTEMP;	Q LSH 1, P&larr;A1, BAMASK[4];	P-Q, CLEARF[-1S];	LTEMP&larr;MDRL&larr;Q, GOTO[TMDSTL,ALU&gt;0];*~*JUMP OVER A BUNCH OF SUBROUTINES USED BY THE TESTS WHICH FOLLOW LATER	GOTO[TMVAT];%THE ROUTINES BELOW ARE SUBROUTINES WHICH ARE CALLED TO GENERATE ADDRESSESAND DATA FOR THE VARIOUS OTHER SECTIONS OF THE DIAGNOSTIC AND TO CHECKTHE RESULTS OF MEMORY READS.%*INITIALIZE THE MEMORY ADDRESS VARIABLES "SADR" AND "LADR"AINI:	Q&larr;MLOW, P&larr;LSAVE;	SADR&larr;LADR&larr;Q, Q&larr;RSAVE, RETURN;*GENERATE NEXT ADDRESS, RETURN IT IN Q AND THRU ALU, 17 IN P.	CALLED WITH*PREVIOUS ADDRESS IN P.	TIMING = 3AGEN:	Q&larr;P+1, P&larr;MHIGH;AGEN0:	P-Q;	LADR&larr;SADR&larr;Q, P&larr;17R, FRZBALUBC, RETURN;*GENERATE PREVIOUS ADDRESS LSH 1, RETURN IT IN Q AND THRU ALU BUT RETURN*MLOW ON FIRST ADDRESS &gt; MHIGH.  CALLED WITH PREVIOUS ADDRESS IN Q.AGEN1:	0Q RCY [43], Q&larr;MHIGH;AGEN3:	P&larr;Q, Q&larr;P, GOTO[AGEN0];AGEN2:	NOT(A0)Q RCY [43], Q&larr;MHIGH, GOTO[AGEN3];*INITIALIZE THE DATA CELLS "SDATA", "SDATAL" AND "SBASE", "SBASEL" TO A*SINGLE 1.  TIMING = 4DINIS1:	P&larr;SDATA&larr;NULL;	Q&larr;P+1, SBASE&larr;NULL;	SDATAL&larr;Q;	SBASEL&larr;Q, RETURN;*INITIALIZE THE DATA CELLS "SDATA" "SDATAL" AND "SBASE", "SBASEL" TO A*SINGLE 0.  TIMING = 5DINIS0:	P&larr;Q&larr;377777 777777S;	SDATA&larr;Q;	SBASE&larr;Q, Q&larr;17R;	SDATAL&larr;Q;	SBASEL&larr;Q, RETURN;*PUT SBASE, SBASEL IN SDATA, SDATAL*TIMING = 4DSET:	Q&larr;SBASE;	SDATA&larr;Q;	Q&larr;SBASEL;	SDATAL&larr;Q, GOTO[AINI];*RCY 1 THE 40-BIT QUANTITY IN SBASE, SBASEL AND LEAVE IT IN SDATA,SDATAL ALSO*RETURNS WITH SDATA THRU ALU AND SDATAL IN Q*TIMING = 8BDADV:	Q&larr;SBASEL;	PQ RCY [4], Q&larr;SBASE;	LTEMP1&larr;Q, PQ RCY [41], BAMASK[4], Q&larr;SBASEL;	RTEMP2&larr;MDR&larr;P, P&larr;LTEMP1;	SBASEL&larr;MDR, PQ RCY [1];	SDATAL&larr;MDR, Q&larr;P;	SDATA&larr;Q;	SBASE&larr;Q, AQ, RETURN, Q&larr;RTEMP2;*RCY BY 1 THE 40-BIT QUANTITY IN SDATA, SDATAL.*TIMING = 7DGEN:	Q&larr;SDATAL, RSAVE&larr;Q;	LSAVE&larr;P, PQ RCY [4], Q&larr;SDATA;	LTEMP1&larr;Q, PQ RCY [41], BAMASK[4], Q&larr;SDATAL;	MDR&larr;P, P&larr;LTEMP1;	SDATAL&larr;MDR, PQ RCY [1];	Q&larr;P;	SDATA&larr;Q, Q&larr;RSAVE, P&larr;LSAVE, RETURN;*COMPLEMENT THE DATA IN SBASE AND SBASEL AND LEAVE IT IN SDATA, SDATAL AND*IN MDR, MDRL ALSO.*TIMING = 5NMDATA:	Q&larr;SBASE, RSAVE&larr;Q;	LSAVE&larr;P, P&larr;SBASEL;	Q&larr;NOT Q;	SBASE&larr;MDR&larr;Q, P&larr;NOT P, BAMASK[4];	SDATA&larr;Q, Q&larr;P;	SBASEL&larr;MDRL&larr;Q;	SDATAL&larr;Q, GOTO[AINI];*COMPLEMENT SDATA, SDATAL AND LEAVE IN MDR, MDRL*HAVE NOT(SDATA) IN Q, SDATAL IN P AT CALLNDGEN:	SDATA&larr;MDR&larr;Q, P&larr;NOT P, BAMASK[4];	WRESTART, MDRL&larr;Q&larr;P;	SDATAL&larr;Q, RETURN;*COMPARE THE DATA IN MDR, MDRL TO THE DATA IN SDATA, SDATAL*TIMING = 10DCOMP:	LSAVE&larr;P, P&larr;SDATA;	RSAVE&larr;Q, Q&larr;MDR;	Q&larr;P#Q, P&larr;DMASK;	Q&larr;P AND Q, CALL[AZT], P&larr;MDRL; *WRONG BITS FOR MDR COMPARE IN Q	Q&larr;SDATAL;	Q&larr;P#Q, P&larr;DMASKL;	Q&larr;P AND Q, CALL[AZT];	*WRONG BITS FOR MDRL COMPARE IN Q	P&larr;LSAVE, Q&larr;RSAVE, RETURN;*COMPARE THE DATA IN KMDR, KMDRL TO THAT IN SDATA, SDATAL*TIMING = 10KDCOMP:	LSAVE&larr;P, P&larr;SDATA;	RSAVE&larr;Q, Q&larr;KMDR;	Q&larr;P#Q, P&larr;KDMASK;	Q&larr;P AND Q, CALL[AZT], P&larr;KMDRL; *WRONG BITS FOR KMDR COMPARE IN Q	Q&larr;SDATAL;	Q&larr;P#Q, P&larr;KDMASKL;	Q&larr;P AND Q, CALL[AZT];	*WRONG BITS FOR KMDRL COMPARE IN Q	P&larr;LSAVE, Q&larr;RSAVE, RETURN;*SUBROUTINE TO CHECK AFTERMATH OF ILLEGAL MEMORY REFERENCES IN MONITOR*MODE.IRFCHK:	CALL[CBRK,G=0];	*READ ILLEGAL SO SHOULD LEAVE G=1	CALL[CBRK,H=1], SETSF[CUM&amp;H]; *NO XCTI FLAGS SET SO H=0	P&larr;MAR, Q&larr;RTEMP, CALL[PQCOMP]; *THE ADDRESS PUT INTO RTEMP AND INTO				*MONITOR MAP ENTRY FOR THE PAGE CONTAINING				*THE CURRENT ADDRESS CONSISTS OF THE LOW 9				*BITS OF THE CURRENT ADDRESS AND THE COMPLEMENT				*OF THE REST OF THE ADDRESS MASKED BY MHIGH.				*THIS SHOULD WIND UP IN MAR REGARDLESS OF THE				*LEGALITY OF THE REF OR WHETHER IT IS AND AC				*REFERENCE	CALL[CBRK,H=1], P&larr;MHIGH; *MHIGH IS JUST A RANDOM VALUE FOR ITS				*USE HERE TO FIND OUT WHETHER THE MEMORY INTER-				*FACE WAS ACTIVE DESPITE THE ILLEGALITY OF THE				*READ.	CLEARF[-1S], Q&larr;MDR, CALL[PQCOMP]; *CHECK FOR MDR UNCHANGED	Q&larr;MDRL, P&larr;RTEMP1, CALL[PQCOMP]; *CHECK FOR MDRL UNCHANGED	P&larr;LADR, MDRL&larr;P;	MAPVA&larr;P, RETURN;*SUBROUTINE TO CHECK OUT THE AFTERMATH OF MONITOR MODE READ REF'SMRCHK:	CALL[CBRK,H=1], SETSF[CUM&amp;H]; *H=0 BECAUSE NOT A FORCED USER REF	CALL[CBRK,H=1];	 *CUM=0 BECAUSE MONITOR MODE AND XCTI=0RCHK:	P&larr;MAR, Q&larr;RTEMP, CALL[PQCOMP]; *MAR SHOULD BE [Q]RCHK1:	P&larr;SDATA, CALL[CBRK,G=1];	*RP OR XP WAS 0 IN MAP SO REF SUCCEEDS	CLEARF[-1S], Q&larr;MDR;	*COMPARE THE DATA FROM THE READ	Q&larr;P#Q, P&larr;DMASK;	P AND Q, P&larr;MDRL;	Q&larr;SDATAL, CALL[CBRK,ALU#0];	*(MDR XOR SDATA) AND DMASK # 0	Q&larr;P#Q, P&larr;DMASKL;	P AND Q, P&larr;LADR, MDR&larr;NULL;	Q&larr;SDATA, RETURN[ALU=0];	*RETURN SDATA IN Q IN CASE "NDGEN" NEXT	BRKP[1];			*(MDRL XOR SDATAL) AND DMASKL # 0*SUBROUTINE TO CHECK AFTERMATH OF FORCED USER READS WITH CFM=1CFMCHK:	CALL[CBRK,H=0], SETSF[CUM&amp;H];	CALL[CBRK,H=1]; *CUM=0 BECAUSE CFM=1	GOTO[RCHK];*SUBROUTINE TO TEST THE AFTERMATH OF READ REF'S IN MONITOR MODE WHICH ARE*FORCED TO USER MODE BY THE SETTING OF AN XCTI FLAG IN FFURCHK:	CALL[CBRK,H=0], SETSF[CUM&amp;H]; *FORCED UM REF SO H=1	CALL[CBRK,H=0];	 *CUM SHOULD BE 1 SINCE XCTI=1 FOR REF	P&larr;MAR, Q&larr;LTEMP, CALL[PQCOMP];	GOTO[RCHK1];*SUBROUTINE TO TEST THE AFTERMATH OF A LEGAL USER MODE READURCHK:	CALL[CBRK,H=1], SETSF[CUM&amp;H]; *NOT A FORCED UM REF	CALL[CBRK,H=0];	 *CUM SHOULD BE 1 SINCE UM=1 FOR REF	GOTO[RCHK];*SUBROUTINE TO TEST THE AFTERMATH OF MAPVA&larr;.  CALLED WITH 17 IN Q,*ADDRESS IN P, CORRECT [F] IN RTEMP (BUT G=0).	RETURNS WITH F=0.*TIMING = 13+1 IF AC*! MAXC1 ONLYTMVAX:	P-Q, Q&larr;RTEMP, P&larr;NOT F;	DGOTO[TMVAAC,ALU&lt;=0], P=Q;*!*~ MAXC2 ONLYTMVAX:	P-Q, Q&larr;RTEMP, P&larr;FLAGS;	P#Q, DGOTO[TMVAAC,ALU&lt;=0];*~	Q&larr;(Q) U (1S), FRZBALUBC;TMVA0:	CALL[CBRK,ALU#0], P&larr;LADR, Q&larr;377S; *MAPVA&larr; LOADED F INCORRECTLY				*(CORRECT VALUE= RTEMP OR RTEMP+1 IF AC)	Q&larr;P AND Q, P&larr;X, CALL[PQCOMP]; *MAPVA&larr; DIDN'T LOAD X FROM B[28-35]	P&larr;LADR, Q&larr;MAR, CALL[PQCOMP]; *MAPVA&larr; DIDN'T LOAD MAR FROM [P]	PQ RCY [11], SAMASK[11], CALL[PQCOMP], Q&larr;Y; *MAPVA&larr; DIDN'T LOAD Y				*FROM B[18-26]=[P]	RETURN, CLEARF[-1S];*! MAXC1 ONLYTMVAAC:	P=Q, GOTO[TMVA0];*!*~ MAXC2 ONLYTMVAAC:	P#Q, GOTO[TMVA0];*~*TEST OUT MAPVA&larr; ON ALL LEGAL ADDRESSES WITH THE AFFECTED REGISTERS*BOTH ORIGINALLY 0 AND ORIGINALLY -1 AND WITH MAPVA&larr; TESTED USING BOTH*THE ALU TEST AND THE ACFS TEST.*TIMING = ((MHIGH-MLOW)*16*8)+1 = ABOUT 128*(MHIGH-MLOW) CYCLESTMVAT:	SETSF[IENABLE&amp;G];	SADR&larr;MAPVA&larr;NULL, LADR&larr;A0, GOTO[TWRT,G=1];	RTEMP&larr;A0, P&larr;LADR, CLEARF[-1S];	MAPVA&larr;P, Q&larr;17R, CALL[TMVAX];	MAPVA&larr;A1;	P&larr;CUM&amp;UM;	RTEMP&larr;P, P&larr;LADR, SETF[UM];	MAPVA&larr;P, Q&larr;17R, CALL[TMVAX];	MAPVA&larr;NULL;	P&larr;NOTGUMCUM;	RTEMP&larr;P, P&larr;LADR, SETF[NOTUM];	MAPVA&larr;P, Q&larr;17R, CALL[TMVAX];	MAPVA&larr;A1;	P&larr;NOT G;	RTEMP&larr;P, P&larr;LADR, SETF[NOTCUM];	MAPVA&larr;P, Q&larr;17R, CALL[TMVAX];	MAPVA&larr;NULL;	RTEMP&larr;A0, CLEARF[-1S];	MAPVA&larr;P&larr;SADR, Q&larr;17R, ACFS, CALL[TMVAX];	MAPVA&larr;A1;	P&larr;CUM&amp;UM;	RTEMP&larr;P, SETF[UM];	MAPVA&larr;P&larr;SADR, Q&larr;17R, CALL[TMVAX];	MAPVA&larr;NULL;	P&larr;NOTGUMCUM;	RTEMP&larr;P, SETF[NOTUM];	MAPVA&larr;P&larr;SADR, Q&larr;17R, CALL[TMVAX];	MAPVA&larr;A1;	P&larr;NOT G;	RTEMP&larr;P, SETF[NOTCUM], CALL[RETN];	MAPVA&larr;P&larr;SADR, ACFS, Q&larr;17R, CALL[TMVAX];*NOW TRY WRITE&larr;, READ&larr;, AND RMW&larr; ALLOWING TIME FOR REFERENCES TO FINISH.*MAR AND [F] UNCHANGED ARE CHECKED FOR AND THE DATA IS COMPARED AFTER*ANDING WITH DMASK, DMASKL*TIMING = 160*((MHIGH-MLOW)*81+25+3)+19 OR ABOUT 12,960*(MHIGH-MLOW) CYCLES*! MAXC1 ONLYTWRT:	P&larr;NOT F;		*CHECK FOR F GETTING CLOBBERED*!*~ MAXC2 ONLYTWRT:	P&larr;FLAGS;*~	LTEMP&larr;P, CALL[AINI];TWR0:	CALL[DINIS1];		*INITIALIZE SDATA, SDATAL, SBASE, SBASEL	CALL[SWRT];		*CHECK WRITE&larr;, RMW&larr;, AND READ&larr; ON EVERY ADDRESS				*USING DATA GENERATED FROM SBASE, SBASEL	CALL[BDADV];		*LOOP THROUGH THE 40 VALUES OF SBASE, SBASEL				*BDADV RETURNS WITH SBASEL IN Q (NOT SLOW SOURCE)	GOTO[.-2,Q EVEN];	*WHICH HAVE A SINGLE 1 WITH 39 0'S	CALL[DINIS0];		*REPEAT THE ABOVE FOR THE 40 VALUES OF SBASE,	CALL[SWRT];		*SBASEL WHICH HAVE A SINGLE 0 WITH 39 1'S	CALL[BDADV];		*BDADV RETURNS WITH SBASE THROUGH ALU	GOTO[.-2,ALU&lt;0];*! MAXC1 ONLY	P&larr;NOT F, Q&larr;LTEMP, CALL[PQCOMP]; *F SMASHED DURING THE PRECEDING*!*~ MAXC2 ONLY	P&larr;FLAGS, Q&larr;LTEMP, CALL[PQCOMP];*~	GOTO[TKWRT];*TIMING = (MHIGH-MLOW)*(19+33+29)+25SWRT:	CALL[WLP];	CALL[RMWLP];	CALL[RLP];	CALL[HSRMWLP];	GOTO[RLP];	*RETURN TO CALLER OF SWRT*SEQUENTIALLY WRITE ALL THE ADDRESSES IN THE MACHINE USING DATA WHICH IS*RCY 1 FROM THE PRECEDING WORD'S DATA EACH TIME WITH THE ORIGINAL DATA*BEING THE VALUE IN SBASE, SBASEL.*TIMING = (MHIGH-MLOW)*19+1WLP:	WRITE&larr;Q&larr;SADR, INHINT;	MDR&larr;SDATA, INHINT;	MDRL&larr;SDATAL;	P&larr;MAR, CALL[PQCOMP];	*WRITE DIDN'T LOAD MAR FROM B	CALL[DGEN], Q&larr;SDATAL;	CALL[AGEN], P&larr;LADR, MDR&larr;MDR;	GOTO[WLP,ALU&gt;=0];	GOTO[DSET];*TIMING = (MHIGH-MLOW)*33+1RMWLP:	RMW&larr;Q&larr;SADR, INHINT;	P&larr;MAR, CALL[PQCOMP];	*MAR NOT LOADED BY RMW&larr;.  CORRECT VALUE IN Q	Q&larr;SDATA;	CALL[DCOMP], P&larr;SDATAL;	*ADDRESS OF DATA IN LADR OR SADR	MDR&larr;NOT Q, WRESTART;	MDRL&larr;NOT P, CALL[DGEN], P&larr;LADR;	CALL[PQCOMP], Q&larr;MAR;	*WRESTART SMASHED MAR	CALL[AGEN];	GOTO[RMWLP,ALU&gt;=0];	GOTO[NMDATA];*TIMING = (MHIGH-MLOW)*29+1RLP:	READ&larr;Q&larr;SADR;	P&larr;MAR, CALL[PQCOMP];	*MAR NOT LOADED BY READ&larr;.  CORRECT VALUE IN Q	CALL[DCOMP];		*ADDRESS IN BOTH SADR AND LADR	CALL[DGEN];	CALL[AGEN], P&larr;LADR;	GOTO[RLP,ALU&gt;=0];	GOTO[DSET];*THE FOLLOWING ROUTINE EXERCISES RMW&larr; AT A HIGHER SPEED THAN THE PRECEDING*TEST WITHOUT ERROR CHECKS SUCH THAT THE ERRORS ARE CAUGHT BY THE FOLLOWING*READ&larr; CHECKHSRMWLP: RMW&larr;SADR, INHINT, CALL[RETN]; ****REMOVE CALL WHEN MEM INT WORKS	Q&larr;MDR;	P&larr;MDRL, WRESTART;	MDR&larr;NOT Q, INHINT;	MDRL&larr;NOT P, CALL[DGEN];	P&larr;LADR, CALL[AGEN];	GOTO[HSRMWLP,ALU&gt;=0];	GOTO[NMDATA];*EXCEPT THAT [F] IS NOT CHECKED FOR BEING UNCHANGED.*TIMING = (MHIGH-MLOW)*(19+31+29)+26SKWRT:	CALL[KWLP];		*WRITE EVERY ADDRESS USING NUMBERS				*GENERATED FROM THE CURRENT SBASE, SBASEL	CALL[KRLP];		*NOW KREAD&larr; AND CHECK THE RESULTS	CALL[NMDATA];	GOTO[BDADV];		*CYCLE THE DATA BASE AND RETURN*TIMING = 80*((MHIGH-MLOW)*(19+33+29)+29)+19 = ABOUT 6,340*(MHIGH-MLOW) CYCLES*! MAXC1 ONLYTKWRT:	P&larr;NOT F;*!*~ MAXC2 ONLYTKWRT:	P&larr;FLAGS;*~	LTEMP&larr;P, CALL[AINI];	CALL[DINIS1];	CALL[SKWRT];	GOTO[.-1, Q EVEN];	CALL[DINIS0];	CALL[SKWRT];	GOTO[.-1,ALU&lt;0];*! MAXC1 ONLY	P&larr;NOT F, Q&larr;LTEMP, CALL[PQCOMP]; *F SMASHED BY ONE OF DISK MEMORY				*INTERFACE FUNCTIONS*!*~ MAXC2 ONLY	P&larr;FLAGS, Q&larr;LTEMP, CALL[PQCOMP];*~	SETSF[IENABLE&amp;G], DGOTO[TSTOP];	GOTO[MCTEST,G=0];KWLP:	KWRITE&larr;Q&larr;SADR, INHINT;	KMDRL&larr;SDATAL, INHINT;	KMDR&larr;SDATA;	P&larr;KMAR, CALL[PQCOMP];	*KWRITE&larr; DIDN'T LOAD KMAR FROM B OR KMAR				*BUS SOURCE FAILED	CALL[DGEN];		*GENERATE THE NEXT DATA VALUE (PREVIOUS RCY 1)	CALL[AGEN], P&larr;LADR;	*GENERATE THE NEXT ADDRESS	GOTO[KWLP,ALU&gt;=0];	*FALL THRU WHEN ADDRESS = 0 AGAIN	GOTO[DSET];*TIMING = 29*(MHIGH-MLOW)+1KRLP:	KREAD&larr;Q&larr;SADR;	P&larr;KMAR, CALL[PQCOMP];	*KREAD&larr; DIDN'T LOAD KMAR CORRECTLY	Q&larr;Q;	CALL[KDCOMP];	CALL[DGEN];	CALL[AGEN], P&larr;LADR;	GOTO[KRLP,ALU&gt;=0];	RETURN;*MEMORY COMPETITION TEST USING BOTH MEMORY INTERFACES*(1) WRITE&larr; FROM PROC, KREAD&larr; FROM DISK*(2) RMW&larr; FROM PROC, KRMW&larr; FROM DISK*(3) READ&larr; FROM PROC, KREAD&larr; FROM DISK*(4) KWRITE&larr; FROM DISK, READ&larr; FROM PROC**THIS TEST PERFORMED ONLY IF MASKS ARE ALL 1'SMCTEST:	P&larr;KDMASK;	P&larr;DMASK, NOT P;	P&larr;KDMASKL, Q&larr;17R, NOT P, GOTO[TREFS,ALU#0];	P&larr;DMASKL, P#Q, GOTO[TREFS,ALU#0];	P#Q, GOTO[TREFS,ALU#0];	GOTO[TREFS,ALU#0];	CALL[AINI], CLEARF[-1S], LTEMP&larr;A1;	CALL[DINIS1];	CALL[SPKWRT];	GOTO[.-1,Q EVEN];	CALL[DINIS0];	CALL[SPKWRT];	GOTO[.-1,ALU&lt;0];*! MAXC1 ONLY	P&larr;NOT F, Q&larr;LTEMP, CALL[PQCOMP]; *F SMASHED BY ONE OF DISK OR PROC			*MEMORY FUNCTIONS*!*~ MAXC2 ONLY	P&larr;FLAGS, Q&larr;LTEMP, CALL[PEQZ];*~*MEMORY COMPETITION TEST HITTING THE PROCESSOR INTERFACE WITH A REF*AND THE DISK INTERFACE WITH A REFERENCE IN THE SAME MICROINSTRUCTION.*THE PROCESSOR INTERFACE SHOULD WIN.***NOTE THAT THE REF'S HAVE NOT BEEN TESTED YET, SO THAT THE FOLLOWING***TEST IS OUT OF SEQUENCE.  HOWEVER, WHEN UNTESTED MAXC'S ARE BROUGHT***UP YOU SHOULD FIRST RUN DGM WITH ALL DATA COMPARE MASKS SET TO 0.***THIS SHOULD CATCH PROBLEMS WITH REF'S.  THESE TESTS WERE PUT HERE TO***KEEP THEM WITH THE OTHER MEMORY BASHING TESTS.  REMEMBER THAT***NONE OF THESE TESTS GET RUN WHEN DATA COMPARE MASKS AREN'T ALL 1'S.MCT2:	CLEARF[-1S], CALL[MAPINI];	CALL[DINIS1];	CALL[KREFT];	GOTO[.-1,Q EVEN];	CALL[DINIS0];	CALL[KREFT];	GOTO[.-1,ALU&lt;0];	GOTO[TREFS];PWKRLP:	Q&larr;MDR&larr;SDATA;	WRITE&larr;SADR, INHINT;	KREAD&larr;SADR, INHINT;	P&larr;MDRL&larr;SDATAL;	RTEMP&larr;P, P&larr;KMDR, CALL[PQCOMP];	P&larr;RTEMP, Q&larr;KMDRL, CALL[PQCOMP];	CALL[DGEN];	P&larr;LADR, CALL[AGEN];	GOTO[PWKRLP,ALU&gt;=0];	GOTO[DSET];PRKRLP:	READ&larr;SADR;	KREAD&larr;SADR;	Q&larr;MDR;	P&larr;KMDR, CALL[PQCOMP];	Q&larr;MDRL;	P&larr;KMDRL, CALL[PQCOMP];	CALL[DGEN];	CALL[AGEN], P&larr;LADR;	GOTO[PRKRLP,ALU&gt;=0];	GOTO[DSET];KWPRLP:	P&larr;KMDR&larr;SDATA;	KWRITE&larr;SADR, INHINT;	READ&larr;SADR, INHINT;	Q&larr;KMDRL&larr;SDATAL;	RTEMP&larr;Q, Q&larr;MDR, CALL[PQCOMP];	Q&larr;MDRL, P&larr;RTEMP, CALL[PQCOMP];	CALL[DGEN];	P&larr;LADR, CALL[AGEN];	GOTO[KWPRLP,ALU&gt;=0];	GOTO[DSET];SPKWRT:	CALL[PWKRLP];	CALL[PRKRLP];	CALL[KWPRLP];	GOTO[BDADV];*SUBROUTINE TO NEUTRALIZE MAP BY FILLING IT WITH READ, WRITE, AND ACCESS*PERMISSION AND POINTING EACH VIRTUAL PAGE AT THE ABSOLUTE PAGE OF THE SAME*NUMBER.MAPINI:	MAP&larr;Y, INCY, GOTO[.,Y&gt;=0];	MAP&larr;Y, INCY, GOTO[.,Y&lt;0];	RETURN;*PROCESSOR WREF AND KREAD&larr;PWREFKR: P&larr;Q&larr;17R, CALL[AGEN];PWRFKRLP: MAPVA&larr;SADR, ACFS;	WREF, CALL[CBRK,G=1], KREAD&larr;SADR, INHINT;	Q&larr;MDRL&larr;SDATAL, INHINT, CALL[CBRK,G=1];	RTEMP&larr;Q, Q&larr;MDR&larr;SDATA;	P&larr;KMDR, CALL[PQCOMP];	P&larr;KMDRL, Q&larr;RTEMP, CALL[PQCOMP];	CALL[DGEN];	P&larr;LADR, CALL[AGEN];	GOTO[PWRFKRLP,ALU&gt;=0];	GOTO[DSET];*PROCESSOR RREF AND KWRITE&larr;PRREFKW: P&larr;Q&larr;17R, CALL[AGEN];PRREFKWLP: Q&larr;SDATA;	P&larr;SDATAL;	MAPVA&larr;SADR, ACFS;	RREF, CALL[CBRK,G=1], KWRITE&larr;SADR, INHINT;	KMDR&larr;NOT Q, INHINT, CALL[CBRK,G=1];	KMDRL&larr;NOT P;	RTEMP&larr;P, P&larr;MDR, CALL[PQCOMP];	P&larr;RTEMP, Q&larr;MDRL, CALL[PQCOMP];	CALL[DGEN];	P&larr;LADR, CALL[AGEN];	GOTO[PRREFKWLP,ALU&gt;=0];	GOTO[NMDATA];KREFT:	CALL[PWREFKR];	CALL[PRREFKW];	GOTO[BDADV];*TEST DISK MEMORY INTERFACE STOP LOGICTSTOP1:	CALL[AINI];	*INITIALIZE ADDRESS TO 0TSTOPA:	READ&larr;SADR;	*MAKE MEMORY QUADRANT BUSY	KWRITE&larr;SADR, INHINT;	KMDR&larr;A1, CALL[RETN];	KMDR&larr;NULL;	*SHOULD INVOKE STOP LOGIC	KREAD&larr;SADR, CALL[RETN];	P&larr;KMDR, CALL[NPZT];	*KMDR&larr; DIDN'T INVOKE STOP LOGIC ON KWRITE&larr;	READ&larr;SADR;		*MAKE MEMORY QUADRANT BUSY	KWRITE&larr;SADR, INHINT;	KMDRL&larr;KMDR&larr;A1, CALL[RETN];	KMDRL&larr;NULL;		*SHOULD INVOKE STOP LOGIC	KREAD&larr;SADR, CALL[RETN];	P&larr;KMDRL, Q&larr;17R, CALL[PQCOMP]; *KMDRL&larr; DIDN'T INVOKE STOP LOGIC ON KWRITE&larr;	P&larr;LADR, CALL[AGEN];	GOTO[TSTOPA,ALU&gt;=0];*TEST PROCESSOR MEMORY INTERFACE STOP LOGICTSTOP2:	CALL[AINI];TSTOPB:	KREAD&larr;SADR;	*MAKE QUADRANT BUSY	WRITE&larr;SADR, INHINT;	MDR&larr;A1, CALL[RETN];	MDR&larr;NULL;	*SHOULD INVOKE STOP LOGIC	READ&larr;SADR, CALL[RETN];	*CHECK RESULTS	P&larr;MDR, CALL[NPZT];	*MDR&larr; DIDN'T INVOKE STOP LOGIC ON WRITE&larr;	KREAD&larr;SADR;	*MAKE QUADRANT BUSY	WRITE&larr;SADR, INHINT;	MDRL&larr;MDR&larr;A1, CALL[RETN];	MDRL&larr;NULL;	*SHOULD INVOKE STOP LOGIC	READ&larr;SADR, CALL[RETN];	*CHECK RESULTS	P&larr;MDRL, Q&larr;17R, CALL[PQCOMP];	*MDRL&larr; DIDN'T INVOKE STOP LOGIC	P&larr;LADR, CALL[AGEN];	GOTO[TSTOPB,ALU&gt;=0];INSERT[DGMB.MC];</pre>
  </body>
</html>
