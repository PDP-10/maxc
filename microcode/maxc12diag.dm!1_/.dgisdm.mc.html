<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0//EN">
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html;charset=UTF-8">
    <title>File [Indigo]&lt;Maxc>maxc12diag.dm!1>dgisdm.mc</title>
  </head>
  <body>
    <pre>
ER[DGISDM];%DIAGNOSTIC FOR INSTRUCTION, SCRATCH, DISPATCH, AND MAP MEMORIESTHIS FILE IS INCLUDED BY "DGIML" AND "DGIMH" WHICH TEST, RESPECTIVELY, HIGHAND LOW REGIONS OF IM.  FOR SCOPING, VARIABLES "RLOOK" (READING IM)AND "WLOOK" (WRITING IM) CAN BE LOADED WITH AN ADDRESS AND SIGNOVAWILL OCCUR JUST BEFORE THE READ/WRITE OF THE DESIGNATED ADDRESS.DATA COMPARE CAN BE MASKED BY "LMASK" AND "RMASK".RANGE OF IM ADDRESSES TESTED IS FROM "LADDR" TO "HADDR" INCLUSIVE.  THE DATAPATTERNS USED BEGIN AT "LADDR" WITH EACH OF THE 72 PATTERNS CONSISTING OF ASINGLE 0 IN A FIELD OF 1'S AND EACH OF THE 72 PATTERNS CONSISTING OF A SINGLE 1IN A FIELD OF 0'S.  SUBSEQUENT WORDS RECEIVE THE PREVIOUS WORD'S DATA LCY 1.RANDOM NO. PATTERNS ARE USED TO TEST DM, SM, MAP, AND IM AFTER THE 144FIXED PATTERNS FOR IM ARE EXHAUSTED.TO TEST ONLY IM, START AT "TIM".TO TEST ONLY MP, START AT "TMP".TO TEST ONLY SM, START AT "TSM".ON MAXC2, P&larr; PROVOKES SLOW CHIP FAILURESS BECAUSE P HAS A VERY EARLY WRITEENABLE.  Q&larr; IS NOT AS GOOD ON EITHER MAXC1 OR MAXC2 BECAUSE IT HAS A LATEWRITE ENABLE.ON MAXC2 PARITY CHECKING CAN BE TURNED ON BY SETTING "PARITY" TO THE PROPERVALUE--SEE THE COMMENT AT THE BOTTOM OF THIS PAGE.%SM[SLC,20]; RM[RLC,0]; LM[LLC,10];RV[X0,7654321];RV[X1,76543210];RV[X2,765432100];RV[X3,7654321000];RV[X4,76543210000];RV[X5,765432100000];RV[X6,654321000007];RV[X7,543210000076];LVN[RAN]; LVN[RRAN]; LVN[XRAN]; LVN[COUNT];LVN[LTEMP]; RVN[RTEMP]; RVN[ICOUNT];LVN[LDATA]; LVN[LDATA1]; RV[LMASK,777777 777777]; LVN[LBASE];RVN[RDATA]; RVN[RDATA1]; LV[RMASK,777777 777777]; RVN[RBASE];RV[WLOOK,0]; RV[RLOOK,0];SVN[ADDR]; RV[AINC,1];RV[SMMASK,777777 777777];RV[MPMASK,777777]; SVN[FSET];LV[PARITY,0];	*400 000000	ENABLES IM PE HALT		*200 000000	ENABLES SM/DM/DM1/DM2 PE HALT		*100 000000	ENABLES MP PE HALTMCYCLE:	BRKP[1], COUNT&larr;P+1, GOTO[LOOP];START:	ARM&larr;Y&larr;NULL, INHINT;	IRET, INHINT, COUNT&larr;A0, GOTO[INITL];PQCOMP:	P#Q;AZT:	RETURN[ALU=0];	BRKP[1];			*IN CASE SINGLE STEPPING	BRKP[1], RETURN;RETN:	RETURN;*INITIALIZE SM, MAP, DM, DM1, AND DM2 LOCATIONS BEFORE ARMING PARITY*(ONLY SM INIT NECESSARY NOW--MP INIT NECESSARY IF SWITCH TO NEW BIPOLAR*BOARD ON MP.)INITL:*~ MAXC2 ONLY	SY&larr;MAP&larr;NULL;	D&larr;NULL;	D1&larr;NULL;	D2&larr;NULL, INCY, GOTO[.-3,Y&gt;=0];	SY&larr;MAP&larr;NULL;	D&larr;NULL;	D1&larr;NULL;	D2&larr;NULL, INCY, Q&larr;PARITY, GOTO[.-3,Y&lt;0];	ARM&larr;Q, DGOTO[7], Q&larr;X7;		*INITIALIZE RANDOM NO. GEN.*~*! MAXC1 ONLY	DGOTO[7], Q&larr;X7;*!	X&larr;NPC, RAN&larr;Q, GOTO[.+1];	CALL[IMCYCT];		*CYCLED 1 AND CYCLED 0 TEST ONCE ONLYLOOP:	CALL[TSTIM];	CALL[TSTMP];	CALL[TSTSM];	P&larr;COUNT, GOTO[MCYCLE];TSTIM:	CALL[IMRANT];	RETURN;TSTMP:	CALL[MPRT1];		*RANDOM DATA, SEQUENTIAL ADDRESSES	CALL[MPRT2];		*RANDOM DATA, SEQUENTIAL ADDRESSES	P&larr;A1, SAMASK[12];	ICOUNT&larr;P-1, CALL[MPRT3];	*RANDOM DATA, RANDOM ADDRESS IN MPTSTMPL:	P&larr;ICOUNT;	ICOUNT&larr;P-1;	RETURN[ALU&lt;0];	CALL[MPRT3L];		*Q/ CORRECT VALUE, P/ MP[Y]	GOTO[TSTMPL];		*MPRT3S;G TO LOOP ON FAILURETSTSM:	CALL[SMDMT1];		*RANDOM DATA, SEQUENTIAL ADDRESSES	P&larr;A1, SAMASK[12], GOTO[SDR1];SDRLP:	CALL[SMT2];		*RANDOM DATA, RANDOM ADDRESS IN SM	CALL[DMT2];		*Q/ CORRECT VALUE, P,MDR/ DM[Y]*~ MAXC2 ONLY	CALL[DM1T2];		*Q/ CORRECT VALUE, P, MDR/ DM1[Y]	CALL[DM2T2];		*Q/ CORRECT VALUE, P, MDR/ DM2[Y]	CALL[SDM1B];*~	P&larr;ICOUNT;SDR1:	ICOUNT&larr;P-1, DGOTO[SDRLP];	RETURN[ALU&lt;0];*START HERE TO TEST ONLY IMTIM:	COUNT&larr;A0;TIMLP:	CALL[TSTIM];	P&larr;COUNT;	COUNT&larr;P+1, GOTO[TIMLP];*START HERE TO TEST ONLY THE MAPTMAP:	COUNT&larr;A0;TMAPLP:	CALL[TSTMP];	P&larr;COUNT;	COUNT&larr;P+1, GOTO[TMAPLP];*START HERE TO TEST ONLY SM, DM, DM1, AND DM2TSM:	COUNT&larr;A0;TSMLP:	CALL[TSTSM];	P&larr;COUNT;	COUNT&larr;P+1, GOTO[TSMLP];%"NIRGEN" IS THE SAME AS "RGEN" BELOW EXCEPT THAT IT LOOPSTO GENERATE THE NEXT RANDOM NUMBER WHENEVER THE BUS SOURCE OR BUSDESTINATION FIELDS SELECTS IM.  THIS BYPASSES A HARDWARE BUG.%NIRG1:	Q&larr;RAN, RETURN[ALU#0];NIRGEN:*! MAXC1 ONLY BUG	P&larr;RAN, Q&larr;RX, GOTO[NIRG2,X&gt;=0];	Q&larr;X7, DGOTO[6];	X&larr;NPC, RAN&larr;X7&larr;Q&larr;P+Q, GOTO[.+1];NIRG3:	P&larr;1634 000000L;	Q&larr;P#Q, P&larr;7600 000000L;	P AND Q, P&larr;174 000000L, DGOTO[NIRG1]; *BS=IM=7?	P AND Q, GOTO[NIRGEN,ALU=0]; *BD=IM=7?NIRG2:	RX&larr;RAN&larr;Q&larr;P+Q, DECX, GOTO[NIRG3];*!*RETURN RANDOM NO. IN Q (USES X WHICH MUST NOT BE CLOBBERED), CLOBBERS PRGEN:	P&larr;RAN, Q&larr;RX, GOTO[RGEN1,X&gt;=0];	DGOTO[6], Q&larr;X7;	X&larr;NPC, RAN&larr;X7&larr;Q&larr;P+Q, RETURN;RGEN1:	RX&larr;RAN&larr;Q&larr;P+Q, DECX, RETURN;*SAVE RANDOM NO. GEN. STATE IN LM FOR RESTORATION LATER.  RETURN RANDOM NO. IN Q.RMARK:	P&larr;X, DGOTO[7], Q&larr;RAN;	X&larr;NPC, GOTO[.+1], RRAN&larr;Q;	Q&larr;RX, GOTO[.+2,X&lt;0], XRAN&larr;P;	LX&larr;Q, DECX, GOTO[.-1];PXRET:	X&larr;P, Q&larr;RAN, GOTO[NIRGEN];*RESTORE RANDOM NO. GEN FROM LMRREST:	P&larr;RRAN, DGOTO[7];	X&larr;NPC, RAN&larr;P, GOTO[.+1];	Q&larr;LX, GOTO[PXRET,X&lt;0];	RX&larr;Q, P&larr;XRAN, DECX, GOTO[.-1];MPCOMP:	LTEMP&larr;Q&larr;P, P&larr;Q, SAMASK[22];		*P&larr;CORRECT VALUE, Q&larr;VALUE READ	RTEMP&larr;P;	P&larr;P#Q, Q&larr;MPMASK;	P AND Q, P&larr;LTEMP, Q&larr;RTEMP, GOTO[AZT];MPSMON:	FSET&larr;Q;	CLEARF[FSET], GOTO[RGEN];	*CLEAR CUM TO MAKE MONITOR MODE%TEST MP USING RANDOM NUMBERS, SEQUENTIAL ADDRESSES.  IN THIS FIRST TEST, THEADDRESSES HAVE MORE THAN ONE CYCLE SETUP AND CHANGE AT THE END OF THE CYCLE,SO HARD STORAGE FAILURES, WRITE FAILURES PROVOKED BY ADDRESS GOING AWAY TOOSOON, AND ADDRESS LATCHING PROBLEMS ARE PROVOKED.%MPRT1:	Q&larr;A1, CALL[MPSMON];		*START WITH MONITOR MAP	Y&larr;NULL, CALL[RMARK];		*SAVE STATE OF RANDOM NO. GEN.	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&gt;=0];	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&lt;0];	Y&larr;NULL, SETF[FSET], CALL[RETN];	*NOW USER MAP (DELAY AFTER SETF[CUM])	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&gt;=0];	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&lt;0];*NOW READ AND COMPAREMPRT1C:	Y&larr;NULL, CLEARF[FSET], CALL[RREST];	P&larr;MDR&larr;MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y&gt;=0];	P&larr;MDR&larr;MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y&lt;0];	Y&larr;NULL, SETF[FSET], CALL[RETN];	P&larr;MDR&larr;MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y&gt;=0];	P&larr;MDR&larr;MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	INCY, CALL[RGEN];	GOTO[.-2,Y&lt;0];	RETURN;%TEST MP USING RANDOM NUMBERS, SEQUENTIAL ADDRESSES.  ADDRESSES CHANGE IN THECYCLE BEFORE READS OR THE CYCLE AFTER WRITES, SO HARD STORAGE FAILURES,ADDRESS LATCHING PROBLEMS, AND SLOW CHIP FAILURES ARE PROVOKED.%MPRT2:	Q&larr;A1, CALL[MPSMON];		*START WITH MONITOR MAP	Y&larr;NULL, CALL[RMARK];		*SAVE STATE OF RANDOM NO. GEN.	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&gt;=0];	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&lt;0];	SETF[FSET], CALL[RETN];		*NOW USER MAP (DELAY AFTER SETF[CUM])	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&gt;=0];	MAP&larr;Q, INCY, CALL[RGEN];	GOTO[.-1,Y&lt;0];*NOW READ AND COMPAREMPRT2C:	Y&larr;NULL, CLEARF[FSET], CALL[RREST];	P&larr;MDR&larr;MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y&gt;=0];	P&larr;MDR&larr;MAP, CALL[MPCOMP,Y&lt;0];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y&lt;0];	Y&larr;NULL, SETF[FSET], GOTO[.+3];	P&larr;MDR&larr;MAP, CALL[MPCOMP];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y&gt;=0];	P&larr;MDR&larr;MAP, CALL[MPCOMP,Y&lt;0];		*Q/ CORRECT VALUE, P/ MP[Y]	CALL[RGEN];	INCY, GOTO[.-2,Y&lt;0];	RETURN;%TEST MP USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%MPRT3:	Q&larr;A1, CALL[MPSMON];	FSET&larr;Q;				*RANDOM CUMMPRT3L:	SETF[FSET], CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];		*RDATA/ RANDOM DATA	ADDR&larr;FSPLIT&larr;Q;			*ADDR[0,8]/ PREVIOUS ADDRESS	Y&larr;ADDR, Q&larr;RDATA;		*ADDR[27,35]/ ADDRESS WRITTEN-READ	MAP&larr;Q;	FSPLIT&larr;ADDR;	Y&larr;ADDR;	Q&larr;RDATA, P&larr;MDR&larr;MAP, GOTO[MPCOMP]; *COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF MPRT3LMPRT3S:	FSPLIT&larr;ADDR, Q&larr;RDATA;	Y&larr;ADDR, Q&larr;RDATA;	MAP&larr;Q;	FSPLIT&larr;ADDR;	Y&larr;ADDR, DGOTO[MPRT3S];	Q&larr;RDATA, P&larr;MDR&larr;MAP, CALL[MPCOMP];SMCOMP:	RTEMP&larr;P;	LTEMP&larr;Q;	P&larr;P#Q, Q&larr;SMMASK;	P AND Q, P&larr;RTEMP, Q&larr;LTEMP, GOTO[AZT];%TEST SM/DM USING RANDOM DATA, SEQUENTIAL ADDRESSES.  THE ADDRESS CHANGES INTHE CYCLE BEFORE EACH READ OR AFTER EACH WRITE TO CATCH SLOW TIMING PATHS.**A SLOWER DEVELOPMENT OF THE ADDRESS WOULD BE TO LOAD Y FROM A SLOW SOURCE**IN THE CYCLE BEFORE THE READ.%SMDMT1:	CALL[RGEN];	Y&larr;NULL, CALL[RMARK];SMDML1:	D&larr;Q, INCY, Q&larr;NOT Q;*~ MAXC2 ONLY	D1&larr;Q, INCY, Q&larr;NOT Q;	D2&larr;Q, DECY, Q&larr;NOT Q;*~	SY&larr;Q, DECY, CALL[RGEN];	INCY;	GOTO[SMDML1,Y&gt;=0];SMDML2:	D&larr;Q, Q&larr;NOT Q, INCY;*~ MAXC2 ONLY	D1&larr;Q, Q&larr;NOT Q, INCY;	D2&larr;Q, Q&larr;NOT Q, DECY;*~	SY&larr;Q, DECY, CALL[RGEN];	INCY;	GOTO[SMDML2,Y&lt;0];	Y&larr;A1, CALL[RREST];	*RESTORE ORIG. RANDOM NO. STATESMDMC1:	INCY;	P&larr;MDR&larr;D, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM[Y]	Q&larr;NOT Q, INCY;*~ MAXC2 ONLY	P&larr;MDR&larr;D1, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM1[Y]	Q&larr;NOT Q, INCY;	P&larr;MDR&larr;D2, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM2[Y]	Q&larr;NOT Q, DECY;*~	P&larr;MDR&larr;SY, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ SM[Y]	CALL[RGEN];	DECY, GOTO[SMDMC1,Y&gt;=0];SMDMC2:	INCY;	P&larr;MDR&larr;D, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM[Y]	Q&larr;NOT Q, INCY;*~ MAXC2 ONLY	P&larr;MDR&larr;D1, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM1[Y]	Q&larr;NOT Q, INCY;	P&larr;MDR&larr;D2, CALL[SMCOMP];	*Q/ CORRECT VALUE, P/ DM2[Y]	Q&larr;NOT Q, DECY;*~	P&larr;MDR&larr;SY, CALL[SMCOMP];	CALL[RGEN];	DECY, GOTO[SMDMC2,Y&lt;0];	RETURN;%TEST SM USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%SMT2:	CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA&larr;FSPLIT&larr;P&larr;Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y&larr;P, Q&larr;RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	SY&larr;Q, P&larr;LDATA, INCY;	FSPLIT&larr;P;	Y&larr;P;	Q&larr;RDATA, P&larr;MDR&larr;SY, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF SMT2SMTS:	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, Q&larr;RDATA;	SY&larr;Q;	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, DGOTO[SMTS];	Q&larr;RDATA, P&larr;MDR&larr;SY, CALL[SMCOMP];*~ MAXC2 ONLY%TEST SM, DM, DM1, DM2 TRYING TO PROVOKE FAILURES CAUSED BY FREQUENT SWITCHINGOF THE CHIP SELECTS.%SDM1B:	CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];	LDATA&larr;Q, CALL[RGEN];	RDATA1&larr;Q, CALL[RGEN];	LDATA1&larr;Y&larr;Q;	FSPLIT&larr;Q;		*Y CHANGING BEFORE WRITE	SY&larr;Y&larr;Q, Q&larr;RDATA1;	*AND AFTER WRITE OF SM	D1&larr;Q, Q&larr;LDATA, NEGY;	*CHIP SELECT CHANGES HERE	D&larr;Q, Q&larr;RDATA, NEGY;	*AND HERE	D2&larr;Q, Q&larr;LDATA1, NEGY;	*AND HERE	FSPLIT&larr;Q;	P&larr;Y&larr;SY, CALL[SMCOMP];			*P/ SM[LDATA1[0,8]], Q/ SHOULD BE	Q&larr;RDATA1, P&larr;D1, NEGY, CALL[SMCOMP];	*P/ DM1[-Y], Q/ SHOULD BE	Q&larr;LDATA, P&larr;D, NEGY, CALL[SMCOMP];	*P/ DM[-Y], Q/ SHOULD BE	Q&larr;RDATA, P&larr;D2, NEGY, CALL[SMCOMP];	*P/ DM2[-Y], Q/ SHOULD BE	RETURN;*~%TEST DM USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%DMT2:	CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA&larr;FSPLIT&larr;P&larr;Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y&larr;P, Q&larr;RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	D&larr;Q, P&larr;LDATA, INCY;	FSPLIT&larr;P;	Y&larr;P;	Q&larr;RDATA, P&larr;MDR&larr;D, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF DMT2DMTS:	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, Q&larr;RDATA;	D&larr;Q;	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, DGOTO[DMTS];	Q&larr;RDATA, P&larr;MDR&larr;D, CALL[SMCOMP];%TEST DM1 USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%*~ MAXC2 ONLYDM1T2:	CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA&larr;FSPLIT&larr;P&larr;Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y&larr;P, Q&larr;RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	D1&larr;Q, P&larr;LDATA, INCY;	FSPLIT&larr;P;	Y&larr;P;	Q&larr;RDATA, P&larr;MDR&larr;D1, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF DM1T2DM1TS:	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, Q&larr;RDATA;	D1&larr;Q;	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, DGOTO[DM1TS];	Q&larr;RDATA, P&larr;MDR&larr;D1, CALL[SMCOMP];%TEST DM2 USING RANDOM ADDRESSES AND RANDOM DATA.  TWO RANDOM ADDRESSES AREGENERATED AND RANDOM DATA.  Y CHANGES FROM THE FIRST RANDOM ADDRESS TO THESECOND IN THE CYCLE BEFORE THE READ/WRITE.%DM2T2:	CALL[RGEN];	RDATA&larr;Q, CALL[RGEN];		*RDATA/ RANDOM DATA	LDATA&larr;FSPLIT&larr;P&larr;Q;		*LDATA[0,8]/ PREVIOUS ADDRESS	Y&larr;P, Q&larr;RDATA;			*LDATA[27,35]/ ADDRESS WRITTEN-READ	D2&larr;Q, P&larr;LDATA, INCY;	FSPLIT&larr;P;	Y&larr;P;	Q&larr;RDATA, P&larr;MDR&larr;D2, GOTO[SMCOMP];	*COMPARE AND RETURN*SCOPE LOOP TO USE AFTER FAILURES OF DM2T2DM2TS:	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, Q&larr;RDATA;	D2&larr;Q;	P&larr;LDATA;	FSPLIT&larr;P;	Y&larr;P, DGOTO[DM2TS];	Q&larr;RDATA, P&larr;MDR&larr;D2, CALL[SMCOMP];*~*WRITE IM[ADDR] WITH RDATA AND LDATA.  ADDR#WLOOK THRU ALU AT CALL.*! MAXC1 ONLYWIM:	GOTO[.+2,ALU#0];	SIGNOVA;	P&larr;NPC&larr;ADDR, Q&larr;RDATA;	I&larr;Q,DGOTO[.+1];  *2 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];	P&larr;NPC&larr;ADDR, GOTO[.+1], Q&larr;LDATA;	I&larr;Q, DGOTO[.+1], Q&larr;AINC, INHINT;  *5 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];	P&larr;HADDR, Q&larr;P+Q, RETURN;*!*~ MAXC2 ONLYWIM:	Q&larr;RDATA, GOTO[.+2,ALU=0];	B&larr;Q, GOTO[.+2];	B&larr;Q, SIGNOVA;	NPC&larr;ADDR, FRZBALUBC;	*FREEZE EREG	P&larr;I&larr;EREG, DGOTO[.+1]; *2 CYCLES AFTER SIGNOVA IM[36,71]	P#Q, Q&larr;LDATA;	B&larr;Q, GOTO[.+2,ALU=0];	BRKP[1];		*EREG WRONG AFTER IM WRITE	NPC&larr;ADDR, FRZBALUBC;	P&larr;I&larr;EREG, INHINT, DGOTO[.+1];	P#Q, P&larr;ADDR, Q&larr;AINC;	*6 CYCLES AFTER SIGNOVA IM[0,35]	P&larr;HADDR, Q&larr;P+Q, RETURN[ALU=0];	BRKP[1];		*EREG WRONG AFTER IM WRITE*~*READ IM[ADDR], MASK IT WITH LMASK AND RMASK, AND COMPARE TO LDATA AND RDATA.*ADDR#RLOOK THRU ALU AT CALL.RIM:	GOTO[.+2,ALU#0];	SIGNOVA;	NPC&larr;ADDR;*! MAXC1 ONLY	P&larr;I, DGOTO[.+1], Q&larr;RMASK;  *2 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];*!*~ MAXC2 ONLY	I, Q&larr;RMASK, DGOTO[.+1];	MDR&larr;P&larr;EREG, GOTO[.+1];*~	LTEMP&larr;P AND Q, GOTO[.+1], P&larr;RDATA;	P&larr;P AND Q, Q&larr;LTEMP, CALL[PQCOMP];*RIGHT HALF OF IM ENTRY [ADDR] MASKED BY [RMASK] SHOULD HAVE BEEN P *BUT WAS Q	NPC&larr;ADDR;*! MAXC1 ONLY	P&larr;I, INHINT, DGOTO[.+1], Q&larr;LMASK;  *9 CYCLES AFTER SIGNOVA	INHINT, GOTO[.+1];*!*~ MAXC2 ONLY	I, INHINT, Q&larr;LMASK, DGOTO[.+1];	MDR&larr;P&larr;EREG, GOTO[.+1];*~	RTEMP&larr;P AND Q, GOTO[.+1], P&larr;LDATA;	P&larr;P AND Q, Q&larr;RTEMP, CALL[PQCOMP];*LEFT HALF OF IM ENTRY [ADDR] MASKED BY [LMASK] SHOULD HAVE BEEN P*BUT WAS Q	P&larr;ADDR, Q&larr;AINC;	Q&larr;P+Q, P&larr;HADDR, RETURN;*LOOP TO REPEAT "WIM" AFTER PARITY ERRORS*~ MAXC2 ONLYWIMREP:	Q&larr;RDATA;	B&larr;Q, SIGNOVA;	NPC&larr;ADDR, FRZBALUBC;	*FREEZE EREG	P&larr;I&larr;EREG, DGOTO[.+1];	P#Q, Q&larr;LDATA;	B&larr;Q, GOTO[.+2,ALU=0];	BRKP[1];		*EREG WRONG	NPC&larr;ADDR, FRZBALUBC;	P&larr;I&larr;EREG, INHINT, DGOTO[.+1];	P#Q, P&larr;ARM, Q&larr;17700 000000L;	P AND Q, GOTO[.+2,ALU=0];	BRKP[1];		*EREG WRONG	Q&larr;PARITY, GOTO[WIMREP,ALU=0];	BRKP[1], ARM&larr;Q, GOTO[WIMREP];*~DCYCLE:	PQ LCY [1],FRZBALUBC, Q&larr;LDATA;	LDATA&larr;P, P&larr;RDATA, FRZBALUBC;	PQ LCY [1], FRZBALUBC, RETURN, Q&larr;ADDR;*STARTING WITH THE 72 BIT NUMBER &lt;LBASE,RBASE&gt;, WRITE FROM ADDRESS*LADDR TO HADDR SEQUENTIALLY LEFT CYCLED PATTERNSRWT1:	P&larr;LBASE,Q&larr;RBASE;	RDATA&larr;Q, Q&larr;LADDR;	LDATA&larr;P, P&larr;WLOOK;RWT2:	P#Q, ADDR&larr;Q, CALL[WIM];	P-Q, ADDR&larr;Q, P&larr;LDATA, Q&larr;RDATA, CALL[DCYCLE];	RDATA&larr;P, FRZBALUBC;	P&larr;WLOOK, GOTO[RWT2,ALU&gt;=0];*NOW READ AND COMPARE	P&larr;LBASE, Q&larr;RBASE;	RDATA&larr;Q, Q&larr;LADDR;	LDATA&larr;P, P&larr;RLOOK;RWT3:	P#Q, ADDR&larr;Q, CALL[RIM];	P-Q, ADDR&larr;Q, P&larr;LDATA, Q&larr;RDATA, CALL[DCYCLE];	RDATA&larr;P, FRZBALUBC, DGOTO[RWT3];	RETURN[ALU&lt;0], P&larr;RLOOK;*TEST IM USING 72 PATTERNS OF SINGLE 0 IN FIELD OF 1'S AND 72 PATTERNS*OF SINGLE 1 IN FIELD OF 0'SIMCYCT:	LBASE&larr;P&larr;A0;	RBASE&larr;P+1,CALL[RWT1];IMRWT1:	P&larr;LBASE, Q&larr;RBASE;	PQ LCY [1],Q&larr;LBASE;	LBASE&larr;P,P&larr;RBASE;	PQ LCY [1];	RBASE&larr;P;	DGOTO[IMRWT1,ALU&gt;=0];	CALL[RWT1];*RETURN HERE WHEN 72 PATTERNS OF A SINGLE 1 IN A FIELD OF 0'S ARE EXHAUSTED	LBASE&larr;P&larr;A1;	RBASE&larr;2P,CALL[RWT1];IMRWT2:	P&larr;LBASE,Q&larr;RBASE;	PQ LCY [1],Q&larr;LBASE;	LBASE&larr;P,P&larr;RBASE;	PQ LCY [1];	RBASE&larr;P;	DGOTO[IMRWT2,ALU&lt;0];	CALL[RWT1];	RETURN;*NOW TEST IM USING RANDOM NO.'SIMRANT:	Q&larr;LADDR, DGOTO[WRANIM];	ADDR&larr;Q, CALL[RMARK];WRANE:	ADDR&larr;Q, CALL[NIRGEN];WRANIM:	RDATA&larr;Q, CALL[RGEN];	LDATA&larr;Q, Q&larr;ADDR, P&larr;HADDR, DGOTO[WRANE];	P-Q, P&larr;WLOOK, CALL[.+1];	P#Q, GOTO[WIM,ALU&gt;=0];*NOW READ AND COMPARE	Q&larr;LADDR, POP, DGOTO[RRANIM];	ADDR&larr;Q, CALL[RREST];RRANE:	ADDR&larr;Q, CALL[NIRGEN];RRANIM:	RDATA&larr;Q, CALL[RGEN];	LDATA&larr;Q, Q&larr;ADDR, P&larr;HADDR, DGOTO[RRANE];	P-Q, P&larr;RLOOK, CALL[.+1];	P#Q, GOTO[RIM,ALU&gt;=0];	POP;	RETURN;</pre>
  </body>
</html>
